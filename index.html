<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corner Predictor - Over 9.5 Analiza</title>
    <style>
        /* Kolory Arsenal: czerwony #EF0107, bia≈Çy #FFFFFF, granatowy #023474 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            padding: 30px 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 20px rgba(239, 1, 7, 0.3);
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            color: #FFFFFF;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }

        header .subtitle {
            color: #FFFFFF;
            font-size: 1.1em;
            opacity: 0.95;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: #EF0107;
            color: #FFFFFF;
        }

        .btn-primary:hover {
            background: #cc0000;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(239, 1, 7, 0.4);
        }

        .btn-secondary {
            background: #023474;
            color: #FFFFFF;
        }

        .btn-secondary:hover {
            background: #011f4a;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(2, 52, 116, 0.4);
        }

        .btn-white {
            background: #FFFFFF;
            color: #EF0107;
        }

        .btn-white:hover {
            background: #f5f5f5;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.3);
        }

        /* Cards */
        .card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(239, 1, 7, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .card-header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 15px 20px;
            border-radius: 10px;
            margin: -25px -25px 20px -25px;
            font-size: 1.3em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header.blue {
            background: linear-gradient(135deg, #023474 0%, #011f4a 100%);
        }

        /* Match List */
        .match-item {
            background: rgba(255, 255, 255, 0.03);
            border-left: 4px solid #EF0107;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .match-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-left-color: #023474;
            transform: translateX(5px);
        }

        .match-time {
            color: #FFFFFF;
            font-weight: bold;
            display: inline-block;
            width: 70px;
        }

        .match-teams {
            color: #FFFFFF;
            font-size: 1.1em;
            margin: 5px 0;
        }

        .match-league {
            color: #EF0107;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(2, 52, 116, 0.5);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #EF0107;
            margin: 10px 0;
        }

        .stat-label {
            color: #FFFFFF;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #EF0107;
            font-size: 1.2em;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #EF0107;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Kontener dla komunikat√≥w */
        #messages-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .message-item {
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 1, 7, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 1, 7, 0);
            }
        }

        /* League Section - Two Column Layout */
        #matches-container {
            margin-top: 20px;
        }

        .league-section {
            margin-bottom: 0;
            break-inside: avoid;
        }

        .league-title {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        /* Responsive - jedna kolumna na ma≈Çych ekranach */
        @media (max-width: 768px) {
            #matches-container {
                grid-template-columns: 1fr;
            }
            
            #analysis-content > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
        }

        /* Analysis Window */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 50px auto;
            padding: 30px;
            border: 3px solid #EF0107;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(239, 1, 7, 0.5);
        }

        /* Blokada przewijania strony w tle gdy modal otwarty */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .close {
            color: #FFFFFF;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #EF0107;
        }

        /* Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th {
            background: #023474;
            color: #FFFFFF;
            padding: 15px;
            text-align: left;
            border-bottom: 3px solid #EF0107;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        tr:hover {
            background: rgba(239, 1, 7, 0.1);
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-success {
            background: #4CAF50;
            color: #FFFFFF;
        }

        .badge-danger {
            background: #EF0107;
            color: #FFFFFF;
        }

        .badge-warning {
            background: #FF9800;
            color: #FFFFFF;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öΩ Corner Predictor</h1>
            <p class="subtitle">Analiza Over 9.5 Rzut√≥w Ro≈ºnych</p>
        </header>

        <div class="button-group">
            <button class="btn btn-primary" onclick="fetchMatches()">üîÑ Pobierz Mecze</button>
            <button class="btn btn-secondary" onclick="analyzeOver95()">üìä Analizuj Over 9.5</button>
            <button class="btn btn-secondary" onclick="analyzeCards()" style="background: #FFA500; color: #000;">üü® Analizuj Kartki</button>
            <button class="btn btn-white" onclick="showHistory()">üìú Historia</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Pobieranie danych...</p>
        </div>

        <div id="stats" class="stats-grid" style="display: none;">
            <div class="stat-card">
                <div class="stat-label">Dzisiejsze Mecze</div>
                <div class="stat-value" id="total-matches">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Ligi</div>
                <div class="stat-value" id="total-leagues">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">KwalifikujƒÖce siƒô</div>
                <div class="stat-value" id="qualified-matches">0</div>
            </div>
        </div>

        <div id="matches-container"></div>
    </div>

    <!-- Modal dla analizy -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('analysisModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">üìä Analiza Over 9.5</h2>
            <div id="analysis-content"></div>
        </div>
    </div>

    <!-- Modal dla historii -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('historyModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">üìú Historia Mecz√≥w</h2>
            <div id="history-content"></div>
        </div>
    </div>

    <!-- Modal dla analizy kartek -->
    <div id="cardsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('cardsModal')">&times;</span>
            <h2 style="color: #FFA500; margin-bottom: 20px;">üü® Analiza Kartek (Over 3.5)</h2>
            <div id="cards-content"></div>
        </div>
    </div>

    <footer>
        <p>Corner Predictor - System analizy rzut√≥w ro≈ºnych Over 9.5</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Powered by Football Data API</p>
    </footer>

    <script>
        // API Configuration
        const API_KEY = '8cdad7757b702fae3b792c0b3328017ee33cc17594b18ea8a2717cdc53162325';
        
        // Konfiguracja: u≈ºyj lokalnego proxy servera (uruchom: python3 proxy_server.py)
        const BASE_URL = 'http://localhost:8080/api';
        const USE_PROXY = false; // false = u≈ºywa lokalnego proxy, true = u≈ºywa zewnƒôtrznych proxy (czƒôsto 403)
        
        // Debug: sprawd≈∫ konfiguracjƒô
        console.log('üîß Konfiguracja API:', { BASE_URL, USE_PROXY, proxy: getProxy() });
        
        // Proxy dla CORS - wiƒôcej opcji na wypadek blokad
        const PROXY_SERVICES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://thingproxy.freeboard.io/fetch/',
        ];
        let currentProxyIndex = 0;
        
        function getProxy() {
            if (!USE_PROXY) return ''; // Brak proxy je≈õli u≈ºywamy lokalnego serwera
            return PROXY_SERVICES[currentProxyIndex];
        }

        // Global state
        let matchesData = [];
        let leaguesData = {};
        let teamsData = {};
        let analyzedMatches = [];
        let lastAnalysisHash = null; // Hash mecz√≥w z ostatniej analizy

        // Fetch matches from API
        async function fetchMatches() {
            showLoading(true);
            displayMessage('Pobieranie mecz√≥w z API...', 'info');
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const proxy = getProxy();
                
                // Je≈õli u≈ºywasz lokalnego proxy, API_KEY jest ju≈º w URL przez backend
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/todays-matches?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/todays-matches`;
                }
                
                console.log('Pobieranie mecz√≥w z:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success || !data.data || !Array.isArray(data.data)) {
                    throw new Error('Brak danych w odpowiedzi API');
                }
                
                // Filtruj tylko mecze z dzisiaj (wed≈Çug date_unix w UTC)
                // date_unix z API jest w UTC, wiƒôc musimy u≈ºyƒá UTC do obliczania przedzia≈Ç√≥w
                const todayUTC = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
                const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000); // Unix timestamp poczƒÖtku dnia UTC
                const todayEnd = todayStart + 86399; // +23:59:59 = 86399 sekund
                
                const allMatches = data.data || [];
                console.log(`üìÖ Pobrano ${allMatches.length} mecz√≥w z API`);
                console.log(`üìÖ Dzisiejszy zakres UTC: ${new Date(todayStart * 1000).toISOString()} - ${new Date(todayEnd * 1000).toISOString()}`);
                
                // Pokazuj WSZYSTKIE mecze z dzisiaj - niezale≈ºnie od statusu (rozegrane, trwajƒÖce, oczekujƒÖce)
                // Rozszerzamy zakres o 6 godzin wcze≈õniej aby uwzglƒôdniƒá r√≥≈ºnice stref czasowych
                // NIE rozszerzamy w przysz≈Ço≈õƒá - mecze z nastƒôpnego dnia nie powinny siƒô pokazywaƒá
                const extendedStart = todayStart - 21600; // 6 godzin wcze≈õniej
                const extendedEnd = todayEnd; // Koniec dnia (bez rozszerzania w przysz≈Ço≈õƒá)
                
                const filteredOut = [];
                matchesData = allMatches.filter(match => {
                    const matchDateUnix = match.date_unix;
                    const status = match.status || 'unknown';
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    
                    if (!matchDateUnix) {
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: 'brak date_unix', status});
                        return false;
                    }
                    
                    // Sprawd≈∫ czy mecz jest w zakresie dzisiaj (z rozszerzeniem wstecz, ale nie w prz√≥d)
                    // Dodatkowo sprawd≈∫ czy data meczu (bez czasu) to dzisiaj
                    const matchDateObj = new Date(matchDateUnix * 1000);
                    // Por√≥wnaj daty jako stringi YYYY-MM-DD w UTC
                    const matchDateStr = matchDateObj.toISOString().split('T')[0];
                    
                    // Mecz musi byƒá w zakresie czasowym I mieƒá datƒô dzisiaj
                    const isInTimeRange = matchDateUnix >= extendedStart && matchDateUnix <= extendedEnd;
                    const isTodayDate = matchDateStr === todayUTC;
                    
                    const isInRange = isInTimeRange && isTodayDate;
                    
                    if (!isInRange) {
                        const matchDateFullStr = matchDateObj.toISOString();
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: `poza zakresem (${matchDateFullStr})`, status});
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`‚úÖ Filtrowanie mecz√≥w: ${allMatches.length} wszystkich, ${matchesData.length} pokazanych (wszystkie statusy)`);
                if (filteredOut.length > 0) {
                    console.log(`‚ùå Odfiltrowano ${filteredOut.length} mecz√≥w:`);
                    filteredOut.forEach((item, idx) => {
                        console.log(`   ${idx + 1}. ${item.match} - ${item.reason} (status: ${item.status})`);
                    });
                }
                
                // Loguj pokazane mecze z ich statusami
                console.log(`üìã Pokazane mecze (${matchesData.length}):`);
                matchesData.forEach((match, idx) => {
                    const status = match.status || 'unknown';
                    const time = match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-';
                    console.log(`   ${idx + 1}. ${match.home_name} vs ${match.away_name} (${time}) - status: ${status}`);
                });
                
                // Zapisz do localStorage
                localStorage.setItem('matchesData', JSON.stringify(matchesData));
                localStorage.setItem('matchesDate', today);
                
                // Je≈õli mecze siƒô zmieni≈Çy, wyczy≈õƒá cache analizy
                const currentHash = createMatchesHash(matchesData);
                const cachedHash = localStorage.getItem('lastAnalysisHash');
                if (cachedHash !== currentHash) {
                    console.log('üìã Mecze siƒô zmieni≈Çy - czyszczƒô cache analizy');
                    localStorage.removeItem('lastAnalysis');
                    localStorage.removeItem('lastAnalysisHash');
                    analyzedMatches = [];
                    lastAnalysisHash = null;
                }
                
                showLoading(false);
                displayMatches();
                displayMessage(`‚úì Pobrano ${matchesData.length} mecz√≥w!`, 'success');
            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd pobierania mecz√≥w:', error);
                displayMessage('B≈ÇƒÖd pobierania danych: ' + error.message, 'error');
                
                // Spr√≥buj za≈Çadowaƒá z localStorage
                const savedMatches = localStorage.getItem('matchesData');
                const savedDate = localStorage.getItem('matchesDate');
                if (savedMatches && savedDate === new Date().toISOString().split('T')[0]) {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj te≈º z cache (na wypadek je≈õli by≈Çy w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('Za≈Çadowano dane z cache', 'info');
                }
            }
        }

        // Display matches
        function displayMatches() {
            const container = document.getElementById('matches-container');
            if (matchesData.length === 0) {
                container.innerHTML = '<div class="card" style="grid-column: 1 / -1;"><p style="color: #FFFFFF; text-align: center;">Brak mecz√≥w do wy≈õwietlenia</p></div>';
                return;
            }
            
            // Pobierz nazwy lig (z cache je≈õli dostƒôpne)
            let leaguesMap = {};
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    leaguesMap = JSON.parse(saved);
                }
            } catch (e) {
                console.error('B≈ÇƒÖd odczytu leaguesMap:', e);
            }
            
            // Grupuj mecze wed≈Çug ligi
            const matchesByLeague = {};
            matchesData.forEach(match => {
                const competitionId = match.competition_id;
                const leagueKey = leaguesMap[competitionId] || `Liga ID: ${competitionId}`;
                
                if (!matchesByLeague[leagueKey]) {
                    matchesByLeague[leagueKey] = [];
                }
                matchesByLeague[leagueKey].push(match);
            });
            
            // Przygotuj ligi z informacjƒÖ o liczbie mecz√≥w
            const leagueEntries = Object.entries(matchesByLeague).map(([key, matches]) => ({
                key,
                matches,
                count: matches.length
            }));
            
            // Sortuj ligi wed≈Çug liczby mecz√≥w (malejƒÖco)
            leagueEntries.sort((a, b) => b.count - a.count);
            
            // Podziel ligi na pary - w ka≈ºdej parze lewa (A) ma wiƒôcej mecz√≥w ni≈º prawa (B)
            const leaguePairs = [];
            for (let i = 0; i < leagueEntries.length; i += 2) {
                if (i + 1 < leagueEntries.length) {
                    // Para lig - upewnij siƒô, ≈ºe lewa ma wiƒôcej
                    const left = leagueEntries[i];
                    const right = leagueEntries[i + 1];
                    if (left.count >= right.count) {
                        leaguePairs.push([left, right]);
                    } else {
                        leaguePairs.push([right, left]);
                    }
                } else {
                    // Ostatnia liga bez pary - dodaj do lewej kolumny
                    leaguePairs.push([leagueEntries[i], null]);
                }
            }
            
            // Funkcja do generowania HTML dla sekcji ligi
            const generateLeagueHTML = (league) => {
                if (!league) return '';
                const matchText = league.count === 1 ? '1 mecz' : `${league.count} mecz√≥w`;
                let html = `
                    <div class="league-section">
                        <div class="league-title">üèÜ ${league.key} (${matchText})</div>
                `;
                
                league.matches.forEach(match => {
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    const dateUnix = match.date_unix;
                    const status = match.status || 'pending';
                    let timeStr = '-';
                    let statusBadge = '';
                    
                    if (dateUnix) {
                        const date = new Date(dateUnix * 1000);
                        timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                    }
                    
                    // Dodaj badge statusu
                    if (status === 'complete' || status === 'finished' || status === 'FT') {
                        statusBadge = '<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">Zako≈Ñczony</span>';
                    } else if (status === 'live' || status === 'inplay' || status === 'LIVE') {
                        statusBadge = '<span style="background: #EF0107; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">LIVE</span>';
                    } else if (status === 'pending' || status === 'scheduled') {
                        statusBadge = '<span style="background: #FF9800; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">Oczekuje</span>';
                    }
                    
                    html += `
                        <div class="match-item">
                            <span class="match-time">${timeStr}</span>
                            <div class="match-teams">${homeName} vs ${awayName} ${statusBadge}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                return html;
            };
            
            // Generuj HTML - ka≈ºda para lig w osobnym wierszu
            let html = '';
            leaguePairs.forEach(([leftLeague, rightLeague]) => {
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">';
                html += '<div>' + generateLeagueHTML(leftLeague) + '</div>';
                html += '<div>' + generateLeagueHTML(rightLeague) + '</div>';
                html += '</div>';
            });
            
            container.innerHTML = html;
            
            // Aktualizuj statystyki
            document.getElementById('total-matches').textContent = matchesData.length;
            document.getElementById('total-leagues').textContent = leagueEntries.length;
            document.getElementById('stats').style.display = 'grid';
        }

        // Fetch team stats from API
        async function fetchTeamStats(teamId, competitionId) {
            try {
                const proxy = getProxy();
                
                // Najpierw spr√≥buj league-season
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-season?season_id=${competitionId}`;
                }
                let response = await fetch(url);
                
                // Je≈õli 403 i u≈ºywamy zewnƒôtrznego proxy, spr√≥buj zmieniƒá proxy
                if (response.status === 403 && USE_PROXY) {
                    console.warn(`‚ö†Ô∏è 403 Forbidden dla league-season, pr√≥bujƒô zmieniƒá proxy...`);
                    // Pr√≥buj nastƒôpnego proxy
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                } else if (response.status === 403 && !USE_PROXY) {
                    console.error('‚ùå 403 Forbidden - sprawd≈∫ czy proxy server dzia≈Ça na localhost:8080');
                    console.error('   Uruchom: python3 proxy_server.py');
                }
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.data) {
                        // Znajd≈∫ dru≈ºynƒô w danych
                        const clubs = Array.isArray(data.data) ? data.data : (data.data.clubs || []);
                        for (const club of clubs) {
                            if (club.id === teamId) {
                                return club;
                            }
                        }
                    }
                }
                
                // Fallback: pobierz mecze z ligi
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-matches?season_id=${competitionId}`;
                }
                response = await fetch(url);
                
                // Je≈õli 403 i u≈ºywamy zewnƒôtrznego proxy, spr√≥buj zmieniƒá proxy
                if (response.status === 403 && USE_PROXY) {
                    console.warn(`403 Forbidden dla league-matches, pr√≥bujƒô zmieniƒá proxy...`);
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                }
                
                if (!response.ok) {
                    console.error(`B≈ÇƒÖd pobierania league-matches: ${response.status}`);
                    return null;
                }
                
                const data = await response.json();
                if (!data.success || !data.data) return null;
                
                // Filtruj mecze z tƒÖ dru≈ºynƒÖ (zako≈Ñczone)
                const teamMatches = data.data
                    .filter(m => m.status === 'complete' && (m.homeID === teamId || m.awayID === teamId))
                    .sort((a, b) => (b.date_unix || 0) - (a.date_unix || 0))
                    .slice(0, 5);
                
                if (teamMatches.length === 0) return null;
                
                // Oblicz statystyki z mecz√≥w
                return calculateStatsFromMatches(teamMatches, teamId);
                
            } catch (error) {
                console.error('B≈ÇƒÖd pobierania statystyk:', error);
                return null;
            }
        }

        // Calculate stats from matches
        function calculateStatsFromMatches(matches, teamId) {
            if (!matches || matches.length === 0) return null;
            
            let totalCorners = 0;
            let totalShots = 0;
            let totalPossession = 0;
            let totalDangerousAttacks = 0;
            let over95Count = 0;
            const recentMatches = [];
            
            matches.forEach(match => {
                const isHome = match.homeID === teamId;
                const corners = isHome ? (match.team_a_corners || 0) : (match.team_b_corners || 0);
                const oppCorners = isHome ? (match.team_b_corners || 0) : (match.team_a_corners || 0);
                const totalCornerCount = (match.totalCornerCount || 0);
                
                const shots = isHome ? (match.team_a_shots || 0) : (match.team_b_shots || 0);
                const possession = isHome ? (match.team_a_possession || 0) : (match.team_b_possession || 0);
                const dangerousAttacks = isHome ? (match.team_a_dangerous_attacks || 0) : (match.team_b_dangerous_attacks || 0);
                
                totalCorners += corners;
                totalShots += shots;
                totalPossession += possession;
                totalDangerousAttacks += dangerousAttacks;
                
                if (totalCornerCount > 9.5) {
                    over95Count++;
                }
                
                recentMatches.push({
                    totalCornerCount: totalCornerCount,
                    corners: corners,
                    shots: shots,
                    possession: possession,
                    dangerousAttacks: dangerousAttacks
                });
            });
            
            const matchCount = matches.length;
            
            return {
                avg_corners: totalCorners / matchCount,
                avg_shots: totalShots / matchCount,
                avg_possession: totalPossession / matchCount,
                avg_dangerous_attacks: totalDangerousAttacks / matchCount,
                over95_percentages: [(over95Count / matchCount) * 100],
                recent_matches: recentMatches
            };
        }

        // Calculate Over 9.5 percentage
        function calculateOver95Percentage(stats) {
            if (!stats || !stats.recent_matches || stats.recent_matches.length === 0) {
                // Spr√≥buj z over95_percentages je≈õli dostƒôpne
                if (stats?.over95_percentages && stats.over95_percentages.length > 0) {
                    return stats.over95_percentages[0];
                }
                return 0;
            }
            
            const validMatches = stats.recent_matches.filter(m => m.totalCornerCount !== -1 && m.totalCornerCount !== undefined);
            if (validMatches.length === 0) return 0;
            
            const over95Count = validMatches.filter(m => m.totalCornerCount > 9.5).length;
            return (over95Count / validMatches.length) * 100;
        }

        // Analyze single match
        function analyzeMatch(match, homeStats, awayStats) {
            const homePercent = calculateOver95Percentage(homeStats);
            const awayPercent = calculateOver95Percentage(awayStats);
            
            // Podstawowe wymaganie
            const meetsBasic = homePercent >= 50 && awayPercent >= 50;
            
            // Oblicz statystyki
            const avgShotsHome = homeStats?.avg_shots || 0;
            const avgShotsAway = awayStats?.avg_shots || 0;
            const avgPossessionHome = homeStats?.avg_possession || 0;
            const avgPossessionAway = awayStats?.avg_possession || 0;
            const avgDangerousAttacksHome = homeStats?.avg_dangerous_attacks || 0;
            const avgDangerousAttacksAway = awayStats?.avg_dangerous_attacks || 0;
            
            // Min ro≈ºne
            const homeRecent = homeStats?.recent_matches || [];
            const awayRecent = awayStats?.recent_matches || [];
            
            const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            
            const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
            const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
            
            // ≈örednia ≈ÇƒÖcznych ro≈ºnych
            const avgTotalCornersHome = homeValidCorners.length > 0 
                ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length 
                : 0;
            const avgTotalCornersAway = awayValidCorners.length > 0 
                ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length 
                : 0;
            
            // Kategorie
            const categories = [];
            let score = 0;
            
            // 1. Over 9.5
            const avgOver95 = (homePercent + awayPercent) / 2;
            const sumOver95 = homePercent + awayPercent;
            const meetsOver95 = (
                avgOver95 >= 60 ||
                sumOver95 >= 100 ||
                (homePercent >= 60 && awayPercent >= 40) ||
                (awayPercent >= 60 && homePercent >= 40)
            );
            if (meetsOver95) {
                categories.push(`‚úì Over 9.5 ‚â• 60% (${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%)`);
                score++;
            } else {
                categories.push(`‚úó Over 9.5 = ${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%`);
            }
            
            // 2. Strza≈Çy
            if (avgShotsHome > 14 && avgShotsAway > 14) {
                categories.push(`‚úì Strza≈Çy > 14 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Strza≈Çy = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
            }
            
            // 3. Posiadanie
            if (avgPossessionHome >= 45 && avgPossessionAway >= 45) {
                categories.push(`‚úì Posiadanie ‚â• 45% (${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%)`);
                score++;
            } else {
                categories.push(`‚úó Posiadanie = ${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%`);
            }
            
            // 4. Niebezpieczne ataki
            if (avgDangerousAttacksHome > 50 && avgDangerousAttacksAway > 50) {
                categories.push(`‚úì Ataki > 50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
            }
            
            // 5. ≈ör ≈ÇƒÖczne ro≈ºne
            if (avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`‚úì ≈ör ≈ÇƒÖczne ro≈ºne > 9.5 (${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó ≈ör ≈ÇƒÖczne ro≈ºne = ${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)}`);
            }
            
            // 6. Min ro≈ºne
            if (minCornersHome >= 7 && minCornersAway >= 7) {
                categories.push(`‚úì Min ro≈ºne ‚â• 7 (${minCornersHome} vs ${minCornersAway})`);
                score++;
            } else {
                categories.push(`‚úó Min ro≈ºne = ${minCornersHome} vs ${minCornersAway}`);
            }
            
            // 7. ≈örednia ro≈ºnych z ostatnich 3 mecz√≥w (bardziej aktualne)
            const homeRecent3 = homeValidCorners.slice(0, 3);
            const awayRecent3 = awayValidCorners.slice(0, 3);
            const avgRecent3Home = homeRecent3.length > 0 ? homeRecent3.reduce((sum, v) => sum + v, 0) / homeRecent3.length : 0;
            const avgRecent3Away = awayRecent3.length > 0 ? awayRecent3.reduce((sum, v) => sum + v, 0) / awayRecent3.length : 0;
            const avgRecent3 = (avgRecent3Home + avgRecent3Away) / 2;
            if (avgRecent3 > 9.5) {
                categories.push(`‚úì ≈ör ro≈ºne (ostatnie 3) > 9.5 (${avgRecent3.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó ≈ör ro≈ºne (ostatnie 3) = ${avgRecent3.toFixed(1)}`);
            }
            
            // 8. Konsystencja ro≈ºnych (odchylenie standardowe)
            const homeCornersStdDev = homeValidCorners.length > 1 ? 
                Math.sqrt(homeValidCorners.reduce((sum, v) => sum + Math.pow(v - avgTotalCornersHome, 2), 0) / homeValidCorners.length) : 0;
            const awayCornersStdDev = awayValidCorners.length > 1 ? 
                Math.sqrt(awayValidCorners.reduce((sum, v) => sum + Math.pow(v - avgTotalCornersAway, 2), 0) / awayValidCorners.length) : 0;
            const avgStdDev = (homeCornersStdDev + awayCornersStdDev) / 2;
            // Niskie odchylenie = bardziej konsystentne (dobrze)
            if (avgStdDev < 3.0 && avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`‚úì Konsystencja ro≈ºnych (odchylenie: ${avgStdDev.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Konsystencja ro≈ºnych (odchylenie: ${avgStdDev.toFixed(1)})`);
            }
            
            // 10. NOWE: R√≥≈ºnica miƒôdzy ≈õredniƒÖ ro≈ºnych zespo≈Ç√≥w
            const cornersDiff = Math.abs(avgTotalCornersHome - avgTotalCornersAway);
            // Ma≈Ça r√≥≈ºnica = zr√≥wnowa≈ºone zespo≈Çy (lepiej dla Over 9.5)
            if (cornersDiff < 2.0 && avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`‚úì Zr√≥wnowa≈ºone ro≈ºne (r√≥≈ºnica: ${cornersDiff.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Zr√≥wnowa≈ºone ro≈ºne (r√≥≈ºnica: ${cornersDiff.toFixed(1)})`);
            }
            
            // Oblicz predicted avg corners
            const homeAvgCorners = homeStats?.avg_corners || 0;
            const awayAvgCorners = awayStats?.avg_corners || 0;
            const predictedAvgCorners = (homeAvgCorners + awayAvgCorners) / 2;
            
            // Oblicz statystyki dla wszystkich modeli
            const modelResults = {
                model1: meetsBasic && score >= 7, // Model 1: Score >= 7
                model2: calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners) >= 9, // Model 2: Punktowy >= 9
                model3: calculateModel3Qualifies(predictedAvgCorners, avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, avgShotsHome, avgShotsAway), // Model 3: Jako≈õciowy
                model4: calculateModel4Qualifies(avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, minCornersHome, minCornersAway) >= 2, // Model 4: 4 czynniki >= 2
                model5: calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, avgDangerousAttacksHome, avgDangerousAttacksAway, avgPossessionHome, avgPossessionAway, avgShotsHome, avgShotsAway, homeAvgCorners, awayAvgCorners, minCornersHome, minCornersAway) >= 8.0 // Model 5: WEIGHTED >= 8.0
            };
            
            // Kwalifikacja: mecz kwalifikuje siƒô je≈õli spe≈Çnia DOWOLNY z modeli (1, 2, 3, 4, 5)
            const qualified = modelResults.model1 || modelResults.model2 || modelResults.model3 || modelResults.model4 || modelResults.model5;
            
            return {
                qualified,
                score,
                categories,
                percent_sum: sumOver95,
                home_percent: homePercent,
                away_percent: awayPercent,
                home_stats: homeStats,
                away_stats: awayStats,
                predicted_avg_corners: predictedAvgCorners,
                model_results: modelResults
            };
        }
        
        // Model 2: System punktowy (max 13 punkt√≥w, minimum 9)
        function calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners) {
            let points = 0;
            const homeAvgCorners = homeStats?.avg_corners || 0;
            const awayAvgCorners = awayStats?.avg_corners || 0;
            const homeMinCorners = homeStats?.recent_matches?.slice(0, 5).map(m => m.totalCornerCount || 0).filter(v => v > 0);
            const awayMinCorners = awayStats?.recent_matches?.slice(0, 5).map(m => m.totalCornerCount || 0).filter(v => v > 0);
            const homeMin = homeMinCorners.length > 0 ? Math.min(...homeMinCorners) : 0;
            const awayMin = awayMinCorners.length > 0 ? Math.min(...awayMinCorners) : 0;
            const homeAttacks = homeStats?.avg_dangerous_attacks || 0;
            const awayAttacks = awayStats?.avg_dangerous_attacks || 0;
            const homeShots = homeStats?.avg_shots || 0;
            const awayShots = awayStats?.avg_shots || 0;
            
            if (homeAvgCorners >= 5.0) points += 2;
            if (awayAvgCorners >= 4.5) points += 2;
            if (homeMin >= 4.5 || awayMin >= 4.5) points += 1;
            if (homeAvgCorners + awayAvgCorners >= 9.5) points += 2;
            if (homeAttacks >= 50 && awayAttacks >= 50) points += 1;
            if (homeShots >= 12 && awayShots >= 12) points += 1;
            if (homeAttacks >= 55) points += 1;
            if (predictedAvgCorners >= 10) points += 1;
            
            return points;
        }
        
        // Model 3: Jako≈õciowy
        function calculateModel3Qualifies(predictedAvgCorners, homePoss, awayPoss, homeAttacks, awayAttacks, homeShots, awayShots) {
            if (predictedAvgCorners < 10.0) return false;
            
            const style1 = (homePoss > 55 && awayPoss < 45) || (awayPoss > 55 && homePoss < 45);
            const style2 = homeAttacks >= 50 && awayAttacks >= 50;
            const style3 = homeShots > 14 || awayShots > 14;
            
            return style1 || style2 || style3;
        }
        
        // Model 4: 4 czynniki >= 2
        function calculateModel4Qualifies(homePoss, awayPoss, homeAttacks, awayAttacks, homeMinCorners, awayMinCorners) {
            let factors = 0;
            
            if (Math.abs(homePoss - awayPoss) >= 10) factors++;
            if (homeAttacks >= 50 || awayAttacks >= 50) factors++;
            if ((homePoss < 45 && awayMinCorners >= 6) || (awayPoss < 45 && homeMinCorners >= 6)) factors++;
            
            return factors;
        }
        
        // Model 5: WEIGHTED (system punktowy z wagami, pr√≥g 8.0) - ULEPSZONY
        function calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, homeAttacks, awayAttacks, homePoss, awayPoss, homeShots, awayShots, homeAvgCorners, awayAvgCorners, homeMinCorners, awayMinCorners) {
            let points = 0;
            
            // 1. Predicted avg corners - ULEPSZONE (wiƒôcej prog√≥w, lepsza skala)
            if (predictedAvgCorners >= 12) {
                points += 2.5;
            } else if (predictedAvgCorners >= 11.5) {
                points += 2.0;
            } else if (predictedAvgCorners >= 11) {
                points += 1.5;
            } else if (predictedAvgCorners >= 10.5) {
                points += 1.0;
            } else if (predictedAvgCorners >= 10) {
                points += 0.5;
            }
            
            // 2. Score (Model 1) - ULEPSZONE (wiƒôcej punkt√≥w za wy≈ºsze score)
            if (score >= 9) {
                points += 2.5;
            } else if (score >= 8) {
                points += 2.0;
            } else if (score >= 7) {
                points += 1.5;
            } else if (score >= 6) {
                points += 1.0;
            } else if (score >= 5) {
                points += 0.5;
            }
            
            // 3. Min Over 9.5% - ULEPSZONE (NAJWA≈ªNIEJSZY CZYNNIK - wiƒôksza waga)
            const minOver95 = Math.min(homePercent, awayPercent);
            if (minOver95 >= 75) {
                points += 3.0;  // Zwiƒôkszone z 2.0
            } else if (minOver95 >= 70.1) {
                points += 2.5;  // Zwiƒôkszone z 2.0
            } else if (minOver95 >= 65) {
                points += 1.5;  // Nowy pr√≥g
            } else if (minOver95 >= 60) {
                points += 1.0;
            } else if (minOver95 >= 55) {
                points += 0.5;  // Nowy pr√≥g
            }
            
            // 4. ≈ör atak√≥w - bez zmian
            const avgAttacks = (homeAttacks + awayAttacks) / 2;
            if (avgAttacks >= 57) {
                points += 1.5;
            } else if (avgAttacks >= 55) {
                points += 1.0;
            } else if (avgAttacks >= 50) {
                points += 0.5;
            }
            
            // 5. Styl gry - bez zmian
            const style1 = (homePoss > 55 && awayPoss < 45) || (awayPoss > 55 && homePoss < 45);
            const style2 = homeAttacks >= 50 && awayAttacks >= 50;
            const style3 = homeShots > 14 || awayShots > 14;
            let stylePoints = 0;
            if (style1) stylePoints += 0.5;
            if (style2) stylePoints += 0.5;
            if (style3) stylePoints += 0.5;
            if (stylePoints >= 1.0) {
                points += 1.5;
            } else if (stylePoints >= 0.5) {
                points += 0.75;
            }
            
            // 6. ≈ör corners - bez zmian
            if (homeAvgCorners >= 5.0 && awayAvgCorners >= 4.5) {
                points += 1.0;
            } else if (homeAvgCorners >= 4.5 || awayAvgCorners >= 4.0) {
                points += 0.5;
            }
            
            // 7. Min corners - bez zmian
            if (homeMinCorners >= 7 && awayMinCorners >= 7) {
                points += 1.0;
            } else if (homeMinCorners >= 6 || awayMinCorners >= 6) {
                points += 0.5;
            }
            
            // 8. NOWY: Bonus za wysokie oba Over 9.5%
            if (homePercent >= 70 && awayPercent >= 70) {
                points += 0.5;  // Bonus za oba zespo≈Çy z wysokim Over 9.5%
            }
            
            return points;
        }

        // Fetch league names
        async function fetchLeagueNames() {
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    return JSON.parse(saved);
                }
                
                const proxy = getProxy();
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-list?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/league-list`;
                }
                const response = await fetch(url);
                
                if (!response.ok) return {};
                
                const data = await response.json();
                if (!data.success || !data.data) return {};
                
                const leaguesMap = {};
                data.data.forEach(league => {
                    const seasons = league.season || [];
                    seasons.forEach(season => {
                        if (season.id) {
                            const country = league.country || '';
                            const leagueName = league.league_name || league.name || '';
                            leaguesMap[season.id] = `${country} - ${leagueName}`;
                        }
                    });
                });
                
                localStorage.setItem('leaguesMap', JSON.stringify(leaguesMap));
                return leaguesMap;
            } catch (error) {
                console.error('B≈ÇƒÖd pobierania nazw lig:', error);
                return {};
            }
        }

        // Utw√≥rz hash z mecz√≥w dla por√≥wnania
        function createMatchesHash(matches) {
            if (!matches || matches.length === 0) return '';
            // Sortuj mecze i stw√≥rz hash z ID i dat
            const sorted = [...matches].sort((a, b) => (a.id || 0) - (b.id || 0));
            const ids = sorted.map(m => `${m.id}_${m.date_unix}_${m.status}`).join('|');
            return ids;
        }

        // Analyze Over 9.5 matches
        async function analyzeOver95() {
            if (matchesData.length === 0) {
                displayMessage('Najpierw pobierz mecze!', 'warning');
                return;
            }
            
            // Sprawd≈∫ czy mecze siƒô zmieni≈Çy od ostatniej analizy
            const currentHash = createMatchesHash(matchesData);
            const cachedAnalysis = localStorage.getItem('lastAnalysis');
            const cachedHash = localStorage.getItem('lastAnalysisHash');
            
                if (cachedAnalysis && cachedHash === currentHash && analyzedMatches.length === 0) {
                // Wczytaj z cache
                try {
                    const parsed = JSON.parse(cachedAnalysis);
                    analyzedMatches = parsed;
                    console.log(`üìã Wczytano analizƒô z cache (${analyzedMatches.length} mecz√≥w)`);
                    
                    // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                    const qualifiedElement = document.getElementById('qualified-matches');
                    if (qualifiedElement) {
                        qualifiedElement.textContent = analyzedMatches.length;
                    }
                    
                    displayAnalysisResults();
                    openModal('analysisModal');
                    displayMessage(`‚úì Wy≈õwietlono poprzedniƒÖ analizƒô (${analyzedMatches.length} mecz√≥w). Aby wykonaƒá ponownie, u≈ºyj "Analizuj ponownie"`, 'info');
                    return;
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu cache analizy:', e);
                }
            }
            
            // Je≈õli mecze siƒô nie zmieni≈Çy ale mamy ju≈º wyniki w pamiƒôci, u≈ºyj ich
            if (currentHash === lastAnalysisHash && analyzedMatches.length > 0) {
                console.log('üìã U≈ºywam wynik√≥w z pamiƒôci (mecze nie zmieni≈Çy siƒô)');
                
                // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                displayAnalysisResults();
                openModal('analysisModal');
                displayMessage(`‚úì Wy≈õwietlono analizƒô z pamiƒôci (${analyzedMatches.length} mecz√≥w)`, 'info');
                return;
            }
            
            showLoading(true);
            displayMessage('Analizowanie mecz√≥w...', 'info');
            
            try {
                // Pobierz nazwy lig
                const leaguesMap = await fetchLeagueNames();
                
                // Pobierz statystyki dla wszystkich dru≈ºyn
                analyzedMatches = [];
                let processed = 0;
                const total = matchesData.length;
                
                for (const match of matchesData) {
                    processed++;
                    const progress = Math.round((processed / total) * 100);
                    displayMessage(`Analizowanie meczu ${processed}/${total} (${progress}%)...`, 'info');
                    
                    const competitionId = match.competition_id;
                    const homeId = match.homeID;
                    const awayId = match.awayID;
                    
                    if (!competitionId || !homeId || !awayId) {
                        continue;
                    }
                    
                    // Pobierz statystyki obu dru≈ºyn
                    const [homeStats, awayStats] = await Promise.all([
                        fetchTeamStats(homeId, competitionId),
                        fetchTeamStats(awayId, competitionId)
                    ]);
                    
                    if (!homeStats || !awayStats) {
                        continue;
                    }
                    
                    // Analizuj mecz
                    const analysis = analyzeMatch(match, homeStats, awayStats);
                    
                    if (analysis.qualified) {
                        analyzedMatches.push({
                            match,
                            league: leaguesMap[competitionId] || `Liga ID: ${competitionId}`,
                            analysis,
                            home_name: match.home_name,
                            away_name: match.away_name,
                            time: match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-'
                        });
                    }
                    
                    // Op√≥≈∫nienie miƒôdzy requestami
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Sortuj wed≈Çug score i percent_sum
                analyzedMatches.sort((a, b) => {
                    if (b.analysis.score !== a.analysis.score) {
                        return b.analysis.score - a.analysis.score;
                    }
                    return b.analysis.percent_sum - a.analysis.percent_sum;
                });
                
                // Pobierz kursy Over 9.5 dla zakwalifikowanych mecz√≥w
                if (analyzedMatches.length > 0) {
                    displayMessage(`Pobieranie kurs√≥w dla ${analyzedMatches.length} zakwalifikowanych mecz√≥w...`, 'info');
                    for (let i = 0; i < analyzedMatches.length; i++) {
                        const item = analyzedMatches[i];
                        const matchId = item.match.id;
                        if (matchId) {
                            try {
                                const proxy = getProxy();
                                let url;
                                if (USE_PROXY) {
                                    url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                                } else {
                                    url = `${BASE_URL}/match?match_id=${matchId}`;
                                }
                                const response = await fetch(url);
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data.success && data.data) {
                                        const oddsOver95 = data.data.odds_corners_over_95;
                                        if (oddsOver95) {
                                            item.odds_over95 = parseFloat(oddsOver95);
                                        }
                                    }
                                }
                                // Op√≥≈∫nienie miƒôdzy requestami
                                await new Promise(resolve => setTimeout(resolve, 300));
                            } catch (error) {
                                console.error(`B≈ÇƒÖd pobierania kursu dla meczu ${matchId}:`, error);
                            }
                        }
                    }
                }
                
                // Zapisz do cache
                lastAnalysisHash = currentHash;
                localStorage.setItem('lastAnalysis', JSON.stringify(analyzedMatches));
                localStorage.setItem('lastAnalysisHash', currentHash);
                
                // Automatycznie zapisz do historii je≈õli to pierwsza analiza dzisiaj
                if (analyzedMatches.length > 0) {
                    try {
                        const today = new Date().toISOString().split('T')[0];
                        const savedHistory = localStorage.getItem('over95_history');
                        let history = savedHistory ? JSON.parse(savedHistory) : [];
                        
                        // Sprawd≈∫ czy ju≈º zapisano mecze dzisiaj (sprawd≈∫ pole saved_date lub ostatni zapis)
                        let lastSaveDate = null;
                        const lastSaveDateStr = localStorage.getItem('lastHistorySaveDate');
                        if (lastSaveDateStr) {
                            lastSaveDate = lastSaveDateStr;
                        } else if (history.length > 0) {
                            // Fallback: sprawd≈∫ datƒô ostatniego meczu (je≈õli nie ma saved_date)
                            const lastMatch = history.reduce((latest, match) => {
                                const matchSavedDate = match.saved_date || (match.date_unix ? new Date(match.date_unix * 1000).toISOString().split('T')[0] : null);
                                const latestSavedDate = latest.saved_date || (latest.date_unix ? new Date(latest.date_unix * 1000).toISOString().split('T')[0] : null);
                                return (matchSavedDate && matchSavedDate > (latestSavedDate || '')) ? match : latest;
                            });
                            if (lastMatch.saved_date) {
                                lastSaveDate = lastMatch.saved_date;
                            } else if (lastMatch.date_unix) {
                                lastSaveDate = new Date(lastMatch.date_unix * 1000).toISOString().split('T')[0];
                            }
                        }
                        
                        // Je≈õli nie zapisano dzisiaj, zapisz automatycznie
                        if (lastSaveDate !== today) {
                            let savedCount = 0;
                            analyzedMatches.forEach(item => {
                                const { match, league, analysis } = item;
                                
                                // Sprawd≈∫ czy mecz ju≈º istnieje w historii
                                const matchId = match.id || `${match.homeID}_${match.awayID}_${match.date_unix}`;
                                const alreadyExists = history.some(h => 
                                    (h.api_match_id === match.id) ||
                                    (h.match_id === matchId) ||
                                    (h.home_id === match.homeID && h.away_id === match.awayID && 
                                     h.date_unix === match.date_unix)
                                );
                                
                                if (!alreadyExists) {
                                    // Znajd≈∫ kt√≥ry model zakwalifikowa≈Ç mecz (priorytet: 1, 2, 3, 4, 5)
                                    const modelResults = analysis.model_results || {};
                                    let qualifiedModel = null;
                                    if (modelResults.model1) qualifiedModel = 1;
                                    else if (modelResults.model2) qualifiedModel = 2;
                                    else if (modelResults.model3) qualifiedModel = 3;
                                    else if (modelResults.model4) qualifiedModel = 4;
                                    else if (modelResults.model5) qualifiedModel = 5;
                                    
                                    const historyEntry = {
                                        match_id: matchId,
                                        api_match_id: match.id,
                                        home_id: match.homeID,
                                        away_id: match.awayID,
                                        home_name: match.home_name || item.home_name,
                                        away_name: match.away_name || item.away_name,
                                        league_name: league.split(' - ').slice(-1)[0] || league,
                                        country: league.split(' - ')[0] || '',
                                        date_unix: match.date_unix || 0,
                                        date_formatted: match.date_unix ? new Date(match.date_unix * 1000).toLocaleString('pl-PL') : 'N/A',
                                        saved_date: today, // Data zapisu do historii
                                        over95_percentages: [analysis.home_percent, analysis.away_percent],
                                        home_stats: analysis.home_stats || {},
                                        away_stats: analysis.away_stats || {},
                                        categories: analysis.categories || [],
                                        score: analysis.score || 0,
                                        percent_sum: analysis.percent_sum || 0,
                                        qualified_model: qualifiedModel, // Model kt√≥ry zakwalifikowa≈Ç mecz (1-5)
                                        model_results: analysis.model_results || {}, // Wszystkie wyniki modeli
                                        status: 'pending',
                                        result: 'pending',
                                        match: match,
                                        analysis: analysis,
                                        league: league
                                    };
                                    history.push(historyEntry);
                                    savedCount++;
                                }
                            });
                            
                            if (savedCount > 0) {
                                localStorage.setItem('over95_history', JSON.stringify(history));
                                localStorage.setItem('lastHistorySaveDate', today);
                                console.log(`üíæ Automatycznie zapisano ${savedCount} mecz√≥w do historii (pierwsza analiza dzisiaj)`);
                                displayMessage(`üíæ Automatycznie zapisano ${savedCount} mecz√≥w do historii`, 'success');
                            }
                        }
                    } catch (e) {
                        console.error('B≈ÇƒÖd podczas automatycznego zapisu do historii:', e);
                    }
                }
                
                // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                showLoading(false);
                displayAnalysisResults();
                openModal('analysisModal');
                
                if (analyzedMatches.length > 0) {
                    displayMessage(`‚úì Znaleziono ${analyzedMatches.length} kwalifikujƒÖcych siƒô mecz√≥w!`, 'success');
                } else {
                    displayMessage('‚ÑπÔ∏è Nie znaleziono mecz√≥w spe≈ÇniajƒÖcych kryteria Over 9.5', 'info');
                }
                
            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd analizy:', error);
                displayMessage('B≈ÇƒÖd analizy: ' + error.message, 'error');
            }
        }

        // Display analysis results
        function displayAnalysisResults() {
            const content = document.getElementById('analysis-content');
            
            if (analyzedMatches.length === 0) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center;">
                            Brak mecz√≥w kwalifikujƒÖcych siƒô do Over 9.5.<br>
                            ≈ªaden mecz nie spe≈Çnia wymaganych kryteri√≥w (‚â•50% oba zespo≈Çy i ‚â•7 z 9 kryteri√≥w).
                        </p>
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="analyzeOver95()" class="btn btn-primary">üîÑ Analizuj ponownie</button>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="color: #EF0107; margin-bottom: 10px;">‚úÖ Znaleziono ${analyzedMatches.length} mecz√≥w kwalifikujƒÖcych siƒô</h3>
                            <p style="color: #FFFFFF;">Mecze posortowane wed≈Çug score (najwy≈ºszy pierwszy)</p>
                        </div>
                        <button onclick="forceReanalyze()" class="btn btn-secondary" style="padding: 10px 20px; font-size: 14px;">üîÑ Analizuj ponownie</button>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            `;
            
            // Podziel mecze naprzemiennie miƒôdzy kolumny, zachowujƒÖc sortowanie wed≈Çug score Model 1
            // Kolumna A wiersz 1: najwy≈ºszy score, Kolumna B wiersz 1: nastƒôpny, itd.
            // Mecze sƒÖ ju≈º posortowane wed≈Çug score Model 1 (od najwy≈ºszego do najni≈ºszego) w linii 1367-1372
            const leftColumn = [];
            const rightColumn = [];
            
            analyzedMatches.forEach((item, index) => {
                if (index % 2 === 0) {
                    // Parzyste indeksy (0, 2, 4...) ‚Üí lewa kolumna
                    leftColumn.push(item);
                } else {
                    // Nieparzyste indeksy (1, 3, 5...) ‚Üí prawa kolumna
                    rightColumn.push(item);
                }
            });
            
            // Funkcja do generowania szczeg√≥≈Ç√≥w dla ka≈ºdego modelu
            const generateModelDetails = (analysis, modelResults) => {
                const homeStats = analysis.home_stats || {};
                const awayStats = analysis.away_stats || {};
                const homePercent = analysis.home_percent || 0;
                const awayPercent = analysis.away_percent || 0;
                const predictedAvgCorners = analysis.predicted_avg_corners || 0;
                const score = analysis.score || 0;
                
                // Oblicz statystyki
                const avgShotsHome = homeStats.avg_shots || 0;
                const avgShotsAway = awayStats.avg_shots || 0;
                const avgPossessionHome = homeStats.avg_possession || 0;
                const avgPossessionAway = awayStats.avg_possession || 0;
                const avgDangerousAttacksHome = homeStats.avg_dangerous_attacks || 0;
                const avgDangerousAttacksAway = awayStats.avg_dangerous_attacks || 0;
                const avgCornersHome = homeStats.avg_corners || 0;
                const avgCornersAway = awayStats.avg_corners || 0;
                
                const homeRecent = homeStats.recent_matches || [];
                const awayRecent = awayStats.recent_matches || [];
                const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
                const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
                const avgTotalCornersHome = homeValidCorners.length > 0 ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length : 0;
                const avgTotalCornersAway = awayValidCorners.length > 0 ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length : 0;
                
                // Znajd≈∫ kt√≥ry model zakwalifikowa≈Ç mecz (priorytet: 1, 2, 3, 4, 5)
                let qualifiedModel = null;
                if (modelResults.model1) qualifiedModel = 1;
                else if (modelResults.model2) qualifiedModel = 2;
                else if (modelResults.model3) qualifiedModel = 3;
                else if (modelResults.model4) qualifiedModel = 4;
                else if (modelResults.model5) qualifiedModel = 5;
                
                let scoreText = '';
                let detailsHTML = '';
                
                if (qualifiedModel === 1) {
                    // Model 1: Score >= 7/9
                    scoreText = `Score: ${score}/9`;
                    detailsHTML = analysis.categories.map(cat => {
                        const color = cat.startsWith('‚úì') ? '#4CAF50' : cat.startsWith('‚úó') ? '#EF0107' : '#FFFFFF';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                    }).join('');
                } else if (qualifiedModel === 2) {
                    // Model 2: Punktowy >= 9
                    const model2Score = calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners);
                    scoreText = `Punkty: ${model2Score}`;
                    
                    const details = [];
                    if (avgCornersHome >= 5.0) details.push(`‚úì ≈ör ro≈ºne (gospodarz) ‚â• 5.0 (${avgCornersHome.toFixed(1)})`);
                    else details.push(`‚úó ≈ör ro≈ºne (gospodarz) = ${avgCornersHome.toFixed(1)}`);
                    
                    if (avgCornersAway >= 4.5) details.push(`‚úì ≈ör ro≈ºne (go≈õƒá) ‚â• 4.5 (${avgCornersAway.toFixed(1)})`);
                    else details.push(`‚úó ≈ör ro≈ºne (go≈õƒá) = ${avgCornersAway.toFixed(1)}`);
                    
                    if (minCornersHome >= 4.5 || minCornersAway >= 4.5) details.push(`‚úì Min ro≈ºne ‚â• 4.5 (${minCornersHome} vs ${minCornersAway})`);
                    else details.push(`‚úó Min ro≈ºne = ${minCornersHome} vs ${minCornersAway}`);
                    
                    if (avgCornersHome + avgCornersAway >= 9.5) details.push(`‚úì Suma ro≈ºnych ‚â• 9.5 (${(avgCornersHome + avgCornersAway).toFixed(1)})`);
                    else details.push(`‚úó Suma ro≈ºnych = ${(avgCornersHome + avgCornersAway).toFixed(1)}`);
                    
                    if (avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) details.push(`‚úì Ataki ‚â• 50+50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`‚úó Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    if (avgShotsHome >= 12 && avgShotsAway >= 12) details.push(`‚úì Strza≈Çy ‚â• 12+12 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                    else details.push(`‚úó Strza≈Çy = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
                    
                    if (avgDangerousAttacksHome >= 55) details.push(`‚úì Ataki (gospodarz) ‚â• 55 (${avgDangerousAttacksHome.toFixed(1)})`);
                    else details.push(`‚úó Ataki (gospodarz) = ${avgDangerousAttacksHome.toFixed(1)}`);
                    
                    if (predictedAvgCorners >= 10) details.push(`‚úì Predicted avg ‚â• 10 (${predictedAvgCorners.toFixed(1)})`);
                    else details.push(`‚úó Predicted avg = ${predictedAvgCorners.toFixed(1)}`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('‚úì') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (qualifiedModel === 3) {
                    // Model 3: Jako≈õciowy
                    scoreText = `Predicted avg: ${predictedAvgCorners.toFixed(1)}`;
                    
                    const details = [];
                    if (predictedAvgCorners >= 10.0) details.push(`‚úì Predicted avg corners ‚â• 10.0 (${predictedAvgCorners.toFixed(1)})`);
                    else details.push(`‚úó Predicted avg corners = ${predictedAvgCorners.toFixed(1)}`);
                    
                    const style1 = (avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45);
                    if (style1) details.push(`‚úì Styl 1: R√≥≈ºnica posiadania > 10% (${avgPossessionHome.toFixed(0)}% vs ${avgPossessionAway.toFixed(0)}%)`);
                    else details.push(`‚úó Styl 1: R√≥≈ºnica posiadania = ${Math.abs(avgPossessionHome - avgPossessionAway).toFixed(0)}%`);
                    
                    const style2 = avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50;
                    if (style2) details.push(`‚úì Styl 2: Ataki ‚â• 50+50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`‚úó Styl 2: Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    const style3 = avgShotsHome > 14 || avgShotsAway > 14;
                    if (style3) details.push(`‚úì Styl 3: Strza≈Çy > 14 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                    else details.push(`‚úó Styl 3: Strza≈Çy = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('‚úì') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (qualifiedModel === 4) {
                    // Model 4: 4 czynniki >= 2
                    const factors = calculateModel4Qualifies(avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, minCornersHome, minCornersAway);
                    scoreText = `Czynniki: ${factors}/3`;
                    
                    const details = [];
                    const possDiff = Math.abs(avgPossessionHome - avgPossessionAway);
                    if (possDiff >= 10) details.push(`‚úì R√≥≈ºnica posiadania ‚â• 10% (${possDiff.toFixed(0)}%)`);
                    else details.push(`‚úó R√≥≈ºnica posiadania = ${possDiff.toFixed(0)}%`);
                    
                    if (avgDangerousAttacksHome >= 50 || avgDangerousAttacksAway >= 50) details.push(`‚úì Ataki ‚â• 50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`‚úó Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    const factor3 = (avgPossessionHome < 45 && minCornersAway >= 6) || (avgPossessionAway < 45 && minCornersHome >= 6);
                    if (factor3) details.push(`‚úì Niskie posiadanie + min ro≈ºne ‚â• 6 (${avgPossessionHome.toFixed(0)}%/${minCornersAway} lub ${avgPossessionAway.toFixed(0)}%/${minCornersHome})`);
                    else details.push(`‚úó Niskie posiadanie + min ro≈ºne (${avgPossessionHome.toFixed(0)}%/${minCornersHome} vs ${avgPossessionAway.toFixed(0)}%/${minCornersAway})`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('‚úì') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (qualifiedModel === 5) {
                    // Model 5: WEIGHTED >= 8.0
                    const model5Score = calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, avgDangerousAttacksHome, avgDangerousAttacksAway, avgPossessionHome, avgPossessionAway, avgShotsHome, avgShotsAway, avgCornersHome, avgCornersAway, minCornersHome, minCornersAway);
                    scoreText = `Punkty: ${model5Score.toFixed(2)}`;
                    
                    const details = [];
                    details.push(`Predicted avg corners: ${predictedAvgCorners.toFixed(1)}`);
                    details.push(`Model 1 Score: ${score}/9`);
                    details.push(`Min Over 9.5%: ${Math.min(homePercent, awayPercent).toFixed(1)}%`);
                    details.push(`≈ör atak√≥w: ${((avgDangerousAttacksHome + avgDangerousAttacksAway) / 2).toFixed(1)}`);
                    details.push(`Styl gry: ${((avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45) || (avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) || (avgShotsHome > 14 || avgShotsAway > 14)) ? 'Tak' : 'Nie'}`);
                    details.push(`≈ör ro≈ºne: ${avgCornersHome.toFixed(1)} | ${avgCornersAway.toFixed(1)}`);
                    details.push(`Min ro≈ºne: ${minCornersHome} | ${minCornersAway}`);
                    
                    detailsHTML = details.map(d => {
                        return `<p style="color: #FFFFFF; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                }
                
                return { scoreText, detailsHTML, qualifiedModel };
            };
            
            // Funkcja do generowania HTML dla meczu
            const generateMatchHTML = (item) => {
                const { match, league, analysis } = item;
                const basicRequirement = analysis.home_percent >= 50 && analysis.away_percent >= 50;
                const basicText = basicRequirement 
                    ? `‚úì WYMAGANIE PODSTAWOWE: Oba zespo≈Çy ‚â• 50% (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`
                    : `‚úó WYMAGANIE PODSTAWOWE: Oba zespo≈Çy ‚â• 50% - NIE SPE≈ÅNIONE (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`;
                
                // Sprawd≈∫ kt√≥re modele zakwalifikowa≈Çy mecz
                const modelResults = analysis.model_results || {};
                const model1Qualified = modelResults.model1 ? '‚úÖ' : '‚ùå';
                const model2Qualified = modelResults.model2 ? '‚úÖ' : '‚ùå';
                const model3Qualified = modelResults.model3 ? '‚úÖ' : '‚ùå';
                const model4Qualified = modelResults.model4 ? '‚úÖ' : '‚ùå';
                const model5Qualified = modelResults.model5 ? '‚úÖ' : '‚ùå';
                
                // Wygeneruj szczeg√≥≈Çy dla modelu, kt√≥ry zakwalifikowa≈Ç mecz
                const { scoreText, detailsHTML, qualifiedModel } = generateModelDetails(analysis, modelResults);
                const modelName = qualifiedModel ? `Model ${qualifiedModel}` : 'Model 1';
                
                return `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header">
                            üèÜ ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                <p style="color: #EF0107; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    ${scoreText}
                                </p>
                                ${item.odds_over95 ? `
                                    <p style="color: #FFFFFF; margin: 5px 0; font-size: 1em;">
                                        üí∞ Kurs Over 9.5: <strong style="color: #4CAF50;">${item.odds_over95.toFixed(2)}</strong>
                                    </p>
                                ` : `
                                    <p style="color: #999999; margin: 5px 0; font-size: 0.9em;">
                                        üí∞ Kurs Over 9.5: <em>Brak danych</em>
                                    </p>
                                `}
                            </div>
                            
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(239, 1, 7, 0.1); border-radius: 8px; border-left: 3px solid #EF0107;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold; font-size: 0.95em;">Wyniki wszystkich modeli:</p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 0.9em;">
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 1 (Score >= 7): ${model1Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 2 (Punktowy >= 9): ${model2Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 3 (Jako≈õciowy): ${model3Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 4 (4 czynniki >= 2): ${model4Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0; grid-column: 1 / -1;">Model 5 WEIGHTED (pr√≥g 8.0): ${model5Qualified}</p>
                                </div>
                                ${qualifiedModel ? `<p style="color: #4CAF50; margin-top: 8px; font-weight: bold; font-size: 0.9em;">‚úÖ Zakwalifikowany przez: ${modelName}</p>` : ''}
                            </div>
                            
                            <div style="margin-top: 15px;">
                                <p style="color: ${basicRequirement ? '#4CAF50' : '#EF0107'}; margin: 5px 0;">
                                    ${basicText}
                                </p>
                                <p style="color: #FFFFFF; margin-top: 10px; font-weight: bold;">Szczeg√≥≈Çy wymaga≈Ñ (${modelName}):</p>
                                ${detailsHTML}
                            </div>
                        </div>
                    </div>
                `;
            };
            
            // Lewa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            leftColumn.forEach(item => {
                html += generateMatchHTML(item);
            });
            html += '</div>';
            
            // Prawa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            rightColumn.forEach(item => {
                html += generateMatchHTML(item);
            });
            html += '</div>';
            
            html += '</div>';
            
            content.innerHTML = html;
        }

        // Wymu≈õ ponownƒÖ analizƒô (ignoruj cache)
        async function forceReanalyze() {
            console.log('üîÑ Wymuszam ponownƒÖ analizƒô...');
            lastAnalysisHash = null;
            analyzedMatches = [];
            localStorage.removeItem('lastAnalysis');
            localStorage.removeItem('lastAnalysisHash');
            await analyzeOver95();
        }

        // Weryfikuj wyniki mecz√≥w w historii
        async function verifyHistoryResults(silent = false) {
            const savedHistory = localStorage.getItem('over95_history');
            if (!savedHistory) {
                if (!silent) {
                displayMessage('Brak historii do weryfikacji', 'warning');
                }
                return;
            }
            
            if (!silent) {
            showLoading(true);
            displayMessage('Weryfikowanie wynik√≥w mecz√≥w...', 'info');
            }
            
            try {
                let history = JSON.parse(savedHistory);
                let verifiedCount = 0;
                let updatedCount = 0;
                
                // Znajd≈∫ mecze kt√≥re wymagajƒÖ weryfikacji (status pending)
                const pendingMatches = history.filter(m => m.status === 'pending' || m.result === 'pending');
                
                if (pendingMatches.length === 0) {
                    if (!silent) {
                    showLoading(false);
                    displayMessage('Wszystkie mecze sƒÖ ju≈º zweryfikowane', 'info');
                    }
                    return;
                }
                
                if (!silent) {
                displayMessage(`Weryfikowanie ${pendingMatches.length} mecz√≥w...`, 'info');
                }
                
                for (let i = 0; i < pendingMatches.length; i++) {
                    const match = pendingMatches[i];
                    const matchId = match.api_match_id;
                    
                    if (!matchId) {
                        console.log(`‚ö†Ô∏è Pomijam mecz ${match.home_name} vs ${match.away_name} - brak api_match_id`);
                        continue;
                    }
                    
                    try {
                        // Pobierz dane meczu z API
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        if (!data.success || !data.data) continue;
                        
                        const matchData = data.data;
                        const status = matchData.status;
                        
                        // Sprawd≈∫ czy mecz siƒô zako≈Ñczy≈Ç
                        if (status === 'complete') {
                            const totalCorners = matchData.totalCornerCount || 0;
                            const expectedCorners = 9.5;
                            
                            // Aktualizuj status w historii
                            const historyIndex = history.findIndex(h => 
                                h.api_match_id === matchId || 
                                (h.match_id === match.match_id)
                            );
                            
                            if (historyIndex !== -1) {
                                const result = totalCorners > expectedCorners ? 'won' : 'lost';
                                history[historyIndex].status = 'verified';
                                history[historyIndex].result = result;
                                history[historyIndex].actual_corners = totalCorners;
                                history[historyIndex].match = matchData;
                                updatedCount++;
                                console.log(`‚úì Zaktualizowano ${match.home_name} vs ${match.away_name}: ${result} (${totalCorners} ro≈ºnych)`);
                            }
                        }
                        
                        verifiedCount++;
                        
                        // Op√≥≈∫nienie miƒôdzy requestami
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`B≈ÇƒÖd weryfikacji meczu ${match.home_name} vs ${match.away_name}:`, error);
                    }
                }
                
                // Zapisz zaktualizowanƒÖ historiƒô
                if (updatedCount > 0) {
                    localStorage.setItem('over95_history', JSON.stringify(history));
                    if (!silent) {
                    displayMessage(`‚úì Zaktualizowano ${updatedCount} mecz√≥w w historii`, 'success');
                    // Od≈õwie≈º wy≈õwietlanie historii
                    showHistory();
                } else {
                        console.log(`‚úì [AUTO-VERIFY] Zaktualizowano ${updatedCount} mecz√≥w w historii`);
                    }
                } else {
                    if (!silent) {
                    displayMessage('Brak mecz√≥w do aktualizacji', 'info');
                    }
                }
                
                if (!silent) {
                showLoading(false);
                }
            } catch (error) {
                if (!silent) {
                showLoading(false);
                displayMessage('B≈ÇƒÖd podczas weryfikacji: ' + error.message, 'error');
                }
                console.error('B≈ÇƒÖd podczas weryfikacji:', error);
            }
        }
        
        // Automatyczna weryfikacja przy pierwszym uruchomieniu w nowym dniu
        async function autoVerifyOnNewDay() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const lastVerifyDate = localStorage.getItem('lastAutoVerifyDate');
                
                // Je≈õli to pierwsze uruchomienie w nowym dniu, zweryfikuj automatycznie
                if (lastVerifyDate !== today) {
                    const savedHistory = localStorage.getItem('over95_history');
                    if (savedHistory) {
                        const history = JSON.parse(savedHistory);
                        const pendingMatches = history.filter(m => m.status === 'pending' || m.result === 'pending');
                        
                        if (pendingMatches.length > 0) {
                            console.log(`üîÑ [AUTO-VERIFY] Automatyczna weryfikacja wynik√≥w (${pendingMatches.length} mecz√≥w oczekujƒÖcych)...`);
                            // Wywo≈Çaj weryfikacjƒô w trybie cichym (bez wy≈õwietlania komunikat√≥w)
                            await verifyHistoryResults(true);
                            // Zapisz datƒô ostatniej weryfikacji
                            localStorage.setItem('lastAutoVerifyDate', today);
                            console.log(`‚úì [AUTO-VERIFY] Zako≈Ñczono automatycznƒÖ weryfikacjƒô`);
                        }
                    }
                }
            } catch (error) {
                console.error('B≈ÇƒÖd podczas automatycznej weryfikacji:', error);
            }
        }

        // Show history
        function showHistory(sortBy = 'date') {
            window.currentHistorySort = sortBy; // Zapisz aktualne sortowanie
            const savedHistory = localStorage.getItem('over95_history');
            const content = document.getElementById('history-content');
            
            if (!savedHistory) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center; padding: 40px;">
                            üìã Brak historii mecz√≥w.<br>
                            <span style="color: rgba(255,255,255,0.7); font-size: 0.9em;">
                                Po analizie i zapisaniu mecz√≥w, pojawiƒÖ siƒô tutaj.
                            </span>
                        </p>
                    </div>
                `;
            } else {
                try {
                    let history = JSON.parse(savedHistory);
                    
                    // Sortuj historiƒô wed≈Çug wybranego kryterium
                    if (sortBy === 'score') {
                        // Sortuj wed≈Çug score Model 1 (od najwy≈ºszego do najni≈ºszego)
                        history.sort((a, b) => {
                            const scoreA = a.score || a.analysis?.score || 0;
                            const scoreB = b.score || b.analysis?.score || 0;
                            return scoreB - scoreA;
                        });
                    } else if (sortBy === 'model') {
                        // Sortuj wed≈Çug modelu (M-1, M-2, M-3, M-4, M-5)
                        history.sort((a, b) => {
                            const modelA = a.qualified_model || (a.analysis?.model_results ? 
                                (a.analysis.model_results.model1 ? 1 : 
                                 a.analysis.model_results.model2 ? 2 :
                                 a.analysis.model_results.model3 ? 3 :
                                 a.analysis.model_results.model4 ? 4 :
                                 a.analysis.model_results.model5 ? 5 : 0) : 0);
                            const modelB = b.qualified_model || (b.analysis?.model_results ? 
                                (b.analysis.model_results.model1 ? 1 : 
                                 b.analysis.model_results.model2 ? 2 :
                                 b.analysis.model_results.model3 ? 3 :
                                 b.analysis.model_results.model4 ? 4 :
                                 b.analysis.model_results.model5 ? 5 : 0) : 0);
                            return modelA - modelB; // M-1, M-2, M-3, M-4, M-5
                        });
                    } else if (sortBy === 'result') {
                        // Sortuj wed≈Çug wyniku (won, pending, lost)
                        const resultOrder = { 'won': 1, 'pending': 2, 'lost': 3 };
                        history.sort((a, b) => {
                            const resultA = resultOrder[a.result || a.status || 'pending'] || 2;
                            const resultB = resultOrder[b.result || b.status || 'pending'] || 2;
                            return resultA - resultB;
                        });
                    } else {
                        // Sortuj wed≈Çug daty (najnowsze pierwsze) - domy≈õlne
                        history.sort((a, b) => {
                            const dateA = a.date_unix || a.match?.date_unix || 0;
                            const dateB = b.date_unix || b.match?.date_unix || 0;
                            return dateB - dateA;
                        });
                    }
                    
                    // Grupuj mecze wed≈Çug daty (tylko je≈õli sortBy === 'date')
                    const matchesByDate = {};
                    if (sortBy === 'date') {
                        history.forEach(match => {
                            const dateUnix = match.date_unix || match.match?.date_unix || 0;
                            if (dateUnix) {
                                const date = new Date(dateUnix * 1000);
                                const dateStr = date.toLocaleDateString('pl-PL', { 
                                    year: 'numeric', 
                                    month: 'long', 
                                    day: 'numeric' 
                                });
                                
                                if (!matchesByDate[dateStr]) {
                                    matchesByDate[dateStr] = [];
                                }
                                matchesByDate[dateStr].push(match);
                            }
                        });
                    } else {
                        // Dla innych sortowa≈Ñ, wszystkie mecze w jednej "dacie"
                        matchesByDate['Wszystkie mecze'] = history;
                    }
                    
                    // Sortuj daty (najnowsze pierwsze) - u≈ºywamy date_unix do poprawnego sortowania
                    const sortedDates = Object.keys(matchesByDate).sort((a, b) => {
                        if (sortBy !== 'date') return 0; // Nie sortuj dat je≈õli sortujemy po czym≈õ innym
                        // Znajd≈∫ najnowszy mecz z ka≈ºdej daty
                        const dateA = matchesByDate[a][0].date_unix || matchesByDate[a][0].match?.date_unix || 0;
                        const dateB = matchesByDate[b][0].date_unix || matchesByDate[b][0].match?.date_unix || 0;
                        return dateB - dateA; // Najnowsze pierwsze (malejƒÖco)
                    });
                    
                    let html = `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                                <div>
                                    <h3 style="color: #EF0107; margin-bottom: 10px;">üìú Historia analizowanych mecz√≥w</h3>
                                    <p style="color: #FFFFFF;">≈ÅƒÖcznie: ${history.length} mecz√≥w w historii</p>
                                </div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <select id="historySortBy" onchange="sortHistory()" style="
                                        padding: 10px 15px;
                                        font-size: 14px;
                                    border-radius: 5px;
                                        background: rgba(255, 255, 255, 0.1);
                                        color: #FFFFFF;
                                        border: 1px solid rgba(255, 255, 255, 0.3);
                                    cursor: pointer;
                                    ">
                                        <option value="date" ${sortBy === 'date' ? 'selected' : ''}>Sortuj: Data (najnowsze)</option>
                                        <option value="score" ${sortBy === 'score' ? 'selected' : ''}>Sortuj: Score (9/9 ‚Üí 0/9)</option>
                                        <option value="model" ${sortBy === 'model' ? 'selected' : ''}>Sortuj: Model (M-1 ‚Üí M-5)</option>
                                        <option value="result" ${sortBy === 'result' ? 'selected' : ''}>Sortuj: Wynik (Wygrane ‚Üí Przegrane)</option>
                                    </select>
                                    <button onclick="verifyHistoryResults()" class="btn btn-secondary" style="
                                        padding: 12px 24px;
                                        font-size: 16px;
                                        white-space: nowrap;
                                ">üîÑ Weryfikuj Wyniki</button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Funkcja sortowania historii
                    window.sortHistory = function() {
                        const sortBy = document.getElementById('historySortBy')?.value || 'date';
                        showHistory(sortBy);
                    };
                    
                    // Wy≈õwietl mecze wed≈Çug dat (lub wszystkie je≈õli sortBy !== 'date')
                    sortedDates.forEach(dateStr => {
                        const matches = matchesByDate[dateStr];
                        
                        // Sortuj mecze w ramach dnia - najnowsze pierwsze (po date_unix) - tylko je≈õli sortBy === 'date'
                        if (sortBy === 'date') {
                            matches.sort((a, b) => {
                                const dateA = a.date_unix || a.match?.date_unix || 0;
                                const dateB = b.date_unix || b.match?.date_unix || 0;
                                return dateB - dateA; // Najnowsze pierwsze
                            });
                        }
                        
                        html += `
                            <div class="card" style="margin-bottom: 20px;">
                                <div class="card-header">
                                    üìÖ ${dateStr} (${matches.length} ${matches.length === 1 ? 'mecz' : 'mecz√≥w'})
                                </div>
                                <div style="padding: 15px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        `;
                        
                        // Podziel mecze naprzemiennie miƒôdzy kolumny
                        const leftColumn = [];
                        const rightColumn = [];
                        
                        matches.forEach((match, matchIdx) => {
                            if (matchIdx % 2 === 0) {
                                leftColumn.push({ match, matchIdx });
                            } else {
                                rightColumn.push({ match, matchIdx });
                            }
                        });
                        
                        // Funkcja do generowania HTML dla meczu
                        const generateMatchHTML = (match, matchIdx) => {
                            const matchData = match.match || match;
                            const homeName = match.home_name || matchData.home_name || 'N/A';
                            const awayName = match.away_name || matchData.away_name || 'N/A';
                            const league = match.league || match.league_name || matchData.competition_id || 'N/A';
                            const status = match.result || match.status || 'pending';
                            const actualCorners = match.actual_corners || matchData.totalCornerCount || '-';
                            const score = match.score || match.analysis?.score || 0;
                            
                            // Pobierz informacjƒô o modelu kwalifikujƒÖcym
                            const qualifiedModel = match.qualified_model || match.analysis?.model_results ? 
                                (match.analysis.model_results.model1 ? 1 : 
                                 match.analysis.model_results.model2 ? 2 :
                                 match.analysis.model_results.model3 ? 3 :
                                 match.analysis.model_results.model4 ? 4 :
                                 match.analysis.model_results.model5 ? 5 : null) : null;
                            const modelBadge = qualifiedModel ? `<span style="background: rgba(2, 52, 116, 0.5); padding: 2px 8px; border-radius: 4px; font-size: 0.85em; color: #FFFFFF; font-weight: bold;">M-${qualifiedModel}</span>` : '';
                            
                            let statusBadge = '';
                            let statusColor = '#FF9800';
                            if (status === 'won') {
                                statusBadge = '<span class="badge badge-success">‚úÖ Wygra≈Ç</span>';
                                statusColor = '#4CAF50';
                            } else if (status === 'lost') {
                                statusBadge = '<span class="badge badge-danger">‚ùå Przegra≈Ç</span>';
                                statusColor = '#EF0107';
                            } else {
                                statusBadge = '<span class="badge badge-warning">‚è≥ Oczekuje</span>';
                            }
                            
                            const matchId = `history_${dateStr.replace(/\s+/g, '_')}_${matchIdx}`;
                            window[matchId] = match; // Zapisz match w globalnym scope
                            
                            // Wy≈õwietl ro≈ºne - je≈õli mecz oczekuje, poka≈º klepsydrƒô zamiast -1
                            let cornersDisplay = actualCorners;
                            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                                cornersDisplay = '‚è≥';
                            }
                            
                            return `
                                <div class="match-item" style="border-left-color: ${statusColor}; margin-bottom: 15px;" data-model="${qualifiedModel || 0}" data-score="${score}">
                                    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;">
                                        <div style="flex: 1;">
                                            <div class="match-teams">${homeName} vs ${awayName} ${modelBadge}</div>
                                            <div class="match-league">${league}</div>
                                            <div style="margin-top: 10px;">
                                                <span style="color: #FFFFFF;">
                                                    Score: <strong>${score}/9</strong> | Rzut√≥w ro≈ºnych: <strong>${cornersDisplay}</strong>
                                                </span>
                                            </div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 10px;">
                                            <span style="display: inline-block; width: 120px; text-align: center; box-sizing: border-box;">${statusBadge}</span>
                                            <button onclick="showMatchHistoryDetails(window['${matchId}'])" class="btn btn-secondary" style="
                                                padding: 12px 24px;
                                                font-size: 14px;
                                                white-space: nowrap;
                                                min-width: 120px;
                                        ">üîç Szczeg√≥≈Çy</button>
                                        </div>
                                    </div>
                                </div>
                            `;
                        };
                        
                        // Lewa kolumna
                        html += '<div style="display: flex; flex-direction: column;">';
                        leftColumn.forEach(({ match, matchIdx }) => {
                            html += generateMatchHTML(match, matchIdx);
                        });
                        html += '</div>';
                        
                        // Prawa kolumna
                        html += '<div style="display: flex; flex-direction: column;">';
                        rightColumn.forEach(({ match, matchIdx }) => {
                            html += generateMatchHTML(match, matchIdx);
                        });
                        html += '</div>';
                        
                        html += `
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    content.innerHTML = html;
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu historii:', e);
                    content.innerHTML = `
                        <div class="card">
                            <p style="color: #EF0107; text-align: center; padding: 40px;">
                                ‚ùå B≈ÇƒÖd odczytu historii: ${e.message}
                            </p>
                        </div>
                    `;
                }
            }
            
            openModal('historyModal');
        }

        // Poka≈º szczeg√≥≈Çy meczu z historii z por√≥wnaniem predykcji vs rzeczywisto≈õƒá
        async function showMatchHistoryDetails(match) {
            if (!match) {
                displayMessage('B≈ÇƒÖd: brak danych meczu', 'error');
                return;
            }
            
            const matchData = match.match || match;
            const homeName = match.home_name || matchData.home_name || 'N/A';
            const awayName = match.away_name || matchData.away_name || 'N/A';
            const league = match.league || match.league_name || 'N/A';
            const status = match.result || match.status || 'pending';
            let actualCorners = match.actual_corners || matchData.totalCornerCount;
            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                actualCorners = '‚è≥';
            }
            const score = match.score || match.analysis?.score || 0;
            const categories = match.categories || match.analysis?.categories || [];
            const percentSum = match.percent_sum || match.analysis?.percent_sum || 0;
            
            // Dane przed meczem (predykcja)
            const homeStats = match.home_stats || match.analysis?.home_stats || {};
            const awayStats = match.away_stats || match.analysis?.away_stats || {};
            
            // Pobierz dane rzeczywiste z API je≈õli mecz siƒô zako≈Ñczy≈Ç
            let actualMatchData = null;
            if (status === 'won' || status === 'lost' || status === 'verified') {
                const matchId = match.api_match_id || matchData.id;
                if (matchId) {
                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                actualMatchData = data.data;
                            }
                        }
                    } catch (error) {
                        console.error('B≈ÇƒÖd pobierania danych meczu:', error);
                    }
                }
            }
            
            let statusText = '';
            let statusColor = '#FF9800';
            if (status === 'won') {
                statusText = '‚úÖ Wygra≈Ç';
                statusColor = '#4CAF50';
            } else if (status === 'lost') {
                statusText = '‚ùå Przegra≈Ç';
                statusColor = '#EF0107';
            } else {
                statusText = '‚è≥ Oczekuje';
            }
            
            // Por√≥wnanie predykcji vs rzeczywisto≈õƒá
            let comparisonHTML = '';
            if (actualMatchData && (status === 'won' || status === 'lost' || status === 'verified')) {
                const actualTotalCorners = actualMatchData.totalCornerCount || 0;
                const actualHomeCorners = actualMatchData.team_a_corners || 0;
                const actualAwayCorners = actualMatchData.team_b_corners || 0;
                const actualShotsHome = actualMatchData.team_a_shots || 0;
                const actualShotsAway = actualMatchData.team_b_shots || 0;
                const actualPossessionHome = actualMatchData.team_a_possession || 0;
                const actualPossessionAway = actualMatchData.team_b_possession || 0;
                const actualDangerousAttacksHome = actualMatchData.team_a_dangerous_attacks || 0;
                const actualDangerousAttacksAway = actualMatchData.team_b_dangerous_attacks || 0;
                
                // ≈örednie przed meczem
                const predictedShotsHome = homeStats?.avg_shots || 0;
                const predictedShotsAway = awayStats?.avg_shots || 0;
                const predictedPossessionHome = homeStats?.avg_possession || 0;
                const predictedPossessionAway = awayStats?.avg_possession || 0;
                const predictedDangerousAttacksHome = homeStats?.avg_dangerous_attacks || 0;
                const predictedDangerousAttacksAway = awayStats?.avg_dangerous_attacks || 0;
                
                // ≈örednia ≈ÇƒÖcznych ro≈ºnych przed meczem
                const homeRecent = homeStats?.recent_matches || [];
                const awayRecent = awayStats?.recent_matches || [];
                const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const predictedAvgTotalCornersHome = homeValidCorners.length > 0 
                    ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length 
                    : 0;
                const predictedAvgTotalCornersAway = awayValidCorners.length > 0 
                    ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length 
                    : 0;
                const predictedAvgTotalCorners = (predictedAvgTotalCornersHome + predictedAvgTotalCornersAway) / 2;
                
                comparisonHTML = `
                    <div class="card" style="margin-top: 20px; border: 2px solid #EF0107;">
                        <div class="card-header" style="background: rgba(239, 1, 7, 0.3);">
                            üìä Por√≥wnanie: Predykcja vs Rzeczywisto≈õƒá
                        </div>
                        <div style="padding: 20px;">
                            <h4 style="color: #EF0107; margin-bottom: 15px;">Rzut√≥w ro≈ºnych</h4>
                            <table style="width: 100%; color: #FFFFFF; margin-bottom: 20px;">
                                <tr>
                                    <td><strong>Przed meczem (≈õrednia):</strong></td>
                                    <td style="text-align: right;">${predictedAvgTotalCorners.toFixed(1)}</td>
                                </tr>
                                <tr>
                                    <td><strong>Rzeczywiste:</strong></td>
                                    <td style="text-align: right; color: ${actualTotalCorners > 9.5 ? '#4CAF50' : '#EF0107'}; font-weight: bold;">${actualTotalCorners}</td>
                                </tr>
                                <tr>
                                    <td><strong>R√≥≈ºnica:</strong></td>
                                    <td style="text-align: right; color: ${(actualTotalCorners - predictedAvgTotalCorners) >= 0 ? '#4CAF50' : '#EF0107'};">
                                        ${(actualTotalCorners - predictedAvgTotalCorners) >= 0 ? '+' : ''}${(actualTotalCorners - predictedAvgTotalCorners).toFixed(1)}
                                    </td>
                                </tr>
                            </table>
                            
                            <h4 style="color: #EF0107; margin-bottom: 15px; margin-top: 20px;">Szczeg√≥≈Çy ro≈ºnych</h4>
                            <table style="width: 100%; color: #FFFFFF; margin-bottom: 20px;">
                                <tr>
                                    <td><strong>${homeName}:</strong></td>
                                    <td style="text-align: right;">${actualHomeCorners}</td>
                                </tr>
                                <tr>
                                    <td><strong>${awayName}:</strong></td>
                                    <td style="text-align: right;">${actualAwayCorners}</td>
                                </tr>
                            </table>
                            
                            <h4 style="color: #EF0107; margin-bottom: 15px; margin-top: 20px;">Inne statystyki</h4>
                            <table style="width: 100%; color: #FFFFFF; font-size: 0.9em;">
                                <tr>
                                    <td><strong>Strza≈Çy (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedShotsHome.toFixed(1)} ‚Üí <strong>${actualShotsHome}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Strza≈Çy (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedShotsAway.toFixed(1)} ‚Üí <strong>${actualShotsAway}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Posiadanie (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedPossessionHome.toFixed(0)}% ‚Üí <strong>${actualPossessionHome}%</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Posiadanie (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedPossessionAway.toFixed(0)}% ‚Üí <strong>${actualPossessionAway}%</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Ataki (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedDangerousAttacksHome.toFixed(1)} ‚Üí <strong>${actualDangerousAttacksHome}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Ataki (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedDangerousAttacksAway.toFixed(1)} ‚Üí <strong>${actualDangerousAttacksAway}</strong></td>
                                </tr>
                            </table>
                            
                            ${actualTotalCorners <= 9.5 && score >= 7 ? `
                                <div style="margin-top: 20px; padding: 15px; background: rgba(255, 152, 0, 0.2); border-left: 4px solid #FF9800; border-radius: 5px;">
                                    <h4 style="color: #FF9800; margin-bottom: 10px;">‚ö†Ô∏è Analiza przyczyny przegranej</h4>
                                    <p style="color: #FFFFFF; margin: 5px 0;">‚Ä¢ Score: ${score}/9 (wysokie) ale tylko ${actualTotalCorners} ro≈ºnych</p>
                                    <p style="color: #FFFFFF; margin: 5px 0;">‚Ä¢ ≈örednia przed meczem: ${predictedAvgTotalCorners.toFixed(1)} ro≈ºnych</p>
                                    <p style="color: #FFFFFF; margin: 5px 0;">‚Ä¢ Mo≈ºliwe przyczyny:</p>
                                    <ul style="color: #FFFFFF; margin-left: 20px;">
                                        <li>Taktyka defensywna w tym meczu</li>
                                        <li>Brak agresywnych akcji mimo wysokich statystyk</li>
                                        <li>Warunki pogodowe lub inne czynniki zewnƒôtrzne</li>
                                        <li>Niska jako≈õƒá danych historycznych</li>
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">
                        ${homeName} vs ${awayName}
                    </div>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 20px;">
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Liga:</strong> ${league}</p>
                            <p style="color: ${statusColor}; margin: 5px 0;"><strong>Status:</strong> ${statusText}</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Rzut√≥w ro≈ºnych:</strong> ${actualCorners}</p>
                            <p style="color: #EF0107; margin: 5px 0; font-size: 1.2em;"><strong>Score:</strong> ${score}/9</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Suma %:</strong> ${percentSum.toFixed(1)}%</p>
                        </div>
                        
                        ${categories.length > 0 ? `
                            <div style="margin-top: 20px;">
                                <h4 style="color: #FFFFFF; margin-bottom: 10px;">Kryteria przed meczem:</h4>
                                ${categories.map(cat => {
                                    const color = cat.startsWith('‚úì') ? '#4CAF50' : cat.startsWith('‚úó') ? '#EF0107' : '#FFFFFF';
                                    return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
                ${comparisonHTML}
            `;
            
            // Utw√≥rz nowy modal dla szczeg√≥≈Ç√≥w
            const detailsModal = document.createElement('div');
            detailsModal.className = 'modal';
            detailsModal.id = 'historyDetailsModal';
            detailsModal.innerHTML = `
                <div class="modal-content" style="max-width: 900px;">
                    <span class="close" onclick="closeModal('historyDetailsModal')">&times;</span>
                    <h2 style="color: #EF0107; margin-bottom: 20px;">üîç Szczeg√≥≈Çy meczu</h2>
                    ${html}
                </div>
            `;
            document.body.appendChild(detailsModal);
            // Dodaj event listenery dla blokady scrollowania
            const modalContent = detailsModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.addEventListener('wheel', function(e) {
                    const { scrollTop, scrollHeight, clientHeight } = this;
                    const isAtTop = scrollTop === 0;
                    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                    
                    if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            detailsModal.style.display = 'block';
            lockBodyScroll();
        }

        // Utility functions
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function displayMessage(message, type = 'info') {
            const colors = {
                'info': '#023474',
                'success': '#4CAF50',
                'error': '#EF0107',
                'warning': '#FF9800'
            };
            
            // Utw√≥rz kontener dla komunikat√≥w, je≈õli nie istnieje
            let container = document.getElementById('messages-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'messages-container';
                document.body.appendChild(container);
            }
            
            // Utw√≥rz element komunikatu
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message-item';
            messageDiv.style.cssText = `
                background: ${colors[type]};
                color: #FFFFFF;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                animation: slideIn 0.3s;
                max-width: 400px;
                word-wrap: break-word;
            `;
            messageDiv.textContent = message;
            
            // Dodaj komunikat do kontenera
            container.appendChild(messageDiv);
            
            // Usu≈Ñ komunikat po 3 sekundach
            setTimeout(() => {
                messageDiv.style.animation = 'slideOut 0.3s';
                setTimeout(() => {
                    // P≈Çynnie zmniejsz wysoko≈õƒá i padding
                    messageDiv.style.height = messageDiv.offsetHeight + 'px';
                    messageDiv.style.overflow = 'hidden';
                    messageDiv.offsetHeight; // Force reflow
                    messageDiv.style.height = '0';
                    messageDiv.style.marginTop = '0';
                    messageDiv.style.marginBottom = '0';
                    messageDiv.style.paddingTop = '0';
                    messageDiv.style.paddingBottom = '0';
                    messageDiv.style.opacity = '0';
                    
                    // Po zako≈Ñczeniu animacji usu≈Ñ element
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                        // Je≈õli kontener jest pusty, usu≈Ñ go
                        if (container.children.length === 0) {
                            container.remove();
                        }
                    }, 300);
                }, 300);
            }, 3000);
        }

        // Blokuj przewijanie strony w tle gdy modal jest otwarty
        function lockBodyScroll() {
            document.body.classList.add('modal-open');
            // Zapisz pozycjƒô scrolla
            const scrollY = window.scrollY;
            document.body.style.top = `-${scrollY}px`;
        }

        // Odblokuj przewijanie strony w tle
        function unlockBodyScroll() {
            const scrollY = document.body.style.top;
            document.body.classList.remove('modal-open');
            document.body.style.top = '';
            if (scrollY) {
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                // Sprawd≈∫ czy inne modale sƒÖ otwarte
                const openModals = document.querySelectorAll('.modal[style*="block"]');
                if (openModals.length === 0 || (openModals.length === 1 && openModals[0].id === modalId)) {
                    unlockBodyScroll();
                }
            }
        }

        // Global state dla kartek
        let analyzedCardsMatches = [];
        let refereeStats = {}; // Cache statystyk sƒôdzi√≥w

        // Oblicz statystyki sƒôdzi√≥w z historii mecz√≥w
        function calculateRefereeStats() {
            const savedHistory = localStorage.getItem('over95_history');
            if (!savedHistory) {
                return {};
            }

            try {
                const history = JSON.parse(savedHistory);
                const stats = {};

                history.forEach(match => {
                    const matchData = match.match || {};
                    const refereeId = matchData.refereeID;
                    if (refereeId) {
                        const homeCards = matchData.team_a_cards_num || 0;
                        const awayCards = matchData.team_b_cards_num || 0;
                        const totalCards = homeCards + awayCards;

                        if (!stats[refereeId]) {
                            stats[refereeId] = { totalCards: 0, matches: 0 };
                        }
                        stats[refereeId].totalCards += totalCards;
                        stats[refereeId].matches += 1;
                    }
                });

                // Oblicz ≈õrednie
                const avgStats = {};
                for (const [refId, data] of Object.entries(stats)) {
                    if (data.matches >= 3) { // Minimum 3 mecze
                        avgStats[refId] = data.totalCards / data.matches;
                    }
                }

                return avgStats;
            } catch (e) {
                console.error('B≈ÇƒÖd obliczania statystyk sƒôdzi√≥w:', e);
                return {};
            }
        }

        // Analizuj mecz dla kartek (SUPER KOMBINACJA)
        function analyzeMatchForCards(match) {
            const dangerousAttacksHome = match.team_a_dangerous_attacks || 0;
            const dangerousAttacksAway = match.team_b_dangerous_attacks || 0;
            const foulsHome = match.team_a_fouls || 0;
            const foulsAway = match.team_b_fouls || 0;
            const refereeId = match.refereeID;

            // Kryteria SUPER KOMBINACJI:
            // 1. Dangerous Attacks ‚â•55 (co najmniej jedna dru≈ºyna)
            const dangerousAttacksOk = dangerousAttacksHome >= 55 || dangerousAttacksAway >= 55;
            
            // 2. Faule ‚â•12+12 (obie dru≈ºyny)
            const foulsOk = foulsHome >= 12 && foulsAway >= 12;
            
            // 3. Sƒôdzia z ≈õredniƒÖ kartek ‚â•4.0
            const refereeAvgCards = refereeStats[refereeId] || 0;
            const refereeOk = refereeAvgCards >= 4.0;

            const qualified = dangerousAttacksOk && foulsOk && refereeOk;

            const categories = [];
            if (dangerousAttacksOk) {
                categories.push(`‚úì Dangerous Attacks ‚â•55 (${dangerousAttacksHome} | ${dangerousAttacksAway})`);
            } else {
                categories.push(`‚úó Dangerous Attacks <55 (${dangerousAttacksHome} | ${dangerousAttacksAway})`);
            }

            if (foulsOk) {
                categories.push(`‚úì Faule ‚â•12+12 (${foulsHome} | ${foulsAway})`);
            } else {
                categories.push(`‚úó Faule <12+12 (${foulsHome} | ${foulsAway})`);
            }

            if (refereeOk) {
                categories.push(`‚úì Sƒôdzia (≈õrednia kartek: ${refereeAvgCards.toFixed(2)})`);
            } else {
                categories.push(`‚úó Sƒôdzia (≈õrednia kartek: ${refereeAvgCards.toFixed(2)} < 4.0)`);
            }

            return {
                qualified,
                categories,
                dangerousAttacksHome,
                dangerousAttacksAway,
                foulsHome,
                foulsAway,
                refereeId,
                refereeAvgCards
            };
        }

        // Oblicz statystyki sƒôdzi√≥w z WSZYSTKICH mecz√≥w (z historii + dzisiejsze)
        async function calculateRefereeStatsFromAllMatches() {
            const stats = {};
            
            // 1. Dodaj statystyki z historii (je≈õli istnieje)
            const savedHistory = localStorage.getItem('over95_history');
            if (savedHistory) {
                try {
                    const history = JSON.parse(savedHistory);
                    history.forEach(match => {
                        const matchData = match.match || {};
                        const refereeId = matchData.refereeID;
                        if (refereeId) {
                            const homeCards = matchData.team_a_cards_num || 0;
                            const awayCards = matchData.team_b_cards_num || 0;
                            const totalCards = homeCards + awayCards;

                            if (!stats[refereeId]) {
                                stats[refereeId] = { totalCards: 0, matches: 0 };
                            }
                            stats[refereeId].totalCards += totalCards;
                            stats[refereeId].matches += 1;
                        }
                    });
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu historii:', e);
                }
            }
            
            // 2. Dodaj statystyki z dzisiejszych mecz√≥w (pobierz pe≈Çne dane)
            // To zapewni, ≈ºe mamy dane o sƒôdziach nawet je≈õli nie by≈Ço analizy Over 9.5
            if (matchesData.length > 0) {
                displayMessage('Pobieranie danych o sƒôdziach z dzisiejszych mecz√≥w...', 'info');
                
                for (const match of matchesData) {
                    const matchId = match.id;
                    if (!matchId) continue;
                    
                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                const fullMatch = data.data;
                                const refereeId = fullMatch.refereeID;
                                
                                if (refereeId) {
                                    const homeCards = fullMatch.team_a_cards_num || 0;
                                    const awayCards = fullMatch.team_b_cards_num || 0;
                                    const totalCards = homeCards + awayCards;
                                    
                                    // Dodaj tylko je≈õli mecz jest zako≈Ñczony (ma kartki)
                                    if (totalCards > 0 || fullMatch.status === 'complete') {
                                        if (!stats[refereeId]) {
                                            stats[refereeId] = { totalCards: 0, matches: 0 };
                                        }
                                        stats[refereeId].totalCards += totalCards;
                                        stats[refereeId].matches += 1;
                                    }
                                }
                            }
                        }
                        // Kr√≥tkie op√≥≈∫nienie
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        // Ignoruj b≈Çƒôdy - kontynuuj z nastƒôpnym meczem
                    }
                }
            }
            
            // Oblicz ≈õrednie
            const avgStats = {};
            for (const [refId, data] of Object.entries(stats)) {
                if (data.matches >= 3) { // Minimum 3 mecze
                    avgStats[refId] = data.totalCards / data.matches;
                }
            }
            
            return avgStats;
        }

        // Analizuj wszystkie mecze dla kartek
        async function analyzeCards() {
            if (matchesData.length === 0) {
                displayMessage('Najpierw pobierz mecze!', 'warning');
                return;
            }

            showLoading(true);
            displayMessage('Obliczanie statystyk sƒôdzi√≥w...', 'info');

            try {
                // Oblicz statystyki sƒôdzi√≥w z WSZYSTKICH mecz√≥w (historia + dzisiejsze)
                refereeStats = await calculateRefereeStatsFromAllMatches();
                console.log(`üìä Obliczono statystyki dla ${Object.keys(refereeStats).length} sƒôdzi√≥w`);

                // Pobierz nazwy lig
                const leaguesMap = await fetchLeagueNames();

                analyzedCardsMatches = [];
                let processed = 0;
                const total = matchesData.length;

                displayMessage('Analizowanie mecz√≥w dla kartek...', 'info');

                for (const match of matchesData) {
                    processed++;
                    const progress = Math.round((processed / total) * 100);
                    if (processed % 10 === 0) {
                        displayMessage(`Analizowanie meczu ${processed}/${total} (${progress}%)...`, 'info');
                    }

                    // Pobierz pe≈Çne dane meczu (potrzebujemy dangerous_attacks i fouls)
                    const matchId = match.id;
                    if (!matchId) continue;

                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }

                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                const fullMatch = data.data;
                                
                                // Analizuj mecz
                                const analysis = analyzeMatchForCards(fullMatch);
                                
                                if (analysis.qualified) {
                                    analyzedCardsMatches.push({
                                        match: fullMatch,
                                        league: leaguesMap[fullMatch.competition_id] || `Liga ID: ${fullMatch.competition_id}`,
                                        analysis,
                                        home_name: fullMatch.home_name || match.home_name,
                                        away_name: fullMatch.away_name || match.away_name,
                                        time: fullMatch.date_unix ? new Date(fullMatch.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-'
                                    });
                                }
                            }
                        }
                        // Op√≥≈∫nienie miƒôdzy requestami
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`B≈ÇƒÖd pobierania meczu ${matchId}:`, error);
                    }
                }

                showLoading(false);
                displayCardsResults();
                openModal('cardsModal');

                if (analyzedCardsMatches.length > 0) {
                    displayMessage(`‚úì Znaleziono ${analyzedCardsMatches.length} mecz√≥w kwalifikujƒÖcych siƒô do Over 3.5 kartek!`, 'success');
                } else {
                    displayMessage('‚ÑπÔ∏è Nie znaleziono mecz√≥w spe≈ÇniajƒÖcych kryteria SUPER KOMBINACJI', 'info');
                }

            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd analizy kartek:', error);
                displayMessage('B≈ÇƒÖd analizy kartek: ' + error.message, 'error');
            }
        }

        // Wy≈õwietl wyniki analizy kartek
        function displayCardsResults() {
            const content = document.getElementById('cards-content');
            
            if (analyzedCardsMatches.length === 0) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center;">
                            Brak mecz√≥w kwalifikujƒÖcych siƒô do Over 3.5 kartek.<br>
                            <strong style="color: #FFA500;">SUPER KOMBINACJA:</strong><br>
                            - Dangerous Attacks ‚â•55 (co najmniej jedna dru≈ºyna)<br>
                            - Faule ‚â•12+12 (obie dru≈ºyny)<br>
                            - Sƒôdzia z ≈õredniƒÖ kartek ‚â•4.0<br><br>
                            <span style="color: rgba(255,255,255,0.7); font-size: 0.9em;">
                                Dok≈Çadno≈õƒá: 87.50% (48 mecz√≥w w historii)
                            </span>
                        </p>
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="analyzeCards()" class="btn btn-secondary" style="background: #FFA500; color: #000;">üîÑ Analizuj ponownie</button>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 165, 0, 0.2); border-radius: 10px; border-left: 4px solid #FFA500;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="color: #FFA500; margin-bottom: 10px;">‚úÖ Znaleziono ${analyzedCardsMatches.length} mecz√≥w kwalifikujƒÖcych siƒô</h3>
                            <p style="color: #FFFFFF;">SUPER KOMBINACJA: Dangerous Attacks + Faule + Sƒôdzia</p>
                            <p style="color: rgba(255,255,255,0.7); font-size: 0.9em; margin-top: 5px;">
                                Dok≈Çadno≈õƒá: 87.50% (48 mecz√≥w w historii)
                            </p>
                        </div>
                        <button onclick="analyzeCards()" class="btn btn-secondary" style="background: #FFA500; color: #000; padding: 10px 20px; font-size: 14px;">üîÑ Analizuj ponownie</button>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            `;
            
            // Podziel mecze naprzemiennie miƒôdzy kolumny
            const leftColumn = [];
            const rightColumn = [];
            
            analyzedCardsMatches.forEach((item, index) => {
                if (index % 2 === 0) {
                    leftColumn.push(item);
                } else {
                    rightColumn.push(item);
                }
            });
            
            // Lewa kolumna
            html += '<div>';
            leftColumn.forEach(item => {
                const { match, league, analysis } = item;
                html += `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header" style="background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);">
                            üèÜ ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 165, 0, 0.2); border-radius: 8px;">
                                <p style="color: #FFA500; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    ‚úÖ Kwalifikuje siƒô do Over 3.5 kartek
                                </p>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold;">Kryteria:</p>
                                ${analysis.categories.map(cat => `
                                    <p style="color: ${cat.startsWith('‚úì') ? '#4CAF50' : '#EF0107'}; margin: 3px 0; font-size: 0.95em;">
                                        ${cat}
                                    </p>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Prawa kolumna
            html += '<div>';
            rightColumn.forEach(item => {
                const { match, league, analysis } = item;
                html += `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header" style="background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);">
                            üèÜ ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 165, 0, 0.2); border-radius: 8px;">
                                <p style="color: #FFA500; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    ‚úÖ Kwalifikuje siƒô do Over 3.5 kartek
                                </p>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold;">Kryteria:</p>
                                ${analysis.categories.map(cat => `
                                    <p style="color: ${cat.startsWith('‚úì') ? '#4CAF50' : '#EF0107'}; margin: 3px 0; font-size: 0.95em;">
                                        ${cat}
                                    </p>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            html += '</div>';
            content.innerHTML = html;
        }

        // Funkcja do otwierania modala z blokadƒÖ scrollowania
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'block';
                lockBodyScroll();
                
                // Blokuj scroll w modal-content, ≈ºeby nie przewija≈Ço strony w tle
                // U≈ºyj flagi, ≈ºeby nie duplikowaƒá event listener√≥w
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent && !modalContent.dataset.scrollLocked) {
                    modalContent.dataset.scrollLocked = 'true';
                    
                    // Blokuj scroll k√≥≈Çkiem myszy na granicach
                    modalContent.addEventListener('wheel', function(e) {
                        const { scrollTop, scrollHeight, clientHeight } = this;
                        const isAtTop = scrollTop === 0;
                        const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                        
                        // Je≈õli jeste≈õmy na g√≥rze i scrollujemy w g√≥rƒô, lub na dole i scrollujemy w d√≥≈Ç, zablokuj
                        if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }, { passive: false });
                    
                    // Blokuj touchmove na granicach (dla urzƒÖdze≈Ñ mobilnych)
                    let lastTouchY = 0;
                    modalContent.addEventListener('touchstart', function(e) {
                        lastTouchY = e.touches[0].clientY;
                    }, { passive: true });
                    
                    modalContent.addEventListener('touchmove', function(e) {
                        const { scrollTop, scrollHeight, clientHeight } = this;
                        const currentTouchY = e.touches[0].clientY;
                        const deltaY = lastTouchY - currentTouchY;
                        
                        const isAtTop = scrollTop === 0;
                        const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                        
                        // Je≈õli jeste≈õmy na g√≥rze i przesuwamy w g√≥rƒô, lub na dole i przesuwamy w d√≥≈Ç, zablokuj
                        if ((isAtTop && deltaY < 0) || (isAtBottom && deltaY > 0)) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        
                        lastTouchY = currentTouchY;
                    }, { passive: false });
                }
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    closeModal(modal.id || '');
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('Corner Predictor initialized');
            
            // Spr√≥buj za≈Çadowaƒá nazwy lig
            await fetchLeagueNames();
            
            // Automatyczna weryfikacja wynik√≥w przy pierwszym uruchomieniu w nowym dniu
            await autoVerifyOnNewDay();
            
            // Spr√≥buj za≈Çadowaƒá dane z localStorage
            const savedMatches = localStorage.getItem('matchesData');
            const savedDate = localStorage.getItem('matchesDate');
            const today = new Date().toISOString().split('T')[0];
            
            if (savedMatches && savedDate === today) {
                try {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj te≈º z cache (na wypadek je≈õli by≈Çy w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('Za≈Çadowano dane z cache', 'info');
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu cache:', e);
                }
            }
            
        });
    </script>
</body>
</html>

