<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corners Predictor v12 ‚Äì 6 ≈πR√ìDE≈Å | 60%+</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: #fff;
            text-align: center;
            padding: 20px;
            min-height: 100vh;
        }
        h1 { color: #ff5722; font-size: 2em; margin-bottom: 10px; }
        .subtitle { color: #aaa; margin-bottom: 20px; }
        .buttons { margin: 20px 0; }
        button {
            background: #ff5722; color: white; border: none; padding: 14px 28px; margin: 8px;
            font-size: 16px; font-weight: bold; cursor: pointer; border-radius: 12px;
            transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        button:hover { background: #e64a19; transform: translateY(-2px); }
        table {
            width: 100%; max-width: 1200px; margin: 25px auto; border-collapse: collapse;
            background: #1a1a2e; border-radius: 12px; overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            display: block; max-height: 600px; overflow-y: auto;
        }
        table thead { position: sticky; top: 0; background: #16213e; z-index: 10; }
        table tbody { display: table; width: 100%; }
        th { background: #16213e; padding: 16px; font-weight: bold; text-transform: uppercase; font-size: 0.9em; }
        td { padding: 14px; border-bottom: 1px solid #333; }
        tr:hover { background: #222840; }
        .hit { background: #2e7d32 !important; animation: pulse 1s; color: #fff; }
        .miss { background: #c62828 !important; color: #fff; }
        .pending { background: #ff8f00; color: #000; font-weight: bold; }
        .medium { color: #ffd700; font-weight: bold; }
        .high { color: #00ff00; font-weight: bold; }
        .link { color: #4fc3f7; text-decoration: underline; cursor: pointer; }
        .details-row { background: #0f0f23 !important; }
        .details-content { padding: 20px; color: #ccc; line-height: 1.8; }
        .team-stats { display: inline-block; margin: 10px 20px; padding: 10px; background: #1a1a2e; border-radius: 8px; }
        .expand-btn { cursor: pointer; color: #4fc3f7; font-size: 0.9em; user-select: none; }
        #stats {
            font-size: 1.3em; margin: 25px 0; padding: 15px;
            background: rgba(255, 87, 34, 0.1); border-radius: 12px; display: inline-block;
        }
        canvas { margin: 30px auto; max-width: 400px; }
        .loader {
            display: inline-block; width: 20px; height: 20px;
            border: 3px solid #f3f3f3; border-top: 3px solid #ff5722;
            border-radius: 50%; animation: spin 1s linear infinite; margin-left: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
        footer { margin-top: 50px; font-size: 0.9em; color: #888; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Corners Predictor <span id="version">v1.01</span> <span id="loader" class="loader" style="display:none;"></span></h1>
        <p class="subtitle">‚úÖ Sportmonks + FootyStats W≈ÅƒÑCZONE - Podw√≥jna weryfikacja danych!</p>

        <div class="buttons">
            <button id="btn-today">SZUKAJ MECZ√ìW NA DZI≈ö</button>
            <button id="btn-sportmonks">POBIERZ MECZE (Sportmonks)</button>
            <button id="btn-footystats">POBIERZ MECZE (FootyStats)</button>
        </div>

        <p id="info">Kliknij przycisk, by pobraƒá mecze na dzi≈õ...</p>
        <p id="api-status" style="font-size: 0.9em; color: #ffa500; margin-top: 10px;"></p>

        <table id="predictions" style="display:none;">
            <tr>
                <th>Mecz</th>
                <th>Liga</th>
                <th>≈örednia %</th>
                <th>ZGODNO≈öƒÜ</th>
                <th>Link</th>
                <th>Status</th>
            </tr>
        </table>

        <div id="stats" style="display:none;">Hit Rate: ‚Äî | ROI: ‚Äî</div>
        <canvas id="chart" style="display:none;"></canvas>

        <footer>
            <p>CornersBot v12 ¬© 2025 | 6 ≈∫r√≥de≈Ç | corsproxy.io</p>
        </footer>
    </div>

    <script>
        // === KLUCZE (UKRYTE) ===
        const SPORTMONKS_KEY = 'zWSF4VIJJHhBOw4xizgqFPS795qiOdxes0y9B1AhqeBeAKBLrKx8283Ivsks';
        const FOOTYSTATS_KEY = '8cdad7757b702fae3b792c0b3328017ee33cc17594b18ea8a2717cdc53162325';
        
        // Mo≈ºesz dodaƒá wiƒôcej kluczy API-Football (je≈õli masz)
        const API_FOOTBALL_KEYS = [
            'fb9b429fc619754e0ce3ad2a9e5be39b',
            // 'DODAJ_TUTAJ_KOLEJNY_KLUCZ_JE≈öLI_MASZ',
            // 'I_KOLEJNY',
        ];
        let currentKeyIndex = 0;

        // === PROXY (DZIA≈ÅA Z HEADERAMI!) ===
        const PROXY = 'https://corsproxy.io/?';

        let predictions = [];
        let hits = 0, total = 0;
        let chartInstance = null;
        let apiFootballLimitReached = false;

        // Za≈Çaduj wersjƒô przy starcie
        async function loadVersion() {
            try {
                const response = await fetch('version.json?t=' + Date.now());
                const data = await response.json();
                document.getElementById('version').textContent = 'v' + data.version;
                console.log('üìå Wersja aplikacji:', data.version, '| Ostatnia aktualizacja:', data.updated);
            } catch (e) {
                console.warn('Nie mo≈ºna za≈Çadowaƒá wersji:', e);
            }
        }
        
        // Uruchom przy ≈Çadowaniu strony
        loadVersion();
        
        // Inicjalizuj event listenery dla przycisk√≥w (zamiast inline onclick)
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('btn-today').addEventListener('click', loadTodayMatches);
            document.getElementById('btn-sportmonks').addEventListener('click', checkAvailableLeagues);
            document.getElementById('btn-footystats').addEventListener('click', testFootyStatsAPI);
        });

        // Funkcja pomocnicza do przetwarzania mecz√≥w
        async function processFixtures(fixtures) {
                for (let fix of fixtures) {
                    const home = fix.teams.home.name;
                    const away = fix.teams.away.name;
                    const league = fix.league.name;
                    const id = fix.fixture.id;

                console.log(`\nüéØ Analizujƒô: ${home} vs ${away}`);

                    const probs = await getAllProbabilities(home, away, id, league);
                if (!probs) {
                    console.log('‚ùå B≈ÇƒÖd pobierania prawdopodobie≈Ñstw');
                    continue;
                }

                console.log('üìä Prawdopodobie≈Ñstwa:', probs);

                    // Filtrujemy tylko aktywne ≈∫r√≥d≈Ça (nie null, nie 0)
                    const activeProbs = probs.filter(p => p && p > 0);
                    const avgProb = activeProbs.length > 0 
                        ? Math.round(activeProbs.reduce((a, b) => a + b, 0) / activeProbs.length)
                        : 0;
                    const agree = activeProbs.length > 0
                        ? Math.round(activeProbs.filter(p => p >= 60).length / activeProbs.length * 100)
                        : 0;

                console.log(`üìà ≈örednia: ${avgProb}% | Zgodno≈õƒá: ${agree}% (z ${activeProbs.length} ≈∫r√≥de≈Ç)`);

                    // ‚ö†Ô∏è ZMIENIONE: Pr√≥g obni≈ºony do 30% bo wiƒôkszo≈õƒá API wy≈ÇƒÖczona
                    if (agree >= 30 && avgProb >= 55) {
                    console.log('‚úÖ Mecz spe≈Çnia kryteria (zgdn.‚â•30%, ≈õr.‚â•55%)!');
                        
                        // Zapisz szczeg√≥≈Çy predykcji z window.lastMatchProbs
                        const probDetails = window.lastMatchProbs || {};
                        
                        predictions.push({
                            match: `${home} vs ${away}`,
                            league,
                            avgProb,
                            agree,
                            id,
                            status: 'Oczekuje',
                            homeTeam: home,
                            awayTeam: away,
                            // Dodaj szczeg√≥≈Çy predykcji
                            probDetails: {
                                sportmonks: probDetails.p1,
                                footystats: probDetails.p2,
                                apifootball: probDetails.p3,
                                totalcorner: probDetails.p4,
                                betoncorners: probDetails.p5,
                                cornerstat: probDetails.p6
                            }
                    });
                } else {
                    console.log(`‚ùå Mecz NIE spe≈Çnia kryteri√≥w (zgdn:${agree}%<30% LUB ≈õr:${avgProb}%<55%)`);
                }
            }
        }

        async function loadMatchesForDate(daysOffset = 0) {
            document.getElementById('loader').style.display = 'inline-block';
            document.getElementById('info').textContent = 'üîç Wyszukujƒô mecze...';
            document.getElementById('predictions').style.display = 'none';
            predictions = [];

            try {
                const date = new Date();
                date.setDate(date.getDate() + daysOffset);
                const dateStr = date.toISOString().split('T')[0];
                
                console.log('üîç Pobieranie mecz√≥w na:', dateStr);
                console.log('üì° ≈πr√≥d≈Ça: Sportmonks + FootyStats');
                document.getElementById('api-status').innerHTML = 'üì° <strong>Sportmonks + FootyStats</strong> aktywne';
                
                // U≈ºywaj Sportmonks jako g≈Ç√≥wnego ≈∫r√≥d≈Ça mecz√≥w
                let fixtures = null;
                
                // Pobierz mecze ze Sportmonks
                console.log('üîÑ Pobieranie z Sportmonks...');
                
                // U≈ªYWAMY PROXY (bezpo≈õrednie po≈ÇƒÖczenie blokuje CORS)
                // DODANO: include=league ≈ºeby pobraƒá nazwƒô ligi
                const sportmonksUrl = `${PROXY}https://api.sportmonks.com/v3/football/fixtures/date/${dateStr}?api_token=${SPORTMONKS_KEY}&include=league`;
                console.log('üì° Sportmonks URL (przez PROXY, z league):', sportmonksUrl);
                console.log('üìÖ Data szukania:', dateStr);
                
                let smRes;
                try {
                    smRes = await fetch(sportmonksUrl);
                    console.log('üìù Sportmonks Status:', smRes.status);
                } catch (fetchError) {
                    console.error('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia:', fetchError);
                    throw new Error('Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z API: ' + fetchError.message);
                }
                
                console.log('üìù Sportmonks Status Text:', smRes.statusText);
                console.log('üìù Sportmonks Headers:', Array.from(smRes.headers.entries()));
                
                // Sprawd≈∫ content-type przed parsowaniem
                const contentType = smRes.headers.get('content-type');
                console.log('üìù Content-Type:', contentType);
                
                let smData;
                if (contentType && contentType.includes('application/json')) {
                    smData = await smRes.json();
                } else {
                    // Odpowied≈∫ nie jest JSON (prawdopodobnie HTML z b≈Çƒôdem)
                    const textResponse = await smRes.text();
                    console.error('‚ùå Odpowied≈∫ NIE JEST JSON:', textResponse.substring(0, 200));
                    
                    if (smRes.status === 403) {
                        throw new Error('‚õî CORS Proxy (corsproxy.io) zablokowany przez Cloudflare! Spr√≥buj za 5-10 minut lub u≈ºyj VPN.');
                    }
                    
                    throw new Error(`Sportmonks zwr√≥ci≈Ço ${smRes.status}: ${textResponse.substring(0, 100)}`);
                }
                console.log('üì¶ Sportmonks PE≈ÅNA ODPOWIED≈π:', JSON.stringify(smData, null, 2));
                
                // Sprawd≈∫ pagination
                if (smData.pagination) {
                    console.log('üìÑ PAGINATION:', smData.pagination);
                    console.log(`   Strona: ${smData.pagination.current_page}/${smData.pagination.last_page}`);
                    console.log(`   Razem: ${smData.pagination.total} mecz√≥w`);
                }
                
                if (smRes.ok) {
                    console.log('‚úÖ Sportmonks odpowied≈∫ OK');
                    console.log('üìä Struktura odpowiedzi:', Object.keys(smData));
                    
                    if (smData.data && smData.data.length > 0) {
                        console.log(`‚úÖ [Sportmonks] Znaleziono ${smData.data.length} mecz√≥w na tej stronie`);
                        
                        // Sprawd≈∫ czy sƒÖ kolejne strony
                        let allFixtures = [...smData.data];
                        const totalPages = smData.pagination?.last_page || 1;
                        const currentPage = smData.pagination?.current_page || 1;
                        
                        if (totalPages > 1) {
                            console.log(`üìÑ Wykryto ${totalPages} stron - pobieram wszystkie...`);
                            document.getElementById('info').textContent = `Pobieranie ${smData.pagination.total} mecz√≥w z ${totalPages} stron...`;
                            
                            // Pobierz pozosta≈Çe strony (max 5 stron = ~200 mecz√≥w)
                            for (let page = 2; page <= Math.min(totalPages, 5); page++) {
                                const pageUrl = `${PROXY}https://api.sportmonks.com/v3/football/fixtures/date/${dateStr}?api_token=${SPORTMONKS_KEY}&include=league&page=${page}`;
                                console.log(`üìÑ Pobieram stronƒô ${page}/${totalPages}...`);
                                const pageRes = await fetch(pageUrl);
                                const pageData = await pageRes.json();
                                if (pageData.data) {
                                    allFixtures = [...allFixtures, ...pageData.data];
                                    console.log(`   ‚úÖ +${pageData.data.length} mecz√≥w (razem: ${allFixtures.length})`);
                                }
                            }
                        }
                        
                        console.log(`‚úÖ RAZEM pobrano ${allFixtures.length} mecz√≥w`);
                        console.log('üìã Przyk≈Çadowy mecz (pierwszy):', allFixtures[0]);
                        console.log('üîë Klucze meczu:', Object.keys(allFixtures[0]));
                        
                        // Sprawd≈∫my strukturƒô pierwszego meczu
                        const firstMatch = allFixtures[0];
                        console.log('üè† Home team:', firstMatch.home_team || firstMatch.localteam || firstMatch.teams);
                        console.log('üöÄ Away team:', firstMatch.away_team || firstMatch.visitorteam || firstMatch.teams);
                        console.log('üèÜ Liga:', firstMatch.league || firstMatch.league_id);
                        
                        fixtures = allFixtures.map(fix => {
                            // Parsuj pole "name" kt√≥re ma format "Team1 vs Team2"
                            const matchName = fix.name || '';
                            const teams = matchName.split(' vs ');
                            const homeName = teams[0]?.trim() || 'Unknown';
                            const awayName = teams[1]?.trim() || 'Unknown';
                            
                            // Pobierz nazwƒô ligi z include (je≈õli jest)
                            let leagueName = 'Unknown League';
                            if (fix.league && fix.league.name) {
                                leagueName = fix.league.name;
                            } else if (fix.league_id) {
                                leagueName = `Liga ID: ${fix.league_id}`;
                            }
                            
                            return {
                                fixture: { id: fix.id },
                                teams: {
                                    home: { name: homeName },
                                    away: { name: awayName }
                                },
                                league: { name: leagueName }
                            };
                        });
                    }
                } else {
                    console.error('‚ùå Sportmonks b≈ÇƒÖd:', smRes.status, smRes.statusText);
                    console.error('üì¶ Odpowied≈∫ b≈Çƒôdu Sportmonks:', smData);
                    
                    // Sprawd≈∫ czy jest komunikat b≈Çƒôdu w odpowiedzi
                    if (smData.message) {
                        console.error('üí¨ Komunikat b≈Çƒôdu:', smData.message);
                    }
                    if (smData.errors) {
                        console.error('‚ö†Ô∏è Szczeg√≥≈Çy b≈Çƒôdu:', smData.errors);
                    }
                }
                
                if (!fixtures || fixtures.length === 0) {
                    console.error('‚ùå Brak mecz√≥w ze Sportmonks');
                    console.error('üîç Mo≈ºliwe przyczyny:');
                    console.error('   - Nieprawid≈Çowy endpoint API');
                    console.error('   - Nieprawid≈Çowy format daty:', dateStr);
                    console.error('   - Problemy z kluczem API');
                    console.error('   - Limit zapyta≈Ñ osiƒÖgniƒôty');
                    
                    document.getElementById('info').innerHTML = `
                        ‚ùå B≈ÇƒÖd Sportmonks (${smRes.status})<br>
                        Sprawd≈∫ konsolƒô (F12) aby zobaczyƒá szczeg√≥≈Çy
                    `;
                    document.getElementById('loader').style.display = 'none';
                    return;
                }
                
                console.log(`‚öΩ Znaleziono ${fixtures.length} mecz√≥w ze Sportmonks`);
                if (fixtures.length > 50) {
                    document.getElementById('api-status').innerHTML = `‚úÖ <strong>Sportmonks dzia≈Ça poprawnie</strong> (API-Football wy≈ÇƒÖczone) | Pobrano ${fixtures.length} mecz√≥w - tabela ma scrollowanie`;
                } else {
                    document.getElementById('api-status').innerHTML = '‚úÖ <strong>Sportmonks dzia≈Ça poprawnie</strong> (API-Football wy≈ÇƒÖczone do testu)';
                }
                
                // Przetw√≥rz mecze ze Sportmonks
                await processFixtures(fixtures);
                displayResults();
            } catch (e) {
                console.error('üí• B≈ÅƒÑD:', e);
                document.getElementById('info').textContent = 'B≈ÇƒÖd: ' + e.message;
            }
            document.getElementById('loader').style.display = 'none';
        }

        async function loadTodayMatches() {
            return loadMatchesForDate(0);
        }

        // Funkcja do pobierania historii mecz√≥w dru≈ºyny
        async function getTeamHistory(teamName, fixtureId) {
            try {
                console.log(`üîç Szukam historii dla: ${teamName}`);
                
                // Szukaj dru≈ºyny po nazwie
                const searchUrl = `${PROXY}https://api.sportmonks.com/v3/football/teams/search/${encodeURIComponent(teamName)}?api_token=${SPORTMONKS_KEY}`;
                console.log(`üì° URL szukania dru≈ºyny: ${searchUrl}`);
                
                const searchRes = await fetch(searchUrl);
                
                if (!searchRes.ok) {
                    console.error(`‚ùå B≈ÇƒÖd ${searchRes.status} przy szukaniu dru≈ºyny`);
                    return { error: `B≈ÇƒÖd API (${searchRes.status})` };
                }
                
                const searchData = await searchRes.json();
                
                if (!searchData.data || searchData.data.length === 0) {
                    return { error: 'Nie znaleziono dru≈ºyny' };
                }
                
                const teamId = searchData.data[0].id;
                console.log(`‚úÖ Znaleziono dru≈ºynƒô ${teamName}, ID: ${teamId}`);
                
                // Pobierz ostatnie mecze dru≈ºyny ZE STATYSTYKAMI
                // include=latest.statistics pobiera statystyki dla ka≈ºdego meczu
                const historyUrl = `${PROXY}https://api.sportmonks.com/v3/football/teams/${teamId}?api_token=${SPORTMONKS_KEY}&include=latest.statistics.type`;
                console.log(`üì° URL historii (teams/${teamId}/latest+statistics): ${historyUrl}`);
                
                const historyRes = await fetch(historyUrl);
                
                if (!historyRes.ok) {
                    console.error(`‚ùå B≈ÇƒÖd ${historyRes.status} przy pobieraniu historii`);
                    return { error: `B≈ÇƒÖd API historii (${historyRes.status})` };
                }
                
                const historyData = await historyRes.json();
                console.log(`üì¶ Historia dla ${teamName}:`, JSON.stringify(historyData).substring(0, 500));
                console.log(`üì¶ Pe≈Çna struktura:`, historyData);
                
                // Teams endpoint zwraca: data.latest (tablica mecz√≥w)
                const teamData = historyData.data || {};
                const fixtures = teamData.latest || [];
                
                console.log(`üìä Team data keys:`, Object.keys(teamData));
                console.log(`üìä Latest fixtures:`, fixtures.length);
                
                if (!Array.isArray(fixtures) || fixtures.length === 0) {
                    console.warn(`‚ö†Ô∏è Brak mecz√≥w w historii dla ${teamName}`);
                    console.log(`‚ö†Ô∏è Fixtures type:`, typeof fixtures, fixtures);
                    return { error: 'Brak historii mecz√≥w' };
                }
                
                console.log(`üìä Znaleziono ${fixtures.length} ostatnich mecz√≥w`);
                
                // Filtruj tylko zako≈Ñczone mecze (state_id: 5 = finished, 6/7 = finished with penalties/extra time)
                const finishedFixtures = fixtures.filter(f => f.state_id === 5 || f.state_id === 6 || f.state_id === 7);
                console.log(`‚úÖ Zako≈Ñczonych mecz√≥w: ${finishedFixtures.length}`);
                
                // WyciƒÖgnij statystyki ro≈ºnych z ostatnich 5 ZAKO≈ÉCZONYCH mecz√≥w
                const matches = finishedFixtures.slice(0, 5).map((match, index) => {
                    console.log(`\nüìã Mecz ${index + 1}: ${match.name}`);
                    console.log(`   ID: ${match.id}, Data: ${match.starting_at}`);
                    console.log(`   üÜî Szukam ro≈ºnych dla team_id: ${teamId}`);
                    
                    const stats = match.statistics || [];
                    console.log(`   üìä Statystyk: ${stats.length}`);
                    
                    if (stats.length > 0) {
                        // Poka≈º pierwsze 3 statystyki jako przyk≈Çad
                        console.log(`   üîç Przyk≈Çadowe statystyki:`, stats.slice(0, 3));
                        
                        // Poka≈º wszystkie type_id i nazwy Z participant_id
                        const types = stats.map(s => ({
                            type_id: s.type_id,
                            participant_id: s.participant_id,
                            type_name: s.type?.name || 'N/A',
                            data: s.data
                        }));
                        console.log(`   üè∑Ô∏è Wszystkie typy:`, types);
                    }
                    
                    // Szukaj ro≈ºnych DLA TEJ DRU≈ªYNY (sprawd≈∫ participant_id!)
                    // type_id: 34 = Corners w Sportmonks v3
                    const corners = stats.find(s => 
                        (s.type_id === 12 || s.type_id === 34 || s.type_id === 70 || 
                         s.type?.name?.toLowerCase().includes('corner') ||
                         s.type?.name?.toLowerCase().includes('ro≈ºn')) &&
                        s.participant_id === teamId  // ‚Üê KLUCZOWE: tylko statystyki tej dru≈ºyny!
                    );
                    
                    if (corners) {
                        console.log(`   ‚úÖ Znaleziono ro≈ºne:`, corners);
                    } else {
                        console.warn(`   ‚ö†Ô∏è NIE znaleziono statystyk ro≈ºnych!`);
                    }
                    
                    return {
                        opponent: match.name,
                        date: match.starting_at,
                        corners: corners?.data?.value || '?'
                    };
                });
                
                const avgCorners = matches
                    .filter(m => m.corners !== '?')
                    .reduce((sum, m) => sum + parseInt(m.corners), 0) / matches.length;
                
                return { teamId, matches, avgCorners: avgCorners.toFixed(1) };
            } catch (e) {
                console.error('B≈ÇƒÖd pobierania historii:', e);
                return { error: e.message };
            }
        }

        // Funkcja do pokazywania/ukrywania szczeg√≥≈Ç√≥w (MUSI BYƒÜ W WINDOW)
        window.toggleDetails = function(matchId) {
            console.log('üîç toggleDetails wywo≈Çane dla:', matchId, 'typ:', typeof matchId);
            console.log('üì¶ Dostƒôpne predictions:', predictions.length);
            
            // Konwertuj matchId na number (z HTML przychodzi jako string!)
            const numericId = parseInt(matchId);
            console.log('üî¢ Konwersja ID:', matchId, '‚Üí', numericId);
            
            const detailsRow = document.getElementById(`details-${matchId}`);
            if (detailsRow) {
                console.log('üóëÔ∏è Zamykam szczeg√≥≈Çy');
                detailsRow.remove();
                return;
            }
            
            // Pobierz dane meczu (por√≥wnuj number z number!)
            const match = predictions.find(p => p.id === numericId);
            if (!match) {
                console.error('‚ùå Nie znaleziono meczu o ID:', matchId);
                console.log('üìã Dostƒôpne ID:', predictions.map(p => p.id));
                return;
            }
            console.log('‚úÖ Znaleziono mecz:', match);
            
            // Dodaj wiersz ze szczeg√≥≈Çami
            const mainRow = document.querySelector(`#s-${matchId}`).closest('tr');
            const newRow = mainRow.insertAdjacentElement('afterend', document.createElement('tr'));
            newRow.id = `details-${matchId}`;
            newRow.className = 'details-row';
            newRow.innerHTML = `<td colspan="6" class="details-content">
                ‚è≥ ≈Åadowanie historii mecz√≥w...
            </td>`;
            
            // Pobierz historiƒô obu dru≈ºyn
            const homeTeam = match.homeTeam;
            const awayTeam = match.awayTeam;
            
            Promise.all([
                getTeamHistory(homeTeam, matchId),
                getTeamHistory(awayTeam, matchId)
            ]).then(([homeHistory, awayHistory]) => {
                let html = '<div style="text-align: left;">';
                
                // Historia dru≈ºyny gospodarzy
                html += `<div class="team-stats">
                    <strong>üè† ${homeTeam}</strong><br>
                    ≈örednia ro≈ºnych (ostatnie 5): <strong>${homeHistory.avgCorners || '?'}</strong><br>
                    <small style="color:#888;">`;
                if (homeHistory.matches) {
                    homeHistory.matches.forEach(m => {
                        html += `${m.opponent}: ${m.corners} ro≈ºnych<br>`;
                    });
                } else {
                    html += homeHistory.error || 'Brak danych';
                }
                html += `</small></div>`;
                
                // Historia dru≈ºyny go≈õci
                html += `<div class="team-stats">
                    <strong>üöÄ ${awayTeam}</strong><br>
                    ≈örednia ro≈ºnych (ostatnie 5): <strong>${awayHistory.avgCorners || '?'}</strong><br>
                    <small style="color:#888;">`;
                if (awayHistory.matches) {
                    awayHistory.matches.forEach(m => {
                        html += `${m.opponent}: ${m.corners} ro≈ºnych<br>`;
                    });
                } else {
                    html += awayHistory.error || 'Brak danych';
                }
                html += `</small></div>`;
                
                // PREDYKCJE Z WSZYSTKICH ≈πR√ìDE≈Å
                html += `<br><div class="team-stats" style="background: #1a2a3a; border: 2px solid #4af;">
                    <strong>üìä Predykcje prawdopodobie≈Ñstwa Over 9.5 ro≈ºnych</strong><br><br>`;
                
                const probs = match.probDetails || {};
                
                // Sportmonks
                if (probs.sportmonks) {
                    html += `‚úÖ <strong>Sportmonks:</strong> ${probs.sportmonks}% <small>(analiza ostatnich 10 mecz√≥w)</small><br>`;
                } else {
                    html += `‚ö™ <strong>Sportmonks:</strong> Brak danych<br>`;
                }
                
                // FootyStats
                if (probs.footystats) {
                    html += `‚úÖ <strong>FootyStats:</strong> ${probs.footystats}% <small>(analiza ostatnich 10 mecz√≥w)</small><br>`;
                } else {
                    html += `‚ö™ <strong>FootyStats:</strong> Brak danych<br>`;
                }
                
                // API-Football
                if (probs.apifootball) {
                    html += `‚úÖ <strong>API-Football:</strong> ${probs.apifootball}%<br>`;
                } else {
                    html += `‚è∏Ô∏è <strong>API-Football:</strong> Wy≈ÇƒÖczone (limit)<br>`;
                }
                
                // Web scraping usuniƒôty
                html += `<br><small style="color:#888;">‚ö†Ô∏è Web scraping (TotalCorner, BetOnCorners, CornerStat) usuniƒôty - niestabilny</small><br>`;
                
                // Podsumowanie - tylko Sportmonks i FootyStats
                const activeProbs = [probs.sportmonks, probs.footystats].filter(p => p);
                if (activeProbs.length > 0) {
                    const avg = Math.round(activeProbs.reduce((a,b) => a+b, 0) / activeProbs.length);
                    html += `<strong style="color:#4af; font-size:1.2em;">üéØ ≈öREDNIA: ${avg}% (z ${activeProbs.length} ${activeProbs.length === 1 ? '≈∫r√≥d≈Ça' : '≈∫r√≥de≈Ç'})</strong>`;
                } else {
                    html += `<small style="color:#f88;">‚ö†Ô∏è Brak danych z API</small>`;
                }
                
                html += `</div>`;
                
                html += `<br><small style="color:#aaa;">üí° Historia ostatnich 5 mecz√≥w + analiza Sportmonks (10) + FootyStats (10) = kompleksowe dane</small>`;
                html += '</div>';
                
                newRow.querySelector('.details-content').innerHTML = html;
            });
        };

        async function checkAvailableLeagues() {
            document.getElementById('loader').style.display = 'inline-block';
            document.getElementById('info').textContent = 'üîç Pobieranie dzisiejszych mecz√≥w z Sportmonks...';
            
            try {
                // Pobierz dzisiejsze mecze z Sportmonks
                const today = new Date().toISOString().split('T')[0];
                const url = `${PROXY}https://api.sportmonks.com/v3/football/fixtures/date/${today}?api_token=${SPORTMONKS_KEY}&include=league`;
                console.log('üì° Sportmonks - pobieranie mecz√≥w na:', today, url);
                
                const res = await fetch(url);
                const data = await res.json();
                
                console.log('üì¶ Odpowied≈∫ Sportmonks:', data);
                
                if (data.data && data.data.length > 0) {
                    let allMatches = data.data;
                    console.log(`üì• Sportmonks: Pobrano ${allMatches.length} mecz√≥w z API`);
                    
                    // FILTRUJ tylko mecze z dzisiaj (w lokalnej strefie czasowej)
                    const todayStart = new Date();
                    todayStart.setHours(0, 0, 0, 0);
                    const todayEnd = new Date();
                    todayEnd.setHours(23, 59, 59, 999);
                    
                    const matches = allMatches.filter(match => {
                        if (!match.starting_at) return false;
                        const matchDate = new Date(match.starting_at);
                        const isToday = matchDate >= todayStart && matchDate <= todayEnd;
                        if (!isToday) {
                            console.log(`‚è≠Ô∏è POMIJAM (nie dzisiaj):`, match.name, '| Data meczu:', matchDate.toLocaleString('pl-PL'));
                        }
                        return isToday;
                    });
                    
                    console.log(`‚úÖ Sportmonks: Po filtrowaniu zosta≈Ço ${matches.length} mecz√≥w z dzisiaj (${today})`);
                    console.log(`üìÖ Zakres dzisiejszych dat: ${todayStart.toLocaleString('pl-PL')} - ${todayEnd.toLocaleString('pl-PL')}`);
                    
                    // Zlicz unikalne ligi
                    const uniqueLeagues = new Set();
                    matches.forEach(match => {
                        if (match.league?.name) {
                            uniqueLeagues.add(match.league.name);
                        }
                    });
                    
                    // Wy≈õwietl mecze w tabeli
                    const table = document.getElementById('predictions');
                    table.style.display = 'table';
                    
                    let html = `<tr>
                        <th>Mecz</th>
                        <th>Liga</th>
                        <th>Status</th>
                    </tr>`;
                    
                    // Sortuj po lidze, potem po godzinie
                    const sortedMatches = matches.sort((a, b) => {
                        const leagueA = a.league?.name || 'ZZZ';
                        const leagueB = b.league?.name || 'ZZZ';
                        if (leagueA !== leagueB) return leagueA.localeCompare(leagueB);
                        return (a.starting_at || '').localeCompare(b.starting_at || '');
                    });
                    
                    sortedMatches.forEach(match => {
                        // Parsuj nazwƒô meczu (Team1 vs Team2)
                        const matchName = match.name || 'Unknown vs Unknown';
                        const leagueName = match.league?.name || 'Unknown League';
                        
                        // Sprawd≈∫ status meczu (zako≈Ñczony, trwajƒÖcy, zaplanowany)
                        const state = match.state?.state || match.state || '';
                        const isFinished = state === 'FT' || 
                                          state === 'finished' || 
                                          state === 'complete' ||
                                          state === 'FT_PEN' ||
                                          state === 'AET';
                        const isLive = state === 'LIVE' || 
                                      state === 'HT' || 
                                      state === '1H' || 
                                      state === '2H' ||
                                      state === 'inplay';
                        
                        // Parsuj godzinƒô lub status
                        let time = '-';
                        if (isFinished) {
                            time = '‚úÖ KONIEC';
                        } else if (isLive) {
                            time = 'üî¥ LIVE';
                        } else {
                            if (match.starting_at) {
                                const date = new Date(match.starting_at);
                                time = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                            }
                        }
                        
                        html += `<tr>
                            <td><strong>${matchName}</strong></td>
                            <td>${leagueName}</td>
                            <td>${time}</td>
                        </tr>`;
                    });
                    
                    table.innerHTML = html;
                    
                    document.getElementById('info').innerHTML = `
                        ‚úÖ <strong>SPORTMONKS</strong> - Znaleziono <strong>${matches.length} mecz√≥w</strong> z <strong>${uniqueLeagues.size} lig</strong><br>
                        <small style="color:#aaa;">üìÖ Data: ${today} | Tabela przewijalna je≈õli jest wiele mecz√≥w</small>
                    `;
                    
                    // Wy≈õwietl szczeg√≥≈Çy w konsoli
                    console.log('üìã WSZYSTKIE MECZE (Sportmonks):');
                    uniqueLeagues.forEach(league => {
                        const leagueMatches = matches.filter(m => m.league?.name === league);
                        console.log(`${league}: ${leagueMatches.length} mecz√≥w`);
                    });
                    
                } else {
                    document.getElementById('info').textContent = '‚ùå Brak mecz√≥w lub problem z Sportmonks API';
                    console.error('Brak mecz√≥w w odpowiedzi:', data);
                }
                
            } catch (e) {
                console.error('üí• B≈ÅƒÑD podczas sprawdzania lig:', e);
                document.getElementById('info').textContent = 'B≈ÇƒÖd: ' + e.message;
            }
            
            document.getElementById('loader').style.display = 'none';
        }

        async function testFootyStatsAPI() {
            document.getElementById('loader').style.display = 'inline-block';
            document.getElementById('info').textContent = 'üîç Pobieranie dzisiejszych mecz√≥w z FootyStats...';
            
            try {
                // Pobierz dzisiejsze mecze z FootyStats
                const today = new Date().toISOString().split('T')[0];
                const url = `${PROXY}https://api.football-data-api.com/todays-matches?key=${FOOTYSTATS_KEY}`;
                console.log('üì° FootyStats - pobieranie mecz√≥w na:', today, url);
                
                const res = await fetch(url);
                const data = await res.json();
                
                console.log('üì¶ Odpowied≈∫ FootyStats:', data);
                
                if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    let allMatches = data.data;
                    console.log(`üì• FootyStats: Pobrano ${allMatches.length} mecz√≥w z API`);
                    
                    // DEBUG: Sprawd≈∫ strukturƒô pierwszego meczu
                    if (allMatches.length > 0) {
                        console.log('üìä STRUKTURA PIERWSZEGO MECZU (FootyStats):', allMatches[0]);
                        console.log('üìä Wszystkie klucze meczu:', Object.keys(allMatches[0]));
                    }
                    
                    // FILTRUJ tylko mecze z dzisiaj (w lokalnej strefie czasowej)
                    const todayStart = new Date();
                    todayStart.setHours(0, 0, 0, 0);
                    const todayEnd = new Date();
                    todayEnd.setHours(23, 59, 59, 999);
                    
                    const matches = allMatches.filter(match => {
                        let matchDate;
                        if (match.date_unix) {
                            matchDate = new Date(match.date_unix * 1000);
                        } else if (match.date) {
                            matchDate = new Date(match.date);
                        } else {
                            return false; // Brak daty - odrzuƒá
                        }
                        
                        const isToday = matchDate >= todayStart && matchDate <= todayEnd;
                        if (!isToday) {
                            console.log(`‚è≠Ô∏è POMIJAM (nie dzisiaj):`, match.home_name || match.home?.name, 'vs', match.away_name || match.away?.name, '| Data meczu:', matchDate.toLocaleString('pl-PL'));
                        }
                        return isToday;
                    });
                    
                    console.log(`‚úÖ FootyStats: Po filtrowaniu zosta≈Ço ${matches.length} mecz√≥w z dzisiaj (${today})`);
                    console.log(`üìÖ Zakres dzisiejszych dat: ${todayStart.toLocaleString('pl-PL')} - ${todayEnd.toLocaleString('pl-PL')}`);
                    
                    // Zlicz unikalne ligi
                    const uniqueLeagues = new Set();
                    matches.forEach(match => {
                        // Pr√≥buj r√≥≈ºne warianty nazwy ligi
                        const leagueName = match.competition?.name || 
                                          match.competition_name || 
                                          match.league?.name ||
                                          match.league_name ||
                                          match.league || 
                                          match.competition ||
                                          'Unknown';
                        uniqueLeagues.add(leagueName);
                    });
                    
                    // Wy≈õwietl mecze w tabeli
                    const table = document.getElementById('predictions');
                    table.style.display = 'table';
                    
                    let html = `<tr>
                        <th>Mecz</th>
                        <th>Liga</th>
                        <th>Status</th>
                    </tr>`;
                    
                    // Sortuj po lidze, potem po godzinie
                    const sortedMatches = matches.sort((a, b) => {
                        const leagueA = a.competition?.name || a.competition_name || a.league?.name || a.league_name || a.league || a.competition || 'ZZZ';
                        const leagueB = b.competition?.name || b.competition_name || b.league?.name || b.league_name || b.league || b.competition || 'ZZZ';
                        if (leagueA !== leagueB) return leagueA.localeCompare(leagueB);
                        return (a.date_unix || 0) - (b.date_unix || 0);
                    });
                    
                    sortedMatches.forEach(match => {
                        // Parsuj nazwƒô meczu
                        const homeName = match.home_name || match.home?.name || match.homeTeam || 'Unknown';
                        const awayName = match.away_name || match.away?.name || match.awayTeam || 'Unknown';
                        const matchName = `${homeName} vs ${awayName}`;
                        const leagueName = match.competition?.name || 
                                          match.competition_name || 
                                          match.league?.name ||
                                          match.league_name ||
                                          match.league || 
                                          match.competition ||
                                          'Unknown League';
                        
                        // Sprawd≈∫ status meczu (zako≈Ñczony, trwajƒÖcy, zaplanowany)
                        const status = match.status || match.match_status || '';
                        const isFinished = status === 'complete' || 
                                          status === 'finished' || 
                                          status === 'FT' || 
                                          match.finished === true ||
                                          (match.homeGoalCount !== undefined && match.awayGoalCount !== undefined && status !== 'live');
                        
                        // Parsuj godzinƒô lub status
                        let time = '-';
                        if (isFinished) {
                            time = '‚úÖ KONIEC';
                        } else if (status === 'live' || status === 'inplay' || status === 'LIVE') {
                            time = 'üî¥ LIVE';
                        } else {
                            if (match.date_unix) {
                                const date = new Date(match.date_unix * 1000);
                                time = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                            } else if (match.date) {
                                const date = new Date(match.date);
                                time = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                            }
                        }
                        
                        html += `<tr>
                            <td><strong>${matchName}</strong></td>
                            <td>${leagueName}</td>
                            <td>${time}</td>
                        </tr>`;
                    });
                    
                    table.innerHTML = html;
                    
                    document.getElementById('info').innerHTML = `
                        ‚úÖ <strong>FOOTYSTATS</strong> - Znaleziono <strong>${matches.length} mecz√≥w</strong> z <strong>${uniqueLeagues.size} lig</strong><br>
                        <small style="color:#aaa;">üìÖ Data: ${today} | Tabela przewijalna je≈õli jest wiele mecz√≥w</small>
                    `;
                    
                    // Wy≈õwietl szczeg√≥≈Çy w konsoli
                    console.log('üìã WSZYSTKIE MECZE (FootyStats):');
                    uniqueLeagues.forEach(league => {
                        const leagueMatches = matches.filter(m => {
                            const ln = m.competition?.name || m.competition_name || m.league?.name || m.league_name || m.league || m.competition || 'Unknown';
                            return ln === league;
                        });
                        console.log(`${league}: ${leagueMatches.length} mecz√≥w`);
                    });
                    
                } else {
                    document.getElementById('info').textContent = '‚ùå Brak mecz√≥w lub problem z FootyStats API';
                    console.error('Brak mecz√≥w w odpowiedzi:', data);
                }
                
            } catch (e) {
                console.error('üí• B≈ÅƒÑD podczas testowania FootyStats:', e);
                document.getElementById('info').textContent = 'B≈ÇƒÖd: ' + e.message;
            }
            
            document.getElementById('loader').style.display = 'none';
        }

        // Helper: op√≥≈∫nienie
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        async function getAllProbabilities(home, away, id, league) {
            try {
                console.log('  üì° Pobieranie prawdopodobie≈Ñstw z API...');
                
                // ‚úÖ W≈ÅƒÑCZONE: Tylko stabilne ≈∫r√≥d≈Ça API!
                const p1 = await getSportmonksProb(home, away); // Analiza ostatnich 10 mecz√≥w
                
                await delay(500); // Op√≥≈∫nienie przed nastƒôpnym
                
                const p2 = await getFootyStatsProb(home, away);
                const p3 = null; // API-Football - wy≈ÇƒÖczone (limit)
                const p4 = null; // TotalCorner - USUNIƒòTE (web scraping niestabilny)
                const p5 = null; // BetOnCorners - USUNIƒòTE (web scraping niestabilny)
                const p6 = null; // CornerStat - USUNIƒòTE (web scraping niestabilny)
                
                console.log(`  1Ô∏è‚É£ Sportmonks: ${p1 ? p1 + '% (analiza 10 mecz√≥w)' : 'BRAK DANYCH'}`);
                console.log(`  2Ô∏è‚É£ FootyStats: ${p2 ? p2 + '% (analiza 10 mecz√≥w) ‚úÖ W≈ÅƒÑCZONY' : 'BRAK DANYCH'}`);
                console.log(`  3Ô∏è‚É£ API-Football: WY≈ÅƒÑCZONE (limit)`);
                console.log(`  4Ô∏è‚É£ TotalCorner: USUNIƒòTE`);
                console.log(`  5Ô∏è‚É£ BetOnCorners: USUNIƒòTE`);
                console.log(`  6Ô∏è‚É£ CornerStat: USUNIƒòTE`);
                
                // Zwr√≥ƒá tylko te kt√≥re majƒÖ warto≈õƒá
                const probs = [p1, p2, p3, p4, p5, p6].filter(p => p !== null);
                
                // Zapisz szczeg√≥≈Çy do globalnej zmiennej (do wy≈õwietlenia w historii)
                window.lastMatchProbs = { p1, p2, p3, p4, p5, p6, home, away, id };
                
                return probs.length > 0 ? probs : []; // fallback je≈õli wszystko null
            } catch (e) {
                console.error('  ‚ùå B≈ÇƒÖd w getAllProbabilities:', e);
                return []; // fallback
            }
        }

        // === 1. SPORTMONKS - ANALIZA OSTATNICH 10 MECZ√ìW ===
        async function getSportmonksProb(homeTeam, awayTeam) {
            if (!SPORTMONKS_KEY || SPORTMONKS_KEY.includes('TU_WKLEJ')) return null;
            
            try {
                console.log(`    üîç Sportmonks: Analizujƒô ostatnie mecze ${homeTeam} i ${awayTeam}`);
                
                // 1. Znajd≈∫ ID dru≈ºyn
                const homeId = await getSportmonksTeamId(homeTeam);
                const awayId = await getSportmonksTeamId(awayTeam);
                
                if (!homeId || !awayId) {
                    console.warn(`    ‚ö†Ô∏è Nie znaleziono ID dru≈ºyn`);
                    return null;
                }
                
                // 2. Pobierz ostatnie 10 mecz√≥w obu dru≈ºyn
                const homeMatches = await getSportmonksTeamMatches(homeId, 10);
                const awayMatches = await getSportmonksTeamMatches(awayId, 10);
                
                // 3. Zlicz ile mecz√≥w mia≈Ço over 9.5 ro≈ºnych
                let homeOver = 0, homeTotal = 0;
                let awayOver = 0, awayTotal = 0;
                
                homeMatches.forEach(m => {
                    const total = (m.corners_home || 0) + (m.corners_away || 0);
                    if (total > 9.5) homeOver++;
                    homeTotal++;
                });
                
                awayMatches.forEach(m => {
                    const total = (m.corners_home || 0) + (m.corners_away || 0);
                    if (total > 9.5) awayOver++;
                    awayTotal++;
                });
                
                // 4. Oblicz procent
                const homePercent = homeTotal > 0 ? Math.round((homeOver / homeTotal) * 100) : 0;
                const awayPercent = awayTotal > 0 ? Math.round((awayOver / awayTotal) * 100) : 0;
                const avgPercent = Math.round((homePercent + awayPercent) / 2);
                
                console.log(`    ‚úÖ Sportmonks: ${homeTeam} ${homeOver}/${homeTotal} (${homePercent}%), ${awayTeam} ${awayOver}/${awayTotal} (${awayPercent}%) ‚Üí ≈õrednia ${avgPercent}%`);
                
                return avgPercent;
                
            } catch (e) {
                console.error('    ‚ùå Sportmonks error:', e.message);
                return null;
            }
        }
        
        // Helper: Znajd≈∫ ID dru≈ºyny w Sportmonks
        async function getSportmonksTeamId(teamName) {
            try {
                const url = `${PROXY}https://api.sportmonks.com/v3/football/teams/search/${encodeURIComponent(teamName)}?api_token=${SPORTMONKS_KEY}`;
                const res = await fetch(url);
                if (!res.ok) return null;
                const data = await res.json();
                
                if (data.data && data.data.length > 0) {
                    return data.data[0].id;
                }
                return null;
            } catch {
                return null;
            }
        }

        // Helper: Pobierz ostatnie mecze dru≈ºyny
        async function getSportmonksTeamMatches(teamId, limit = 10) {
            try {
                const url = `${PROXY}https://api.sportmonks.com/v3/football/teams/${teamId}?include=latest.statistics.type&api_token=${SPORTMONKS_KEY}`;
                const res = await fetch(url);
                if (!res.ok) return [];
                const data = await res.json();
                
                const matches = data.data?.latest || [];
                const result = [];
                
                // Pobierz ostatnie N zako≈Ñczonych mecz√≥w
                for (const match of matches) {
                    if (result.length >= limit) break;
                    if (match.state_id !== 5 && match.state_id !== 6 && match.state_id !== 7) continue; // Tylko zako≈Ñczone
                    
                    const stats = match.statistics || [];
                    const corners = stats.filter(s => s.type_id === 34); // type_id 34 = Corners
                    
                    let homeCorners = 0, awayCorners = 0;
                    
                    // Parsuj statystyki ro≈ºnych
                    corners.forEach(c => {
                        const value = parseInt(c.data?.value || 0);
                        if (c.location === 'home') homeCorners = value;
                        if (c.location === 'away') awayCorners = value;
                    });
                    
                    result.push({
                        corners_home: homeCorners,
                        corners_away: awayCorners,
                        team_id: teamId,
                        match_id: match.id
                    });
                }
                
                return result;
            } catch (e) {
                console.error('    ‚ùå B≈ÇƒÖd pobierania mecz√≥w:', e.message);
                return [];
            }
        }
        
        // Helper: Pobierz ≈õredniƒÖ ro≈ºnych SAMEJ dru≈ºyny z ostatnich 5 mecz√≥w
        async function getSportmonksTeamOwnCorners(teamId, limit = 5) {
            try {
                const matches = await getSportmonksTeamMatches(teamId, limit);
                const ownCorners = [];
                
                // TODO: Trzeba wiedzieƒá czy dru≈ºyna gra≈Ça jako host czy guest
                // Na razie zwracam ≈õredniƒÖ z obu stron
                matches.forEach(m => {
                    const avg = (m.corners_home + m.corners_away) / 2;
                    ownCorners.push(avg);
                });
                
                if (ownCorners.length === 0) return null;
                
                const avgOwn = ownCorners.reduce((a, b) => a + b, 0) / ownCorners.length;
                return Math.round(avgOwn * 10) / 10; // ZaokrƒÖglij do 1 miejsca po przecinku
                
            } catch {
                return null;
            }
        }

        // === 2. FOOTYSTATS - ANALIZA OSTATNICH 10 MECZ√ìW ===
        // UWAGA: FootyStats u≈ºywa INNYCH nazw p√≥l ni≈º Sportmonks!
        // - Sportmonks: participant_id, statistics[].type_id
        // - FootyStats: total_corners_count, homeCorners, awayCorners
        // Ka≈ºde API ma swojƒÖ strukturƒô - musimy obs≈Çu≈ºyƒá oba!
        async function getFootyStatsProb(home, away) {
            try {
                console.log(`    üîç FootyStats: Analizujƒô ${home} i ${away}`);
                
                // 1. Pobierz ID dru≈ºyn przez wyszukiwanie
                const homeId = await getFootyStatsTeamId(home);
                const awayId = await getFootyStatsTeamId(away);
                
                if (!homeId || !awayId) {
                    console.warn(`    ‚ö†Ô∏è FootyStats: Nie znaleziono ID dru≈ºyn`);
                    return null;
                }
                
                console.log(`    üìå IDs: ${home} = ${homeId}, ${away} = ${awayId}`);
                
                // 2. Pobierz ostatnie 10 mecz√≥w obu dru≈ºyn
                const homeMatches = await getFootyStatsTeamMatches(homeId, 10);
                const awayMatches = await getFootyStatsTeamMatches(awayId, 10);
                
                // 3. Zlicz ile mecz√≥w mia≈Ço over 9.5 ro≈ºnych
                let homeOver = 0, homeTotal = 0;
                let awayOver = 0, awayTotal = 0;
                
                homeMatches.forEach(m => {
                    // FootyStats mo≈ºe u≈ºywaƒá r√≥≈ºnych nazw dla ro≈ºnych
                    const total = m.total_corners_count || 
                                  m.totalCorners || 
                                  m.corners_total ||
                                  m.total_corners ||
                                  (m.homeCorners && m.awayCorners ? m.homeCorners + m.awayCorners : null) ||
                                  (m.home_corners && m.away_corners ? m.home_corners + m.away_corners : null) ||
                                  0;
                    
                    console.log(`      üìä Mecz ${homeTotal + 1}: ${total} ro≈ºnych`);
                    if (total > 9.5) homeOver++;
                    homeTotal++;
                });
                
                awayMatches.forEach(m => {
                    const total = m.total_corners_count || 
                                  m.totalCorners || 
                                  m.corners_total ||
                                  m.total_corners ||
                                  (m.homeCorners && m.awayCorners ? m.homeCorners + m.awayCorners : null) ||
                                  (m.home_corners && m.away_corners ? m.home_corners + m.away_corners : null) ||
                                  0;
                    
                    console.log(`      üìä Mecz ${awayTotal + 1}: ${total} ro≈ºnych`);
                    if (total > 9.5) awayOver++;
                    awayTotal++;
                });
                
                // 4. Oblicz procent
                const homePercent = homeTotal > 0 ? Math.round((homeOver / homeTotal) * 100) : 0;
                const awayPercent = awayTotal > 0 ? Math.round((awayOver / awayTotal) * 100) : 0;
                const avgPercent = Math.round((homePercent + awayPercent) / 2);
                
                console.log(`    ‚úÖ FootyStats: ${home} ${homeOver}/${homeTotal} (${homePercent}%), ${away} ${awayOver}/${awayTotal} (${awayPercent}%) ‚Üí ≈õrednia ${avgPercent}%`);
                
                return avgPercent;
                
            } catch (e) {
                console.error('    ‚ùå FootyStats error:', e.message);
                return null;
            }
        }
        
        // Helper: Znajd≈∫ ID dru≈ºyny w FootyStats
        async function getFootyStatsTeamId(teamName) {
            try {
                // FootyStats u≈ºywa nazwy dru≈ºyny jako identyfikatora w URL
                const cleanName = teamName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                return cleanName; // FootyStats u≈ºywa nazw, nie numerycznych ID
            } catch {
                return null;
            }
        }
        
        // Helper: Pobierz ostatnie mecze dru≈ºyny z FootyStats
        async function getFootyStatsTeamMatches(teamSlug, limit = 10) {
            try {
                // PROXY jest KONIECZNY dla FootyStats (CORS)!
                // POPRAWNY URL: api.football-data-api.com (NIE api.footystats.org)
                const url = `${PROXY}https://api.football-data-api.com/team-matches?key=${FOOTYSTATS_KEY}&team=${teamSlug}`;
                console.log(`    üì° FootyStats URL: ${url}`);
                
                const res = await fetch(url);
                if (!res.ok) {
                    console.warn(`    ‚ö†Ô∏è FootyStats: b≈ÇƒÖd ${res.status}`);
                    return [];
                }
                
                const data = await res.json();
                console.log(`    üì¶ FootyStats odpowied≈∫ dla ${teamSlug}:`, data);
                
                // FootyStats mo≈ºe zwracaƒá r√≥≈ºne struktury danych
                // Pr√≥bujemy kilka wariant√≥w
                let matches = [];
                if (data.data && Array.isArray(data.data)) {
                    matches = data.data;
                } else if (data.matches && Array.isArray(data.matches)) {
                    matches = data.matches;
                } else if (Array.isArray(data)) {
                    matches = data;
                }
                
                // Filtruj tylko zako≈Ñczone mecze
                const finishedMatches = matches.filter(m => 
                    m.status === 'complete' || 
                    m.status === 'finished' || 
                    m.finished === true ||
                    (m.homeGoalCount !== undefined && m.awayGoalCount !== undefined)
                );
                
                console.log(`    ‚úÖ Znaleziono ${finishedMatches.length} zako≈Ñczonych mecz√≥w dla ${teamSlug}`);
                return finishedMatches.slice(0, limit);
                
            } catch (e) {
                console.error(`    ‚ùå B≈ÇƒÖd pobierania mecz√≥w z FootyStats:`, e.message);
                return [];
            }
        }

        // === 3. API-FOOTBALL ===
        async function getApiFootballProb(id) {
            try {
                const url = `${PROXY}https://v3.football.api-sports.io/fixtures/statistics?fixture=${id}`;
                const res = await fetch(url, { headers: { 'x-apisports-key': API_FOOTBALL_KEYS[currentKeyIndex] } });
                if (!res.ok) return 58;
                const data = await res.json();
                if (!data.response.length) return 58;
                const hc = data.response[0].statistics.find(s => s.type === 'Corner Kicks')?.value || 0;
                const ac = data.response[1].statistics.find(s => s.type === 'Corner Kicks')?.value || 0;
                const avg = (hc + ac) * 2.2;
                return Math.min(95, 45 + (avg - 8) * 12);
            } catch { return 58; }
        }

        // === WEB SCRAPING USUNIƒòTY ===
        // TotalCorner, BetOnCorners, CornerStat - web scraping niestabilny
        // Cloudflare blokuje, parsowanie HTML zawodne, 403/404 b≈Çƒôdy

        function displayResults() {
            const table = document.getElementById('predictions');
            table.style.display = 'table';
            let html = `<tr><th>Mecz</th><th>Liga</th><th>≈örednia %</th><th>ZGODNO≈öƒÜ</th><th>Status</th></tr>`;

            if (predictions.length === 0) {
                html += `<tr><td colspan="5">Brak mecz√≥w spe≈ÇniajƒÖcych kryteria (zgdn.‚â•30%, ≈õr.‚â•55%).</td></tr>`;
            } else {
                predictions.forEach(p => {
                    const cls = p.agree >= 80 ? 'high' : p.agree >= 70 ? 'medium' : '';
                    html += `<tr>
                        <td><strong>${p.match}</strong><br>
                            <span class="expand-btn" data-match-id="${p.id}">üìä Poka≈º historiƒô ro≈ºnych</span>
                        </td>
                        <td>${p.league}</td>
                        <td>${p.avgProb}%</td>
                        <td class="${cls}">${p.agree}%</td>
                        <td class="pending" id="s-${p.id}">${p.status}</td>
                    </tr>`;
                });
            }
            table.innerHTML = html;
            
            // Dodaj event listenery do przycisk√≥w (zamiast inline onclick)
            document.querySelectorAll('.expand-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const matchId = this.getAttribute('data-match-id');
                    toggleDetails(matchId);
                });
            });
            
            // Poprawna odmiana s≈Çowa "typ"
            let typText;
            if (predictions.length === 1) {
                typText = 'typ';
            } else if (predictions.length >= 2 && predictions.length <= 4) {
                typText = 'typy';
            } else {
                typText = 'typ√≥w';
            }
            
            document.getElementById('info').innerHTML = `Znaleziono <strong>${predictions.length}</strong> ${typText}!<br><small style="color:#afa;">‚úÖ Aktywne: Sportmonks + FootyStats (analiza ostatnich 10 mecz√≥w ka≈ºdy - prawdziwe dane!)</small>`;
            updateStats();
        }

        async function verifyAll() {
            hits = 0; total = 0;
            for (let p of predictions) {
                const el = document.getElementById(`s-${p.id}`);
                if (!el) continue;
                try {
                    const res = await fetch(`${PROXY}https://v3.football.api-sports.io/fixtures?id=${p.id}`, {
                        headers: { 'x-apisports-key': API_FOOTBALL_KEYS[currentKeyIndex] }
                    });
                    const data = await res.json();
                    const fix = data.response[0];
                    if (fix.fixture.status.short === 'FT') {
                        const statsRes = await fetch(`${PROXY}https://v3.football.api-sports.io/fixtures/statistics?fixture=${p.id}`, {
                            headers: { 'x-apisports-key': API_FOOTBALL_KEYS[currentKeyIndex] }
                        });
                        const stats = await statsRes.json();
                        const hc = stats.response[0].statistics.find(s => s.type === 'Corner Kicks')?.value || 0;
                        const ac = stats.response[1].statistics.find(s => s.type === 'Corner Kicks')?.value || 0;
                        const totalC = hc + ac;
                        const isOver = totalC > 9.5;
                        el.textContent = isOver ? `OVER (${totalC})` : `UNDER (${totalC})`;
                        el.parentElement.className = isOver ? 'hit' : 'miss';
                        if (isOver) hits++;
                        total++;
                    } else {
                        el.textContent = 'W trakcie';
                    }
                } catch { }
            }
            updateStats();
        }

        function updateStats() {
            const hitRate = total > 0 ? Math.round((hits / total) * 100) : 0;
            const roi = total > 0 ? ((hits * 1.85) - (total - hits)).toFixed(2) : 0;
            document.getElementById('stats').innerHTML = `
                <strong>Hit Rate: ${hitRate}%</strong> | 
                <strong>ROI: ${roi > 0 ? '+' : ''}${roi} z≈Ç</strong> (kurs 1.85)
            `;
            updateChart();
        }

        function updateChart() {
            const ctx = document.getElementById('chart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            chartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Trafienia', 'Pud≈Ça'],
                    datasets: [{
                        data: [hits, total - hits],
                        backgroundColor: ['#4CAF50', '#f44336'],
                        borderWidth: 3,
                        borderColor: '#fff'
                    }]
                },
                options: { responsive: true, plugins: { legend: { position: 'bottom', labels: { color: '#fff' } } } }
            });
        }

        // Auto co 30 min
        setInterval(verifyAll, 1800000);
    </script>
</body>
</html>