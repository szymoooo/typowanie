<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corner Predictor - Over 9.5 Analiza</title>
    <style>
        /* Kolory Arsenal: czerwony #EF0107, biaÅ‚y #FFFFFF, granatowy #023474 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            padding: 30px 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 20px rgba(239, 1, 7, 0.3);
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            color: #FFFFFF;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }

        header .subtitle {
            color: #FFFFFF;
            font-size: 1.1em;
            opacity: 0.95;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: #EF0107;
            color: #FFFFFF;
        }

        .btn-primary:hover {
            background: #cc0000;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(239, 1, 7, 0.4);
        }

        .btn-secondary {
            background: #023474;
            color: #FFFFFF;
        }

        .btn-secondary:hover {
            background: #011f4a;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(2, 52, 116, 0.4);
        }

        .btn-white {
            background: #FFFFFF;
            color: #EF0107;
        }

        .btn-white:hover {
            background: #f5f5f5;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.3);
        }

        /* Cards */
        .card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(239, 1, 7, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .card-header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 15px 20px;
            border-radius: 10px;
            margin: -25px -25px 20px -25px;
            font-size: 1.3em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header.blue {
            background: linear-gradient(135deg, #023474 0%, #011f4a 100%);
        }

        /* Match List */
        .match-item {
            background: rgba(255, 255, 255, 0.03);
            border-left: 4px solid #EF0107;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .match-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-left-color: #023474;
            transform: translateX(5px);
        }

        .match-time {
            color: #FFFFFF;
            font-weight: bold;
            display: inline-block;
            width: 70px;
        }

        .match-teams {
            color: #FFFFFF;
            font-size: 1.1em;
            margin: 5px 0;
        }

        .match-league {
            color: #EF0107;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(2, 52, 116, 0.5);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #EF0107;
            margin: 10px 0;
        }

        .stat-label {
            color: #FFFFFF;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #EF0107;
            font-size: 1.2em;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #EF0107;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Kontener dla komunikatÃ³w */
        #messages-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .message-item {
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 1, 7, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 1, 7, 0);
            }
        }

        /* League Section - Two Column Layout */
        #matches-container {
            margin-top: 20px;
        }

        .league-section {
            margin-bottom: 0;
            break-inside: avoid;
        }

        .league-title {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        /* Responsive - jedna kolumna na maÅ‚ych ekranach */
        @media (max-width: 768px) {
            #matches-container {
                grid-template-columns: 1fr;
            }
            
            #analysis-content > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
        }

        /* Analysis Window */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 50px auto;
            padding: 30px;
            border: 3px solid #EF0107;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(239, 1, 7, 0.5);
        }

        /* Blokada przewijania strony w tle gdy modal otwarty */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .close {
            color: #FFFFFF;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #EF0107;
        }

        /* Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th {
            background: #023474;
            color: #FFFFFF;
            padding: 15px;
            text-align: left;
            border-bottom: 3px solid #EF0107;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        tr:hover {
            background: rgba(239, 1, 7, 0.1);
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-success {
            background: #4CAF50;
            color: #FFFFFF;
        }

        .badge-danger {
            background: #EF0107;
            color: #FFFFFF;
        }

        .badge-warning {
            background: #FF9800;
            color: #FFFFFF;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>âš½ Corner Predictor</h1>
            <p class="subtitle">Analiza Over 9.5 RzutÃ³w RoÅ¼nych</p>
        </header>

        <div class="button-group">
            <button class="btn btn-primary" onclick="fetchMatches()">ðŸ”„ Pobierz Mecze</button>
            <button class="btn btn-secondary" onclick="analyzeOver95()">ðŸ“Š Analizuj Over 9.5</button>
            <button class="btn btn-secondary" onclick="analyzeCards()" style="background: #FFA500; color: #000;">ðŸŸ¨ Analizuj Kartki</button>
            <button class="btn btn-white" onclick="showHistory()">ðŸ“œ Historia</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Pobieranie danych...</p>
        </div>

        <div id="stats" class="stats-grid" style="display: none;">
            <div class="stat-card">
                <div class="stat-label">Dzisiejsze Mecze</div>
                <div class="stat-value" id="total-matches">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Ligi</div>
                <div class="stat-value" id="total-leagues">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">KwalifikujÄ…ce siÄ™</div>
                <div class="stat-value" id="qualified-matches">0</div>
            </div>
        </div>

        <div id="matches-container"></div>
    </div>

    <!-- Modal dla analizy -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('analysisModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">ðŸ“Š Analiza Over 9.5</h2>
            <div id="analysis-content"></div>
        </div>
    </div>

    <!-- Modal dla historii -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('historyModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">ðŸ“œ Historia MeczÃ³w</h2>
            <div id="history-content"></div>
        </div>
    </div>

    <!-- Modal dla analizy kartek -->
    <div id="cardsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('cardsModal')">&times;</span>
            <h2 style="color: #FFA500; margin-bottom: 20px;">ðŸŸ¨ Analiza Kartek (Over 3.5)</h2>
            <div id="cards-content"></div>
        </div>
    </div>

    <!-- Modal dla szczegÃ³Å‚Ã³w meczu -->
    <div id="matchDetailsModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
            <span class="close" onclick="closeModal('matchDetailsModal')">&times;</span>
            <div id="match-details-content"></div>
        </div>
    </div>


    <footer>
        <p>Corner Predictor - System analizy rzutÃ³w roÅ¼nych Over 9.5</p>
        <p id="app-version-text" style="font-size: 0.9em; margin-top: 10px;">Powered by Football Data API v1.02</p>
    </footer>

    <script>
        // API Configuration
        const API_KEY = '8cdad7757b702fae3b792c0b3328017ee33cc17594b18ea8a2717cdc53162325';
        
        // API-Football Configuration
        const API_FOOTBALL_KEY = '9cce2e1224d9dd0da28def93ce05f2e5';
        const API_FOOTBALL_BASE_URL = 'https://v3.football.api-sports.io';
        const USE_API_FOOTBALL_REFEREES = true; // WÅ‚Ä…cz/wyÅ‚Ä…cz pobieranie danych o sÄ™dziach z API-Football
        
        // Konfiguracja: uÅ¼yj lokalnego proxy servera (uruchom: python3 proxy_server.py)
        const BASE_URL = 'http://localhost:8080/api';
        const USE_PROXY = false; // false = uÅ¼ywa lokalnego proxy, true = uÅ¼ywa zewnÄ™trznych proxy (czÄ™sto 403)

        const ADVANCED_FILTER_SETTINGS = {
            enabled: true,
            minConsensus: 2,
            minEdge: 0.05, // minimalna przewaga nad progiem break-even (np. 5 punktÃ³w procentowych)
            minOdds: 1.75,
            minPredictedProbability: 0.6,
            minLeagueSamples: 12,
            minLeagueWinRate: 0.6,
            logRejected: true
        };
        
        // Debug: sprawdÅº konfiguracjÄ™ (wyÅ‚Ä…czone w produkcji)
        // console.log('ðŸ”§ Konfiguracja API:', { BASE_URL, USE_PROXY, proxy: getProxy() });
        
        // Proxy dla CORS - wiÄ™cej opcji na wypadek blokad
        const PROXY_SERVICES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://thingproxy.freeboard.io/fetch/',
        ];
        let currentProxyIndex = 0;
        
        function getProxy() {
            if (!USE_PROXY) return ''; // Brak proxy jeÅ›li uÅ¼ywamy lokalnego serwera
            return PROXY_SERVICES[currentProxyIndex];
        }

        // Global state
        let matchesData = [];
        let leaguesData = {};
        let teamsData = {};
        let analyzedMatches = [];
        let allAnalyzedMatches = []; // Wszystkie przeanalizowane mecze (zarÃ³wno zakwalifikowane jak i nie)
        let advancedFiltersSummary = null;
        let advancedFiltersRejected = [];
        let lastAnalysisHash = null; // Hash meczÃ³w z ostatniej analizy
        let currentModelFilter = 'all';
        let historyModelFilter = 'all';

        const APP_VERSION_STORAGE_KEY = 'cornerAppVersion';
        const PROFIT_REPORT_LAST_EXPORT_KEY = 'lastProfitReportExportDate';
        let appVersion = localStorage.getItem(APP_VERSION_STORAGE_KEY);
        if (!appVersion || parseFloat(appVersion) < 1.02) {
            appVersion = '1.02';
            localStorage.setItem(APP_VERSION_STORAGE_KEY, appVersion);
        }

        function updateAppVersionDisplay() {
            const el = document.getElementById('app-version-text');
            if (el) {
                el.textContent = `Powered by Football Data API v${appVersion}`;
            }
        }

        window.bumpAppVersion = function(step = 0.01) {
            const numeric = parseFloat(appVersion);
            if (isNaN(numeric)) {
                
                appVersion = '1.00';
            } else {
                appVersion = (numeric + step).toFixed(2);
            }
            localStorage.setItem(APP_VERSION_STORAGE_KEY, appVersion);
            updateAppVersionDisplay();
            // 
            return appVersion;
        };

        window.setAppVersion = function(value) {
            if (!value) return;
            const sanitized = parseFloat(value);
            if (isNaN(sanitized)) {
                // 
                return appVersion;
            }
            appVersion = sanitized.toFixed(2);
            localStorage.setItem(APP_VERSION_STORAGE_KEY, appVersion);
            updateAppVersionDisplay();
            // 
            return appVersion;
        };

        function setModelFilter(value) {
            currentModelFilter = value;
            displayAnalysisResults();
        }

        function setHistoryModelFilter(value) {
            historyModelFilter = value;
            showHistory();
        }

        function pickKeys(source, keys) {
            const result = {};
            keys.forEach(key => {
                if (source[key] !== undefined) {
                    result[key] = source[key];
                }
            });
            return result;
        }

        function sanitizeHistoryEntry(entry) {
            if (!entry || typeof entry !== 'object') return entry;
            const sanitized = { ...entry };

            if (sanitized.match) {
                const match = sanitized.match;
                sanitized.match = pickKeys(match, [
                    'match_id',
                    'id',
                    'status',
                    'date_unix',
                    'home_name',
                    'away_name',
                    'competition_id',
                    'league_name',
                    'country',
                    'totalCornerCount',
                    'team_a_corners_0_10_min',
                    'team_b_corners_0_10_min',
                    'odds_over95',
                    'odds_corners_over_95',
                    'pre_odds_corner_over_9_5',
                    'odds_corner_over_9_5'
                ]);
                if (!sanitized.match.match_id) {
                    sanitized.match.match_id = match.match_id || sanitized.api_match_id || sanitized.match_id || null;
                }
                if (!sanitized.match.date_unix) {
                    sanitized.match.date_unix = match.date_unix || sanitized.date_unix || null;
                }
                if (match.team_a_corners_0_10_min !== undefined && match.team_b_corners_0_10_min !== undefined) {
                    sanitized.match.corners_0_10 = {
                        home: match.team_a_corners_0_10_min,
                        away: match.team_b_corners_0_10_min
                    };
                }
            }

            if (sanitized.analysis) {
                const analysis = sanitized.analysis;
                const allowedAnalysisKeys = [
                    'summary',
                    'primary_summary',
                    'qualified',
                    'qualified_models',
                    'qualified_model',
                    'model_results',
                    'score',
                    'percent_sum',
                    'home_percent',
                    'away_percent',
                    'home_stats',
                    'away_stats',
                    'categories',
                    'odds_over95',
                    'predicted_avg_corners',
                    'average_corners',
                    'model7_details',
                    'models_details',
                    'requirements',
                    'details',
                    'notes'
                ];
                sanitized.analysis = pickKeys(analysis, allowedAnalysisKeys);
                if (analysis.categories && Array.isArray(analysis.categories)) {
                    sanitized.analysis.categories = [...analysis.categories];
                }
                if (analysis.model_results) {
                    sanitized.analysis.model_results = JSON.parse(JSON.stringify(analysis.model_results));
                }
                if (analysis.home_stats) {
                    sanitized.analysis.home_stats = JSON.parse(JSON.stringify(analysis.home_stats));
                }
                if (analysis.away_stats) {
                    sanitized.analysis.away_stats = JSON.parse(JSON.stringify(analysis.away_stats));
                }
            }

            if (sanitized.raw_match) {
                delete sanitized.raw_match;
            }

            if (sanitized.details || sanitized.full_analysis) {
                delete sanitized.details;
                delete sanitized.full_analysis;
            }

            return sanitized;
        }

        function sanitizeHistoryForStorage(history) {
            if (!Array.isArray(history)) return [];
            return history.map(entry => sanitizeHistoryEntry(entry));
        }

        function saveHistoryWithQuotaProtection(history) {
            if (!Array.isArray(history)) {
                return { saved: false, history: [], removed: 0 };
            }

            let sanitizedHistory = sanitizeHistoryForStorage(history);
            let removed = 0;

            while (sanitizedHistory.length >= 0) {
                try {
                    localStorage.setItem('over95_history', JSON.stringify(sanitizedHistory));
                    return { saved: true, history: sanitizedHistory, removed };
                } catch (error) {
                    const quotaExceeded = error && (error.name === 'QuotaExceededError' || error.code === 22);
                    if (!quotaExceeded || sanitizedHistory.length === 0) {
                        console.error('Nie udaÅ‚o siÄ™ zapisaÄ‡ historii w localStorage:', error);
                        return { saved: false, history: sanitizedHistory, removed };
                    }
                    sanitizedHistory = sanitizedHistory.slice(1);
                    removed += 1;
                }
            }

            return { saved: false, history: sanitizedHistory, removed };
        }

        function formatCurrencyPLN(value) {
            if (!Number.isFinite(value)) return 'â€”';
            return value.toLocaleString('pl-PL', { style: 'currency', currency: 'PLN' });
        }

        function getEntryDateStr(entry) {
            if (!entry) return null;
            if (entry.date_unix) {
                try {
                    return new Date(entry.date_unix * 1000).toISOString().split('T')[0];
                } catch (e) {
                    /* ignore */
                }
            }
            if (entry.match && entry.match.date_unix) {
                try {
                    return new Date(entry.match.date_unix * 1000).toISOString().split('T')[0];
                } catch (e) {
                    /* ignore */
                }
            }
            if (entry.saved_date) {
                return entry.saved_date;
            }
            return null;
        }

        function getEntryOdds(entry) {
            if (!entry) return null;
            const fromTop = entry.odds_over95;
            const fromAnalysis = entry.analysis && entry.analysis.odds_over95;
            const fromMatch = entry.match && (
                entry.match.odds_over95 ??
                entry.match.odds_corners_over_95 ??
                entry.match.pre_odds_corner_over_9_5 ??
                entry.match.odds_corner_over_9_5
            );
            const candidate = fromTop ?? fromAnalysis ?? fromMatch;
            if (candidate === null || candidate === undefined) return null;
            const numeric = parseFloat(candidate);
            return Number.isFinite(numeric) && numeric > 1 ? numeric : null;
        }

        function getEntryResult(entry) {
            if (!entry) return null;
            const result = (entry.result || entry.status || '').toString().toLowerCase();
            if (result === 'won' || result === 'lost') return result;
            return null;
        }

        function normalizeLeagueKey(value) {
            if (!value) return 'Nieznana liga';
            if (typeof value !== 'string') {
                try {
                    return String(value);
                } catch (e) {
                    return 'Nieznana liga';
                }
            }
            const trimmed = value.replace(/\s+/g, ' ').trim();
            return trimmed.length > 0 ? trimmed : 'Nieznana liga';
        }

        function calculateHistoricalLeaguePerformance() {
            try {
                const savedHistory = localStorage.getItem('over95_history');
                if (!savedHistory) return {};
                const history = JSON.parse(savedHistory);
                if (!Array.isArray(history) || history.length === 0) return {};

                const stats = {};
                history.forEach(entry => {
                    const result = getEntryResult(entry);
                    if (!result) return;

                    const leagueRaw =
                        entry.league ||
                        entry.league_name ||
                        entry.match?.league ||
                        entry.match?.league_name ||
                        entry.match?.competition_name ||
                        'Nieznana liga';

                    const leagueKey = normalizeLeagueKey(leagueRaw);
                    if (!stats[leagueKey]) {
                        stats[leagueKey] = { total: 0, won: 0, lost: 0 };
                    }
                    stats[leagueKey].total += 1;
                    if (result === 'won') stats[leagueKey].won += 1;
                    if (result === 'lost') stats[leagueKey].lost += 1;
                });

                Object.keys(stats).forEach(key => {
                    const league = stats[key];
                    league.winRate = league.total > 0 ? league.won / league.total : 0;
                });

                return stats;
            } catch (error) {
                
                return {};
            }
        }

        function calculatePredictedProbability(analysis) {
            if (!analysis) return null;
            const homePercentRaw = analysis.home_percent ?? analysis.homePercent;
            const awayPercentRaw = analysis.away_percent ?? analysis.awayPercent;
            const homePercent = Number(homePercentRaw);
            const awayPercent = Number(awayPercentRaw);
            
            if (!Number.isFinite(homePercent) || !Number.isFinite(awayPercent)) {
                return null;
            }
            
            const avgProbability = (homePercent + awayPercent) / 200; // Å›rednia z dwÃ³ch procentÃ³w
            const minProbability = Math.min(homePercent, awayPercent) / 100;
            const conservative = Math.min(avgProbability, minProbability + 0.05);
            return Math.max(0, Math.min(1, conservative));
        }

        function applyAdvancedFilters(matches, {
            leagueStats = {},
            settings = ADVANCED_FILTER_SETTINGS
        } = {}) {
            if (!settings || !settings.enabled || !Array.isArray(matches)) {
                return {
                    filtered: matches || [],
                    rejected: [],
                    summary: null
                };
            }

            const filtered = [];
            const rejected = [];

            matches.forEach(item => {
                const reasons = [];
                const qualifiedModels = (item.qualified_models && item.qualified_models.length)
                    ? item.qualified_models
                    : determineQualifiedModels(item.analysis?.model_results || {});
                const consensusCount = qualifiedModels.length;
                const analysis = item.analysis || {};
                const odds = item.odds_over95 ?? analysis.odds_over95 ?? null;
                const predictedProbability = calculatePredictedProbability(analysis);
                // Obliczanie edge wyÅ‚Ä…czone - kursy nie sÄ… adekwatne do bukmachera uÅ¼ytkownika
                const effectiveOdds = null; // WyÅ‚Ä…czone
                const breakEven = null; // WyÅ‚Ä…czone
                const edge = null; // WyÅ‚Ä…czone - nie moÅ¼na obliczyÄ‡ bez kursÃ³w
                const leagueKey = normalizeLeagueKey(item.league || item.league_name || '');
                const leagueStat = leagueStats[leagueKey];

                if (settings.minConsensus && consensusCount < settings.minConsensus) {
                    reasons.push(`Brak konsensusu modeli (tylko ${consensusCount})`);
                }

                // Sprawdzanie kursÃ³w wyÅ‚Ä…czone - kursy nie sÄ… adekwatne do bukmachera uÅ¼ytkownika
                // if (!odds || odds < settings.minOdds) {
                //     reasons.push(`Kurs ${odds ? odds.toFixed(2) : 'n/d'} < ${settings.minOdds}`);
                // }

                if (predictedProbability === null || predictedProbability < settings.minPredictedProbability) {
                    const probText = predictedProbability === null ? 'brak' : `${(predictedProbability * 100).toFixed(1)}%`;
                    reasons.push(`Prognoza ${probText} < ${(settings.minPredictedProbability * 100).toFixed(0)}%`);
                }

                // Sprawdzanie przewagi (edge) wyÅ‚Ä…czone - wymaga kursÃ³w, ktÃ³re nie sÄ… adekwatne
                // if (edge === null || edge < settings.minEdge) {
                //     const edgeText = edge === null ? 'brak' : `${(edge * 100).toFixed(1)}%`;
                //     reasons.push(`Przewaga ${edgeText} < ${(settings.minEdge * 100).toFixed(1)}%`);
                // }

                if (leagueStat && leagueStat.total >= settings.minLeagueSamples && leagueStat.winRate < settings.minLeagueWinRate) {
                    reasons.push(`Liga ${leagueKey}: ${(leagueStat.winRate * 100).toFixed(1)}% sukcesÃ³w z ${leagueStat.total} meczÃ³w`);
                }

                item.advanced_metrics = {
                    consensusCount,
                    predictedProbability,
                    breakEven,
                    edge,
                    leagueKey,
                    leagueWinRate: leagueStat ? leagueStat.winRate : null,
                    leagueSamples: leagueStat ? leagueStat.total : 0
                };

                if (reasons.length === 0) {
                    filtered.push(item);
                } else {
                    item.advanced_metrics.reasons = reasons;
                    rejected.push(item);
                }
            });

            const summary = {
                total: matches.length,
                kept: filtered.length,
                rejected: rejected.length,
                settings: { ...settings }
            };

            if (settings.logRejected && rejected.length > 0) {
                console.groupCollapsed(`ðŸª¤ Zaawansowane filtry: odrzucono ${rejected.length}/${matches.length} meczÃ³w`);
                rejected.forEach(item => {
                    console.log(`${item.home_name} vs ${item.away_name} (${item.league})`, item.advanced_metrics);
                });
                console.groupEnd();
            }

            return { filtered, rejected, summary };
        }

        function simulateAdvancedFilterForDate(dateStr, {
            stake = 5,
            customSettings = {},
            logRejected = true
        } = {}) {
            try {
                if (!dateStr) {
                    
                    return null;
                }
                const savedHistory = localStorage.getItem('over95_history');
                if (!savedHistory) {
                    console.warn('Brak historii meczÃ³w (over95_history)');
                    return null;
                }
                const history = JSON.parse(savedHistory);
                if (!Array.isArray(history) || history.length === 0) {
                    
                    return null;
                }
                const leagueStats = calculateHistoricalLeaguePerformance();
                const settings = { ...ADVANCED_FILTER_SETTINGS, ...customSettings };
                const entriesForDate = history.filter(entry => getEntryDateStr(entry) === dateStr);
                if (entriesForDate.length === 0) {
                    
                    return null;
                }

                const matches = entriesForDate.map(entry => {
                    const item = {
                        analysis: entry.analysis || {},
                        qualified_models: entry.qualified_models || (entry.qualified_model ? [entry.qualified_model] : []),
                        league: entry.league || entry.league_name || entry.match?.league_name || '',
                        league_name: entry.league_name || entry.league || '',
                        home_name: entry.home_name || entry.match?.home_name || 'N/A',
                        away_name: entry.away_name || entry.match?.away_name || 'N/A',
                        match: entry.match || {},
                        odds_over95: getEntryOdds(entry),
                        history_entry: entry
                    };
                    return item;
                });

                const { filtered, rejected, summary } = applyAdvancedFilters(matches, {
                    leagueStats,
                    settings: { ...settings, logRejected }
                });

                const report = {
                    date: dateStr,
                    initial: matches.length,
                    kept: filtered.length,
                    rejected: rejected.length,
                    settings,
                    filteredMatches: filtered.map(item => ({
                        home: item.home_name,
                        away: item.away_name,
                        league: item.league || item.league_name,
                        odds: item.odds_over95,
                        advanced_metrics: item.advanced_metrics
                    })),
                    rejectedMatches: rejected.map(item => ({
                        home: item.home_name,
                        away: item.away_name,
                        league: item.league || item.league_name,
                        odds: item.odds_over95,
                        reasons: item.advanced_metrics?.reasons || []
                    }))
                };

                console.group(`ðŸ“Š Symulacja filtrÃ³w zaawansowanych - ${dateStr}`);
                
                
                
                if (filtered.length > 0) {
                    
                    filtered.forEach(item => {
                        const odds = item.odds_over95 ? item.odds_over95.toFixed(2) : 'brak';
                        console.log(` â€¢ ${item.home_name} vs ${item.away_name} (${item.league_name || item.league}) - kurs ${odds}`, item.advanced_metrics);
                    });
                }
                if (rejected.length > 0) {
                    
                    rejected.forEach(item => {
                        const odds = item.odds_over95 ? item.odds_over95.toFixed(2) : 'brak';
                        console.log(` â€¢ ${item.home_name} vs ${item.away_name} (${item.league_name || item.league}) - kurs ${odds}`, item.advanced_metrics?.reasons || []);
                    });
                }
                console.groupEnd();
                return report;
            } catch (error) {
                console.error('BÅ‚Ä…d podczas symulacji filtrÃ³w:', error);
                return null;
            }
        }

        function calculateProfitForDate(dateStr, stake = 5) {
            try {
                const savedHistory = localStorage.getItem('over95_history');
                if (!savedHistory) return null;
                const history = JSON.parse(savedHistory);
                if (!Array.isArray(history) || history.length === 0) return null;

                const matches = [];
                let totalStake = 0;
                let totalReturnGross = 0;
                let totalReturnNet = 0;
                let wins = 0;
                let losses = 0;
                let skipped = 0;

                history.forEach(entry => {
                    const entryDate = getEntryDateStr(entry);
                    if (entryDate !== dateStr) return;

                    const result = getEntryResult(entry);
                    if (!result) return;

                    const odds = getEntryOdds(entry);
                    if (odds === null) {
                        skipped += 1;
                        matches.push({
                            home: entry.home_name,
                            away: entry.away_name,
                            league: entry.league_name || entry.league || '',
                            odds: null,
                            result,
                            stake,
                            payout_gross: null,
                            payout_net: null,
                            net: null,
                            note: 'Brak kursu w historii'
                        });
                        return;
                    }

                    const payout = result === 'won' ? stake * odds : 0;
                    const payoutNet = result === 'won' ? payout * 0.88 : 0;
                    const net = payoutNet - stake;

                    totalStake += stake;
                    totalReturnGross += payout;
                    totalReturnNet += payoutNet;

                    if (result === 'won') wins += 1;
                    if (result === 'lost') losses += 1;

                    matches.push({
                        home: entry.home_name,
                        away: entry.away_name,
                        league: entry.league_name || entry.league || '',
                        odds,
                        result,
                        stake,
                        payout_gross: payout,
                        payout_net: payoutNet,
                        net,
                        note: null
                    });
                });

                if (matches.length === 0) return null;

                const netProfit = totalReturnNet - totalStake;
                const roi = totalStake > 0 ? (netProfit / totalStake) * 100 : 0;

                return {
                    date: dateStr,
                    stake,
                    wins,
                    losses,
                    skipped,
                    matchesPlayed: matches.length,
                    totalStake,
                    totalReturnGross,
                    totalReturnNet,
                    netProfit,
                    roi,
                    matches
                };
            } catch (error) {
                console.error('BÅ‚Ä…d podczas obliczania zysku:', error);
                return null;
            }
        }

        function logProfitReportToConsole(report) {
            if (!report) return;
            const {
                date,
                stake,
                wins,
                losses,
                skipped,
                totalStake,
                totalReturnGross,
                totalReturnNet,
                netProfit,
                roi,
                matches,
                matchesPlayed
            } = report;
            
            console.log(`Stawka bazowa: ${formatCurrencyPLN(stake)}`);
            
            console.log(`Wygrane: ${wins} | Przegrane: ${losses}${skipped ? ` | PomiÄ™te (brak kursu): ${skipped}` : ''}`);
            console.log(`Suma stawek: ${formatCurrencyPLN(totalStake)}`);
            console.log(`Zwrot brutto (bez podatku): ${formatCurrencyPLN(totalReturnGross)}`);
            console.log(`Zwrot netto (po 12% podatku): ${formatCurrencyPLN(totalReturnNet)}`);
            console.log(`Zysk netto: ${formatCurrencyPLN(netProfit)} (${roi.toFixed(2)}% ROI)`);
            
            matches.forEach(match => {
                const teams = `${match.home || 'N/A'} vs ${match.away || 'N/A'}`;
                const league = match.league ? ` (${match.league})` : '';
                const odds = match.odds ? match.odds.toFixed(2) : 'â€”';
                const payoutGross = match.payout_gross !== null ? formatCurrencyPLN(match.payout_gross) : 'â€”';
                const payoutNet = match.payout_net !== null ? formatCurrencyPLN(match.payout_net) : 'â€”';
                const net = match.net !== null ? formatCurrencyPLN(match.net) : 'â€”';
                const note = match.note ? ` [${match.note}]` : '';
                const result = match.result === 'won' ? 'WYGRANA' : 'PRZEGRANA';
                
            });
            
        }

        function createProfitCsv(report) {
            const header = ['date', 'home', 'away', 'league', 'result', 'odds', 'stake_pln', 'payout_gross_pln', 'payout_net_pln', 'net_pln'];
            const rows = report.matches.map(match => [
                report.date,
                (match.home || '').replace(/"/g, '""'),
                (match.away || '').replace(/"/g, '""'),
                (match.league || '').replace(/"/g, '""'),
                match.result,
                match.odds !== null ? match.odds.toFixed(2) : '',
                match.stake.toFixed(2),
                match.payout_gross !== null ? match.payout_gross.toFixed(2) : '',
                match.payout_net !== null ? match.payout_net.toFixed(2) : '',
                match.net !== null ? match.net.toFixed(2) : '',
            ]);
            const summaryRow = [
                '',
                '',
                '',
                '',
                'SUMMARY',
                '',
                Number(report.totalStake || 0).toFixed(2),
                Number(report.totalReturnGross || 0).toFixed(2),
                Number(report.totalReturnNet || 0).toFixed(2),
                Number(report.netProfit || 0).toFixed(2)
            ];
            const infoRows = [
                ['', '', '', '', 'MATCHES_PLAYED', `${report.matchesPlayed}`, '', '', '', ''],
                ['', '', '', '', 'WON', `${report.wins}`, '', '', '', ''],
                ['', '', '', '', 'LOST', `${report.losses}`, '', '', '', ''],
                ['', '', '', '', 'SKIPPED', `${report.skipped}`, '', '', '', '']
            ];
            const csvLines = [
                header.join(','),
                ...rows.map(cols => cols.map(value => `"${value}"`).join(',')),
                summaryRow.map(value => `"${value}"`).join(','),
                ...infoRows.map(row => row.map(value => `"${value}"`).join(','))
            ];
            return '\ufeff' + csvLines.join('\n');
        }

        function downloadFile(filename, content, mimeType = 'text/plain;charset=utf-8') {
            try {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = filename;
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Nie udaÅ‚o siÄ™ pobraÄ‡ pliku:', error);
            }
        }

        async function fetchOddsForEntry(entry) {
            if (!entry) return null;
            if (getEntryOdds(entry) !== null) return getEntryOdds(entry);
            const matchId = entry.api_match_id || entry.match_id || (entry.match && (entry.match.id || entry.match.match_id));
            if (!matchId) return null;
            try {
                const proxy = getProxy();
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                } else {
                    url = `${BASE_URL}/match?match_id=${matchId}`;
                }
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                if (!data.success || !data.data) return null;
                const matchData = data.data;
                const odds = matchData.odds_corners_over_95 ??
                    matchData.odds_over95 ??
                    matchData.pre_odds_corner_over_9_5 ??
                    matchData.odds_corner_over_9_5;
                if (odds) {
                    const numeric = parseFloat(odds);
                    if (Number.isFinite(numeric) && numeric > 1) {
                        entry.odds_over95 = numeric;
                        entry.analysis = entry.analysis || {};
                        entry.analysis.odds_over95 = entry.analysis.odds_over95 ?? numeric;
                        entry.match = entry.match || {};
                        entry.match.odds_corners_over_95 = numeric;
                        entry.match.odds_over95 = numeric;
                        return numeric;
                    }
                }
                return null;
            } catch (error) {
                
                return null;
            }
        }

        async function exportProfitReportForDate(dateStr, {
            stake = 5,
            format = 'csv',
            autoDownload = true,
            fetchMissingOdds = true,
            skipIfAlreadyExported = false,
            logSummary = true,
            filename
        } = {}) {
            try {
                if (!dateStr) {
                    throw new Error('Brak daty do wygenerowania raportu zyskÃ³w.');
                }

                const savedHistory = localStorage.getItem('over95_history');
                if (!savedHistory) {
                    if (logSummary) {
                        
                    }
                    return null;
                }

                let history = JSON.parse(savedHistory);
                if (!Array.isArray(history) || history.length === 0) {
                    if (logSummary) {
                        
                    }
                    return null;
                }

                if (skipIfAlreadyExported) {
                    const lastExport = localStorage.getItem(PROFIT_REPORT_LAST_EXPORT_KEY);
                    if (lastExport === dateStr) {
                        if (logSummary) {
                            
                        }
                        return null;
                    }
                }

                const entriesForDate = history.filter(entry => {
                    const entryDate = getEntryDateStr(entry);
                    const result = getEntryResult(entry);
                    return entryDate === dateStr && result;
                });

                if (entriesForDate.length === 0) {
                    if (logSummary) {
                        
                    }
                    return null;
                }

                let updated = false;
                if (fetchMissingOdds) {
                    for (const entry of entriesForDate) {
                        if (getEntryOdds(entry) === null) {
                            const odds = await fetchOddsForEntry(entry);
                            if (odds !== null) {
                                updated = true;
                            }
                        }
                    }
                }

                    if (updated) {
                        const saveResult = saveHistoryWithQuotaProtection(history);
                        history = saveResult.history;
                        if (!saveResult.saved) {
                            
                        }
                    }

                const report = calculateProfitForDate(dateStr, stake);
                if (!report) {
                    if (logSummary) {
                        
                    }
                    return null;
                }

                if (autoDownload) {
                    const baseName = filename || `profit_${dateStr}`;
                    if (format === 'json') {
                        const jsonContent = JSON.stringify(report, null, 2);
                        downloadFile(`${baseName}.json`, jsonContent, 'application/json;charset=utf-8');
                    } else {
                        const csvContent = createProfitCsv(report);
                        downloadFile(`${baseName}.csv`, csvContent, 'text/csv;charset=utf-8');
                    }
                }

                if (logSummary) {
                    logProfitReportToConsole(report);
                }

                localStorage.setItem(PROFIT_REPORT_LAST_EXPORT_KEY, dateStr);
                return report;
            } catch (error) {
                console.error('BÅ‚Ä…d podczas eksportu raportu zyskÃ³w:', error);
                return null;
            }
        }

        async function exportYesterdayProfitReport(options = {}) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const dateStr = yesterday.toISOString().split('T')[0];
            return exportProfitReportForDate(dateStr, options);
        }

        window.exportProfitReportForDate = exportProfitReportForDate;
        window.exportYesterdayProfitReport = exportYesterdayProfitReport;
        window.simulateAdvancedFilterForDate = simulateAdvancedFilterForDate;

        function isCacheFilled(dateStr) {
            return localStorage.getItem(`cacheFilled_${dateStr}`) === '1';
        }

        function markCacheFilled(dateStr) {
            localStorage.setItem(`cacheFilled_${dateStr}`, '1');
        }

async function ensureCacheForDate(dateStr, { showMessage = false, label = '' } = {}) {
    if (USE_PROXY) {
        
        return;
    }
    try {
        if (!dateStr) return;
        if (isCacheFilled(dateStr)) {
            
            return;
        }
        const baseRoot = BASE_URL.endsWith('/api') ? BASE_URL.slice(0, -4) : BASE_URL;
        const response = await fetch(`${baseRoot}/api/cache-day`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ date: dateStr })
        });
        if (!response.ok) {
            
            return;
        }
        const data = await response.json();
        if (data.success) {
            markCacheFilled(dateStr);
            if (showMessage && data.downloaded) {
                const msgLabel = label ? ` (${label})` : '';
                displayMessage(`ðŸ“¦ Pobrano ${data.match_count} meczÃ³w z ${dateStr}${msgLabel}`, 'success');
            }
        } else {
            
        }
    } catch (error) {
        
    }
}

async function ensureYesterdayCache() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dateStr = yesterday.toISOString().split('T')[0];
    await ensureCacheForDate(dateStr, { showMessage: true, label: 'wczoraj' });
}

async function ensureTodayCache() {
    const today = new Date().toISOString().split('T')[0];
    await ensureCacheForDate(today);
}


        // Fetch matches from API
        async function fetchMatches() {
            showLoading(true);
            displayMessage('Pobieranie meczÃ³w z API...', 'info');
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const proxy = getProxy();
                
                // JeÅ›li uÅ¼ywasz lokalnego proxy, API_KEY jest juÅ¼ w URL przez backend
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/todays-matches?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/todays-matches`;
                }
                
                
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success || !data.data || !Array.isArray(data.data)) {
                    throw new Error('Brak danych w odpowiedzi API');
                }

                await ensureTodayCache();
                
                // Filtruj tylko mecze z dzisiaj (wedÅ‚ug date_unix w UTC)
                // date_unix z API jest w UTC, wiÄ™c musimy uÅ¼yÄ‡ UTC do obliczania przedziaÅ‚Ã³w
                const todayUTC = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
                const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000); // Unix timestamp poczÄ…tku dnia UTC
                const todayEnd = todayStart + 86399; // +23:59:59 = 86399 sekund
                
                const allMatches = data.data || [];
                
                console.log(`ðŸ“… Dzisiejszy zakres UTC: ${new Date(todayStart * 1000).toISOString()} - ${new Date(todayEnd * 1000).toISOString()}`);
                
                // Pokazuj WSZYSTKIE mecze z dzisiaj - niezaleÅ¼nie od statusu (rozegrane, trwajÄ…ce, oczekujÄ…ce)
                // Rozszerzamy zakres o 6 godzin wczeÅ›niej aby uwzglÄ™dniÄ‡ rÃ³Å¼nice stref czasowych
                // NIE rozszerzamy w przyszÅ‚oÅ›Ä‡ - mecze z nastÄ™pnego dnia nie powinny siÄ™ pokazywaÄ‡
                const extendedStart = todayStart - 21600; // 6 godzin wczeÅ›niej
                const extendedEnd = todayEnd; // Koniec dnia (bez rozszerzania w przyszÅ‚oÅ›Ä‡)
                
                const filteredOut = [];
                matchesData = allMatches.filter(match => {
                    const matchDateUnix = match.date_unix;
                    const status = match.status || 'unknown';
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    
                    if (!matchDateUnix) {
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: 'brak date_unix', status});
                        return false;
                    }
                    
                    // SprawdÅº czy mecz jest w zakresie dzisiaj (z rozszerzeniem wstecz, ale nie w przÃ³d)
                    // Dodatkowo sprawdÅº czy data meczu (bez czasu) to dzisiaj
                    const matchDateObj = new Date(matchDateUnix * 1000);
                    // PorÃ³wnaj daty jako stringi YYYY-MM-DD w UTC
                    const matchDateStr = matchDateObj.toISOString().split('T')[0];
                    
                    // Mecz musi byÄ‡ w zakresie czasowym I mieÄ‡ datÄ™ dzisiaj
                    const isInTimeRange = matchDateUnix >= extendedStart && matchDateUnix <= extendedEnd;
                    const isTodayDate = matchDateStr === todayUTC;
                    
                    const isInRange = isInTimeRange && isTodayDate;
                    
                    if (!isInRange) {
                        const matchDateFullStr = matchDateObj.toISOString();
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: `poza zakresem (${matchDateFullStr})`, status});
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`âœ… Filtrowanie meczÃ³w: ${allMatches.length} wszystkich, ${matchesData.length} pokazanych (wszystkie statusy)`);
                if (filteredOut.length > 0) {
                    
                    filteredOut.forEach((item, idx) => {
                        console.log(`   ${idx + 1}. ${item.match} - ${item.reason} (status: ${item.status})`);
                    });
                }
                
                // Loguj pokazane mecze z ich statusami
                console.log(`ðŸ“‹ Pokazane mecze (${matchesData.length}):`);
                matchesData.forEach((match, idx) => {
                    const status = match.status || 'unknown';
                    const time = match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-';
                    console.log(`   ${idx + 1}. ${match.home_name} vs ${match.away_name} (${time}) - status: ${status}`);
                });
                
                // Zapisz do localStorage
                localStorage.setItem('matchesData', JSON.stringify(matchesData));
                localStorage.setItem('matchesDate', today);
                
                // JeÅ›li mecze siÄ™ zmieniÅ‚y, wyczyÅ›Ä‡ cache analizy
                const currentHash = createMatchesHash(matchesData);
                const cachedHash = localStorage.getItem('lastAnalysisHash');
                if (cachedHash !== currentHash) {
                    
                    localStorage.removeItem('lastAnalysis');
                    localStorage.removeItem('lastAnalysisHash');
                    analyzedMatches = [];
                    lastAnalysisHash = null;
                }
                
                showLoading(false);
                displayMatches();
                displayMessage(`âœ“ Pobrano ${matchesData.length} meczÃ³w!`, 'success');
            } catch (error) {
                showLoading(false);
                console.error('BÅ‚Ä…d pobierania meczÃ³w:', error);
                displayMessage('BÅ‚Ä…d pobierania danych: ' + error.message, 'error');
                
                // SprÃ³buj zaÅ‚adowaÄ‡ z localStorage
                const savedMatches = localStorage.getItem('matchesData');
                const savedDate = localStorage.getItem('matchesDate');
                if (savedMatches && savedDate === new Date().toISOString().split('T')[0]) {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj teÅ¼ z cache (na wypadek jeÅ›li byÅ‚y w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('ZaÅ‚adowano dane z cache', 'info');
                }
            }
        }

        // Display matches
        function displayMatches() {
            const container = document.getElementById('matches-container');
            if (matchesData.length === 0) {
                container.innerHTML = '<div class="card" style="grid-column: 1 / -1;"><p style="color: #FFFFFF; text-align: center;">Brak meczÃ³w do wyÅ›wietlenia</p></div>';
                return;
            }
            
            // Pobierz nazwy lig (z cache jeÅ›li dostÄ™pne)
            let leaguesMap = {};
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    leaguesMap = JSON.parse(saved);
                }
            } catch (e) {
                console.error('BÅ‚Ä…d odczytu leaguesMap:', e);
            }
            
            // Grupuj mecze wedÅ‚ug ligi
            const matchesByLeague = {};
            matchesData.forEach(match => {
                const competitionId = match.competition_id;
                const leagueKey = leaguesMap[competitionId] || `Liga ID: ${competitionId}`;
                
                if (!matchesByLeague[leagueKey]) {
                    matchesByLeague[leagueKey] = [];
                }
                matchesByLeague[leagueKey].push(match);
            });
            
            // Przygotuj ligi z informacjÄ… o liczbie meczÃ³w
            const leagueEntries = Object.entries(matchesByLeague).map(([key, matches]) => ({
                key,
                matches,
                count: matches.length
            }));
            
            // Sortuj ligi wedÅ‚ug liczby meczÃ³w (malejÄ…co)
            leagueEntries.sort((a, b) => b.count - a.count);
            
            // Podziel ligi na pary - w kaÅ¼dej parze lewa (A) ma wiÄ™cej meczÃ³w niÅ¼ prawa (B)
            const leaguePairs = [];
            for (let i = 0; i < leagueEntries.length; i += 2) {
                if (i + 1 < leagueEntries.length) {
                    // Para lig - upewnij siÄ™, Å¼e lewa ma wiÄ™cej
                    const left = leagueEntries[i];
                    const right = leagueEntries[i + 1];
                    if (left.count >= right.count) {
                        leaguePairs.push([left, right]);
                    } else {
                        leaguePairs.push([right, left]);
                    }
                } else {
                    // Ostatnia liga bez pary - dodaj do lewej kolumny
                    leaguePairs.push([leagueEntries[i], null]);
                }
            }
            
            // Funkcja do generowania HTML dla sekcji ligi
            const generateLeagueHTML = (league) => {
                if (!league) return '';
                const matchText = league.count === 1 ? '1 mecz' : `${league.count} meczÃ³w`;
                let html = `
                    <div class="league-section">
                        <div class="league-title">ðŸ† ${league.key} (${matchText})</div>
                `;
                
                league.matches.forEach(match => {
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    const dateUnix = match.date_unix;
                    const status = match.status || 'pending';
                    let timeStr = '-';
                    let statusBadge = '';
                    
                    if (dateUnix) {
                        const date = new Date(dateUnix * 1000);
                        timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                    }
                    
                    // Dodaj badge statusu
                    if (status === 'complete' || status === 'finished' || status === 'FT') {
                        statusBadge = '<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">ZakoÅ„czony</span>';
                    } else if (status === 'live' || status === 'inplay' || status === 'LIVE') {
                        statusBadge = '<span style="background: #EF0107; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">LIVE</span>';
                    } else if (status === 'pending' || status === 'scheduled') {
                        statusBadge = '<span style="background: #FF9800; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">Oczekuje</span>';
                    }
                    
                    // SprawdÅº czy mecz ma juÅ¼ analizÄ™
                    const matchId = match.id || match.match_id;
                    let analysisIcon = '<span style="font-size: 0.8em; color: #EF0107; margin-left: 5px;">ðŸ‘†</span>';
                    let analysisTitle = 'Kliknij aby zobaczyÄ‡ analizÄ™ modeli';
                    
                    // SprawdÅº w allAnalyzedMatches (wszystkie przeanalizowane mecze)
                    if (allAnalyzedMatches && allAnalyzedMatches.length > 0) {
                        const analyzedMatch = allAnalyzedMatches.find(am => {
                            const amMatch = am.match || {};
                            const amMatchId = amMatch.id || amMatch.match_id || am.api_match_id;
                            return amMatchId === matchId;
                        });
                        
                        if (analyzedMatch && analyzedMatch.analysis) {
                            // Mecz ma analizÄ™ - sprawdÅº czy kwalifikuje siÄ™
                            const isQualified = analyzedMatch.analysis.qualified || false;
                            if (isQualified) {
                                analysisIcon = '<span style="font-size: 0.8em; color: #4CAF50; margin-left: 5px;">âœ…</span>';
                                analysisTitle = 'Mecz kwalifikuje siÄ™ - kliknij aby zobaczyÄ‡ szczegÃ³Å‚y';
                            } else {
                                analysisIcon = '<span style="font-size: 0.8em; color: #EF0107; margin-left: 5px;">âŒ</span>';
                                analysisTitle = 'Mecz nie kwalifikuje siÄ™ - kliknij aby zobaczyÄ‡ szczegÃ³Å‚y';
                            }
                        }
                    }
                    
                    html += `
                        <div class="match-item" style="cursor: pointer;" onclick="analyzeAndShowMatchDetails(${matchId})" title="${analysisTitle}">
                            <span class="match-time">${timeStr}</span>
                            <span class="match-teams">${homeName} vs ${awayName}${statusBadge ? ` ${statusBadge}` : ''} ${analysisIcon}</span>
                        </div>
                    `;
                });
                
                html += '</div>';
                return html;
            };
            
            // Generuj HTML - kaÅ¼da para lig w osobnym wierszu
            let html = '';
            leaguePairs.forEach(([leftLeague, rightLeague]) => {
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">';
                html += '<div>' + generateLeagueHTML(leftLeague) + '</div>';
                html += '<div>' + generateLeagueHTML(rightLeague) + '</div>';
                html += '</div>';
            });
            
            container.innerHTML = html;
            
            // Aktualizuj statystyki
            document.getElementById('total-matches').textContent = matchesData.length;
            document.getElementById('total-leagues').textContent = leagueEntries.length;
            document.getElementById('stats').style.display = 'grid';
        }

        // Fetch team stats from API
        async function fetchTeamStats(teamId, competitionId) {
            try {
                const proxy = getProxy();
                
                // Najpierw sprÃ³buj league-season
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-season?season_id=${competitionId}`;
                }
                let response = await fetch(url);
                
                // JeÅ›li 403 i uÅ¼ywamy zewnÄ™trznego proxy, sprÃ³buj zmieniÄ‡ proxy
                if (response.status === 403 && USE_PROXY) {
                    
                    // PrÃ³buj nastÄ™pnego proxy
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                } else if (response.status === 403 && !USE_PROXY) {
                    console.error('âŒ 403 Forbidden - sprawdÅº czy proxy server dziaÅ‚a na localhost:8080');
                    console.error('   Uruchom: python3 proxy_server.py');
                }
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.data) {
                        // ZnajdÅº druÅ¼ynÄ™ w danych
                        const clubs = Array.isArray(data.data) ? data.data : (data.data.clubs || []);
                        for (const club of clubs) {
                            if (club.id === teamId) {
                                return club;
                            }
                        }
                    }
                }
                
                // Fallback: pobierz mecze z ligi
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-matches?season_id=${competitionId}`;
                }
                response = await fetch(url);
                
                // JeÅ›li 403 i uÅ¼ywamy zewnÄ™trznego proxy, sprÃ³buj zmieniÄ‡ proxy
                if (response.status === 403 && USE_PROXY) {
                    
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                }
                
                if (!response.ok) {
                    console.error(`BÅ‚Ä…d pobierania league-matches: ${response.status}`);
                    return null;
                }
                
                const data = await response.json();
                if (!data.success || !data.data) return null;
                
                // Filtruj mecze z tÄ… druÅ¼ynÄ… (zakoÅ„czone)
                const teamMatches = data.data
                    .filter(m => m.status === 'complete' && (m.homeID === teamId || m.awayID === teamId))
                    .sort((a, b) => (b.date_unix || 0) - (a.date_unix || 0))
                    .slice(0, 5);
                
                if (teamMatches.length === 0) return null;
                
                // Oblicz statystyki z meczÃ³w
                return calculateStatsFromMatches(teamMatches, teamId);
                
            } catch (error) {
                console.error('BÅ‚Ä…d pobierania statystyk:', error);
                return null;
            }
        }

        // Calculate stats from matches
        function calculateStatsFromMatches(matches, teamId) {
            if (!matches || matches.length === 0) return null;
            
            let totalCorners = 0;
            let totalShots = 0;
            let totalPossession = 0;
            let totalDangerousAttacks = 0;
            let over95Count = 0;
            let over105Count = 0;
            let teamCornersGe6Count = 0;
            let teamCornersGe7Count = 0;
            let shotsGe14Count = 0;
            let shotsGe16Count = 0;
            let fhCornersGe5Count = 0;
            let shCornersGe6Count = 0;
            let first10CornerCount = 0;
            const totalCornersList = [];
            const teamCornersList = [];
            const recentMatches = [];
            
            matches.forEach(match => {
                const isHome = match.homeID === teamId;
                const corners = isHome ? (match.team_a_corners ?? match.team_a_corner_count ?? match.team_a_corner ?? 0) : (match.team_b_corners ?? match.team_b_corner_count ?? match.team_b_corner ?? 0);
                const totalCornerCount = match.totalCornerCount ?? match.total_corner_count ?? 0;
                const shots = isHome ? (match.team_a_shots ?? match.team_a_shots_total ?? 0) : (match.team_b_shots ?? match.team_b_shots_total ?? 0);
                const possession = isHome ? (match.team_a_possession ?? 0) : (match.team_b_possession ?? 0);
                const dangerousAttacks = isHome ? (match.team_a_dangerous_attacks ?? match.team_a_attacks_dangerous ?? 0) : (match.team_b_dangerous_attacks ?? match.team_b_attacks_dangerous ?? 0);
                const fhCorners = isHome ? (match.team_a_fh_corners ?? match.team_a_corners_fh ?? match.team_a_corners_first_half ?? 0) : (match.team_b_fh_corners ?? match.team_b_corners_fh ?? match.team_b_corners_first_half ?? 0);
                const shCorners = isHome ? (match.team_a_2h_corners ?? match.team_a_corners_sh ?? match.team_a_corners_second_half ?? 0) : (match.team_b_2h_corners ?? match.team_b_corners_sh ?? match.team_b_corners_second_half ?? 0);
                const first10Corners = isHome ? (match.team_a_corners_0_10_min ?? match.team_a_corner_0_10 ?? match.team_a_corner_first_10 ?? 0) : (match.team_b_corners_0_10_min ?? match.team_b_corner_0_10 ?? match.team_b_corner_first_10 ?? 0);
                
                totalCorners += corners;
                totalShots += shots;
                totalPossession += possession;
                totalDangerousAttacks += dangerousAttacks;
                
                if (totalCornerCount >= 10) over95Count++;
                if (totalCornerCount >= 11) over105Count++;
                if (corners >= 6) teamCornersGe6Count++;
                if (corners >= 7) teamCornersGe7Count++;
                if (shots >= 14) shotsGe14Count++;
                if (shots >= 16) shotsGe16Count++;
                if (fhCorners >= 5) fhCornersGe5Count++;
                if (shCorners >= 6) shCornersGe6Count++;
                if (first10Corners >= 1) first10CornerCount++;
                
                totalCornersList.push(totalCornerCount);
                teamCornersList.push(corners);
                
                recentMatches.push({
                    totalCornerCount,
                    corners,
                    shots,
                    possession,
                    dangerousAttacks,
                    fhCorners,
                    shCorners,
                    first10Corners
                });
            });
            
            const matchCount = matches.length;
            const avgTotalCorners = matchCount > 0 ? totalCornersList.reduce((sum, v) => sum + v, 0) / matchCount : 0;
            const avgTeamCorners = matchCount > 0 ? teamCornersList.reduce((sum, v) => sum + v, 0) / matchCount : 0;
            const totalCornersStd = matchCount > 1 ? Math.sqrt(totalCornersList.reduce((acc, v) => acc + Math.pow(v - avgTotalCorners, 2), 0) / matchCount) : 0;
            const teamCornersStd = matchCount > 1 ? Math.sqrt(teamCornersList.reduce((acc, v) => acc + Math.pow(v - avgTeamCorners, 2), 0) / matchCount) : 0;
            
            return {
                avg_corners: totalCorners / matchCount,
                avg_shots: totalShots / matchCount,
                avg_possession: totalPossession / matchCount,
                avg_dangerous_attacks: totalDangerousAttacks / matchCount,
                over95_percentages: [(over95Count / matchCount) * 100],
                recent_over95_rate: matchCount > 0 ? over95Count / matchCount : 0,
                recent_over105_rate: matchCount > 0 ? over105Count / matchCount : 0,
                recent_team_corners_ge6_rate: matchCount > 0 ? teamCornersGe6Count / matchCount : 0,
                recent_team_corners_ge7_rate: matchCount > 0 ? teamCornersGe7Count / matchCount : 0,
                recent_team_shots_ge14_rate: matchCount > 0 ? shotsGe14Count / matchCount : 0,
                recent_team_shots_ge16_rate: matchCount > 0 ? shotsGe16Count / matchCount : 0,
                recent_fh_corners_ge5_rate: matchCount > 0 ? fhCornersGe5Count / matchCount : 0,
                recent_sh_corners_ge6_rate: matchCount > 0 ? shCornersGe6Count / matchCount : 0,
                recent_corner_first10_rate: matchCount > 0 ? first10CornerCount / matchCount : 0,
                recent_total_corners_std: totalCornersStd,
                recent_team_corners_std: teamCornersStd,
                recent_matches: recentMatches
            };
        }

        // Calculate Over 9.5 percentage
        function calculateOver95Percentage(stats) {
            if (!stats || !stats.recent_matches || stats.recent_matches.length === 0) {
                // SprÃ³buj z over95_percentages jeÅ›li dostÄ™pne
                if (stats?.over95_percentages && stats.over95_percentages.length > 0) {
                    return stats.over95_percentages[0];
                }
                return 0;
            }
            
            const validMatches = stats.recent_matches.filter(m => m.totalCornerCount !== -1 && m.totalCornerCount !== undefined);
            if (validMatches.length === 0) return 0;
            
            const over95Count = validMatches.filter(m => m.totalCornerCount > 9.5).length;
            return (over95Count / validMatches.length) * 100;
        }

        // Analyze single match
        function analyzeMatch(match, homeStats, awayStats) {
            const homePercent = calculateOver95Percentage(homeStats);
            const awayPercent = calculateOver95Percentage(awayStats);
            
            // Podstawowe wymaganie
            const meetsBasic = homePercent >= 50 && awayPercent >= 50;
            
            // Oblicz statystyki
            const avgShotsHome = homeStats?.avg_shots || 0;
            const avgShotsAway = awayStats?.avg_shots || 0;
            const avgPossessionHome = homeStats?.avg_possession || 0;
            const avgPossessionAway = awayStats?.avg_possession || 0;
            const avgDangerousAttacksHome = homeStats?.avg_dangerous_attacks || 0;
            const avgDangerousAttacksAway = awayStats?.avg_dangerous_attacks || 0;
            
            // Min roÅ¼ne
            const homeRecent = homeStats?.recent_matches || [];
            const awayRecent = awayStats?.recent_matches || [];
            
            const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            
            const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
            const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
            
            // Åšrednia Å‚Ä…cznych roÅ¼nych
            const avgTotalCornersHome = homeValidCorners.length > 0 
                ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length 
                : 0;
            const avgTotalCornersAway = awayValidCorners.length > 0 
                ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length 
                : 0;
            
            // Kategorie
            const categories = [];
            let score = 0;
            
            // 1. Over 9.5
            const avgOver95 = (homePercent + awayPercent) / 2;
            const sumOver95 = homePercent + awayPercent;
            const meetsOver95 = (
                avgOver95 >= 60 ||
                sumOver95 >= 100 ||
                (homePercent >= 60 && awayPercent >= 40) ||
                (awayPercent >= 60 && homePercent >= 40)
            );
            if (meetsOver95) {
                categories.push(`âœ“ Over 9.5 â‰¥ 60% (${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%)`);
                score++;
            } else {
                categories.push(`âœ— Over 9.5 = ${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%`);
            }
            
            // 2. StrzaÅ‚y
            if (avgShotsHome > 14 && avgShotsAway > 14) {
                categories.push(`âœ“ StrzaÅ‚y > 14 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— StrzaÅ‚y = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
            }
            
            // 3. Posiadanie
            if (avgPossessionHome >= 45 && avgPossessionAway >= 45) {
                categories.push(`âœ“ Posiadanie â‰¥ 45% (${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%)`);
                score++;
            } else {
                categories.push(`âœ— Posiadanie = ${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%`);
            }
            
            // 4. Niebezpieczne ataki
            if (avgDangerousAttacksHome > 50 && avgDangerousAttacksAway > 50) {
                categories.push(`âœ“ Ataki > 50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
            }
            
            // 5. Åšr Å‚Ä…czne roÅ¼ne
            if (avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`âœ“ Åšr Å‚Ä…czne roÅ¼ne > 9.5 (${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— Åšr Å‚Ä…czne roÅ¼ne = ${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)}`);
            }
            
            // 6. Min roÅ¼ne
            if (minCornersHome >= 7 && minCornersAway >= 7) {
                categories.push(`âœ“ Min roÅ¼ne â‰¥ 7 (${minCornersHome} vs ${minCornersAway})`);
                score++;
            } else {
                categories.push(`âœ— Min roÅ¼ne = ${minCornersHome} vs ${minCornersAway}`);
            }
            
            // 7. Åšrednia roÅ¼nych z ostatnich 3 meczÃ³w (bardziej aktualne)
            const homeRecent3 = homeValidCorners.slice(0, 3);
            const awayRecent3 = awayValidCorners.slice(0, 3);
            const avgRecent3Home = homeRecent3.length > 0 ? homeRecent3.reduce((sum, v) => sum + v, 0) / homeRecent3.length : 0;
            const avgRecent3Away = awayRecent3.length > 0 ? awayRecent3.reduce((sum, v) => sum + v, 0) / awayRecent3.length : 0;
            const avgRecent3 = (avgRecent3Home + avgRecent3Away) / 2;
            if (avgRecent3 > 9.5) {
                categories.push(`âœ“ Åšr roÅ¼ne (ostatnie 3) > 9.5 (${avgRecent3.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— Åšr roÅ¼ne (ostatnie 3) = ${avgRecent3.toFixed(1)}`);
            }
            
            // 8. Konsystencja roÅ¼nych (odchylenie standardowe)
            const homeCornersStdDev = homeValidCorners.length > 1 ? 
                Math.sqrt(homeValidCorners.reduce((sum, v) => sum + Math.pow(v - avgTotalCornersHome, 2), 0) / homeValidCorners.length) : 0;
            const awayCornersStdDev = awayValidCorners.length > 1 ? 
                Math.sqrt(awayValidCorners.reduce((sum, v) => sum + Math.pow(v - avgTotalCornersAway, 2), 0) / awayValidCorners.length) : 0;
            const avgStdDev = (homeCornersStdDev + awayCornersStdDev) / 2;
            // Niskie odchylenie = bardziej konsystentne (dobrze)
            if (avgStdDev < 3.0 && avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`âœ“ Konsystencja roÅ¼nych (odchylenie: ${avgStdDev.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— Konsystencja roÅ¼nych (odchylenie: ${avgStdDev.toFixed(1)})`);
            }
            
            // 10. NOWE: RÃ³Å¼nica miÄ™dzy Å›redniÄ… roÅ¼nych zespoÅ‚Ã³w
            const cornersDiff = Math.abs(avgTotalCornersHome - avgTotalCornersAway);
            // MaÅ‚a rÃ³Å¼nica = zrÃ³wnowaÅ¼one zespoÅ‚y (lepiej dla Over 9.5)
            if (cornersDiff < 2.0 && avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`âœ“ ZrÃ³wnowaÅ¼one roÅ¼ne (rÃ³Å¼nica: ${cornersDiff.toFixed(1)})`);
                score++;
            } else {
                categories.push(`âœ— ZrÃ³wnowaÅ¼one roÅ¼ne (rÃ³Å¼nica: ${cornersDiff.toFixed(1)})`);
            }
            
            // Oblicz predicted avg corners
            const homeAvgCorners = homeStats?.avg_corners || 0;
            const awayAvgCorners = awayStats?.avg_corners || 0;
            const predictedAvgCorners = (homeAvgCorners + awayAvgCorners) / 2;
            
            const model7Result = calculateModel7Result(match, homeStats, awayStats);
            
            // Oblicz statystyki dla wszystkich modeli
            const modelResults = {
                model1: meetsBasic && score >= 7, // Model 1: Score >= 7
                model2: calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners) >= 9, // Model 2: Punktowy >= 9
                model3: calculateModel3Qualifies(predictedAvgCorners, avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, avgShotsHome, avgShotsAway), // Model 3: JakoÅ›ciowy
                model4: calculateModel4Qualifies(avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, minCornersHome, minCornersAway) >= 2, // Model 4: 4 czynniki >= 2
                model5: calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, avgDangerousAttacksHome, avgDangerousAttacksAway, avgPossessionHome, avgPossessionAway, avgShotsHome, avgShotsAway, homeAvgCorners, awayAvgCorners, minCornersHome, minCornersAway) >= 8.0, // Model 5: WEIGHTED >= 8.0
                model7: model7Result.qualified
            };
            
            // Kwalifikacja: mecz kwalifikuje siÄ™ jeÅ›li speÅ‚nia DOWOLNY z modeli (1, 2, 3, 4, 5, 7)
            const qualified = modelResults.model1 || modelResults.model2 || modelResults.model3 || modelResults.model4 || modelResults.model5 || modelResults.model7;
            
            return {
                qualified,
                score,
                categories,
                percent_sum: sumOver95,
                home_percent: homePercent,
                away_percent: awayPercent,
                home_stats: homeStats,
                away_stats: awayStats,
                predicted_avg_corners: predictedAvgCorners,
                model_results: modelResults,
                model7_details: model7Result
            };
        }
        
        // Model 2: System punktowy (max 13 punktÃ³w, minimum 9)
        function calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners) {
            let points = 0;
            const homeAvgCorners = homeStats?.avg_corners || 0;
            const awayAvgCorners = awayStats?.avg_corners || 0;
            const homeMinCorners = homeStats?.recent_matches?.slice(0, 5).map(m => m.totalCornerCount || 0).filter(v => v > 0);
            const awayMinCorners = awayStats?.recent_matches?.slice(0, 5).map(m => m.totalCornerCount || 0).filter(v => v > 0);
            const homeMin = homeMinCorners.length > 0 ? Math.min(...homeMinCorners) : 0;
            const awayMin = awayMinCorners.length > 0 ? Math.min(...awayMinCorners) : 0;
            const homeAttacks = homeStats?.avg_dangerous_attacks || 0;
            const awayAttacks = awayStats?.avg_dangerous_attacks || 0;
            const homeShots = homeStats?.avg_shots || 0;
            const awayShots = awayStats?.avg_shots || 0;
            
            if (homeAvgCorners >= 5.0) points += 2;
            if (awayAvgCorners >= 4.5) points += 2;
            if (homeMin >= 4.5 || awayMin >= 4.5) points += 1;
            if (homeAvgCorners + awayAvgCorners >= 9.5) points += 2;
            if (homeAttacks >= 50 && awayAttacks >= 50) points += 1;
            if (homeShots >= 12 && awayShots >= 12) points += 1;
            if (homeAttacks >= 55) points += 1;
            if (predictedAvgCorners >= 10) points += 1;
            
            return points;
        }

    function determineQualifiedModels(modelResults = {}) {
        const models = [];
        if (modelResults?.model1) models.push(1);
        if (modelResults?.model2) models.push(2);
        if (modelResults?.model3) models.push(3);
        if (modelResults?.model4) models.push(4);
        if (modelResults?.model5) models.push(5);
        if (modelResults?.model7) models.push(7);
        return models;
    }

    function formatModelLabel(modelNumber) {
        if (!modelNumber) return 'Model 1';
        return modelNumber === 7 ? 'Model 7 (Premium)' : `Model ${modelNumber}`;
    }
        
        // Model 3: JakoÅ›ciowy
        function calculateModel3Qualifies(predictedAvgCorners, homePoss, awayPoss, homeAttacks, awayAttacks, homeShots, awayShots) {
            if (predictedAvgCorners < 10.0) return false;
            
            const style1 = (homePoss > 55 && awayPoss < 45) || (awayPoss > 55 && homePoss < 45);
            const style2 = homeAttacks >= 50 && awayAttacks >= 50;
            const style3 = homeShots > 14 || awayShots > 14;
            
            return style1 || style2 || style3;
        }
        
        // Model 4: 4 czynniki >= 2
        function calculateModel4Qualifies(homePoss, awayPoss, homeAttacks, awayAttacks, homeMinCorners, awayMinCorners) {
            let factors = 0;
            
            if (Math.abs(homePoss - awayPoss) >= 10) factors++;
            if (homeAttacks >= 50 || awayAttacks >= 50) factors++;
            if ((homePoss < 45 && awayMinCorners >= 6) || (awayPoss < 45 && homeMinCorners >= 6)) factors++;
            
            return factors;
        }
        
        // Model 5: WEIGHTED (system punktowy z wagami, prÃ³g 8.0) - ULEPSZONY
        function calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, homeAttacks, awayAttacks, homePoss, awayPoss, homeShots, awayShots, homeAvgCorners, awayAvgCorners, homeMinCorners, awayMinCorners) {
            let points = 0;
            
            // 1. Predicted avg corners - ULEPSZONE (wiÄ™cej progÃ³w, lepsza skala)
            if (predictedAvgCorners >= 12) {
                points += 2.5;
            } else if (predictedAvgCorners >= 11.5) {
                points += 2.0;
            } else if (predictedAvgCorners >= 11) {
                points += 1.5;
            } else if (predictedAvgCorners >= 10.5) {
                points += 1.0;
            } else if (predictedAvgCorners >= 10) {
                points += 0.5;
            }
            
            // 2. Score (Model 1) - ULEPSZONE (wiÄ™cej punktÃ³w za wyÅ¼sze score)
            if (score >= 9) {
                points += 2.5;
            } else if (score >= 8) {
                points += 2.0;
            } else if (score >= 7) {
                points += 1.5;
            } else if (score >= 6) {
                points += 1.0;
            } else if (score >= 5) {
                points += 0.5;
            }
            
            // 3. Min Over 9.5% - ULEPSZONE (NAJWAÅ»NIEJSZY CZYNNIK - wiÄ™ksza waga)
            const minOver95 = Math.min(homePercent, awayPercent);
            if (minOver95 >= 75) {
                points += 3.0;  // ZwiÄ™kszone z 2.0
            } else if (minOver95 >= 70.1) {
                points += 2.5;  // ZwiÄ™kszone z 2.0
            } else if (minOver95 >= 65) {
                points += 1.5;  // Nowy prÃ³g
            } else if (minOver95 >= 60) {
                points += 1.0;
            } else if (minOver95 >= 55) {
                points += 0.5;  // Nowy prÃ³g
            }
            
            // 4. Åšr atakÃ³w - bez zmian
            const avgAttacks = (homeAttacks + awayAttacks) / 2;
            if (avgAttacks >= 57) {
                points += 1.5;
            } else if (avgAttacks >= 55) {
                points += 1.0;
            } else if (avgAttacks >= 50) {
                points += 0.5;
            }
            
            // 5. Styl gry - bez zmian
            const style1 = (homePoss > 55 && awayPoss < 45) || (awayPoss > 55 && homePoss < 45);
            const style2 = homeAttacks >= 50 && awayAttacks >= 50;
            const style3 = homeShots > 14 || awayShots > 14;
            let stylePoints = 0;
            if (style1) stylePoints += 0.5;
            if (style2) stylePoints += 0.5;
            if (style3) stylePoints += 0.5;
            if (stylePoints >= 1.0) {
                points += 1.5;
            } else if (stylePoints >= 0.5) {
                points += 0.75;
            }
            
            // 6. Åšr corners - bez zmian
            if (homeAvgCorners >= 5.0 && awayAvgCorners >= 4.5) {
                points += 1.0;
            } else if (homeAvgCorners >= 4.5 || awayAvgCorners >= 4.0) {
                points += 0.5;
            }
            
            // 7. Min corners - bez zmian
            if (homeMinCorners >= 7 && awayMinCorners >= 7) {
                points += 1.0;
            } else if (homeMinCorners >= 6 || awayMinCorners >= 6) {
                points += 0.5;
            }
            
            // 8. NOWY: Bonus za wysokie oba Over 9.5%
            if (homePercent >= 70 && awayPercent >= 70) {
                points += 0.5;  // Bonus za oba zespoÅ‚y z wysokim Over 9.5%
            }
            
            return points;
        }

        // Fetch league names
        async function fetchLeagueNames() {
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    return JSON.parse(saved);
                }
                
                const proxy = getProxy();
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-list?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/league-list`;
                }
                const response = await fetch(url);
                
                if (!response.ok) return {};
                
                const data = await response.json();
                if (!data.success || !data.data) return {};
                
                const leaguesMap = {};
                data.data.forEach(league => {
                    const seasons = league.season || [];
                    seasons.forEach(season => {
                        if (season.id) {
                            const country = league.country || '';
                            const leagueName = league.league_name || league.name || '';
                            leaguesMap[season.id] = `${country} - ${leagueName}`;
                        }
                    });
                });
                
                localStorage.setItem('leaguesMap', JSON.stringify(leaguesMap));
                return leaguesMap;
            } catch (error) {
                console.error('BÅ‚Ä…d pobierania nazw lig:', error);
                return {};
            }
        }

        // UtwÃ³rz hash z meczÃ³w dla porÃ³wnania
        function createMatchesHash(matches) {
            if (!matches || matches.length === 0) return '';
            // Sortuj mecze i stwÃ³rz hash z ID i dat
            const sorted = [...matches].sort((a, b) => (a.id || 0) - (b.id || 0));
            const ids = sorted.map(m => `${m.id}_${m.date_unix}_${m.status}`).join('|');
            return ids;
        }

        // Analyze Over 9.5 matches
        async function analyzeOver95(silent = false, forceReanalyze = false) {
            if (matchesData.length === 0) {
                displayMessage('Najpierw pobierz mecze!', 'warning');
                return;
            }

            advancedFiltersSummary = null;
            advancedFiltersRejected = [];
            
            // SprawdÅº czy mecze siÄ™ zmieniÅ‚y od ostatniej analizy
            const currentHash = createMatchesHash(matchesData);
            const cachedAnalysis = localStorage.getItem('lastAnalysis');
            const cachedHash = localStorage.getItem('lastAnalysisHash');
            
                // JeÅ›li forceReanalyze jest true, pomiÅ„ cache
                if (!forceReanalyze && cachedAnalysis && cachedHash === currentHash && analyzedMatches.length === 0) {
                // Wczytaj z cache
                try {
                    const parsed = JSON.parse(cachedAnalysis);
                    // Filtruj i ponownie zweryfikuj mecze
                    analyzedMatches = parsed.filter(item => {
                        // Ponownie oblicz zakwalifikowane modele na podstawie model_results
                        const qualifiedModels = determineQualifiedModels(item.analysis?.model_results || {});
                        item.qualified_models = qualifiedModels;
                        
                        // SprawdÅº czy mecz faktycznie kwalifikuje siÄ™ (ma co najmniej jeden model)
                        if (qualifiedModels.length === 0) {
                            return false;
                        }
                        
                        // Wyklucz mecze z TYLKO Modelem 4
                        if (qualifiedModels.length === 1 && qualifiedModels[0] === 4) {
                            return false;
                        }
                        
                        // Mecz kwalifikuje siÄ™ jeÅ›li ma zakwalifikowane modele (i nie jest to tylko Model 4)
                        // Ustaw rÃ³wnieÅ¼ analysis.qualified na true jeÅ›li ma zakwalifikowane modele
                        if (item.analysis) {
                            item.analysis.qualified = true;
                        }
                        return true;
                    });
                    
                    // Wczytaj rÃ³wnieÅ¼ wszystkie przeanalizowane mecze
                    const cachedAllAnalysis = localStorage.getItem('lastAnalysisAll');
                    if (cachedAllAnalysis) {
                        allAnalyzedMatches = JSON.parse(cachedAllAnalysis);
                    } else {
                        // Fallback: jeÅ›li nie ma allAnalyzedMatches, uÅ¼yj analyzedMatches
                        allAnalyzedMatches = analyzedMatches;
                    }
                    console.log(`ðŸ“‹ Wczytano analizÄ™ z cache (${analyzedMatches.length} zakwalifikowanych, ${allAnalyzedMatches.length} wszystkich)`);
                    
                    // Aktualizuj statystyki na stronie gÅ‚Ã³wnej
                    const qualifiedElement = document.getElementById('qualified-matches');
                    if (qualifiedElement) {
                        qualifiedElement.textContent = analyzedMatches.length;
                    }
                    
                    // OdÅ›wieÅ¼ listÄ™ meczÃ³w aby pokazaÄ‡ zaktualizowane ikony (âœ…/âŒ)
                    displayMatches();
                    
                    if (!silent) {
                        displayAnalysisResults();
                        openModal('analysisModal');
                        displayMessage(`âœ“ WyÅ›wietlono poprzedniÄ… analizÄ™ (${analyzedMatches.length} meczÃ³w). Aby wykonaÄ‡ ponownie, uÅ¼yj "Analizuj ponownie"`, 'info');
                    }
                    return;
                } catch (e) {
                    console.error('BÅ‚Ä…d odczytu cache analizy:', e);
                }
            }
            
            // JeÅ›li mecze siÄ™ nie zmieniÅ‚y ale mamy juÅ¼ wyniki w pamiÄ™ci, uÅ¼yj ich (chyba Å¼e forceReanalyze)
            if (!forceReanalyze && currentHash === lastAnalysisHash && analyzedMatches.length > 0) {
                console.log('ðŸ“‹ UÅ¼ywam wynikÃ³w z pamiÄ™ci (mecze nie zmieniÅ‚y siÄ™)');
                
                // Aktualizuj statystyki na stronie gÅ‚Ã³wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                // OdÅ›wieÅ¼ listÄ™ meczÃ³w aby pokazaÄ‡ zaktualizowane ikony (âœ…/âŒ)
                displayMatches();
                
                if (!silent) {
                    displayAnalysisResults();
                    openModal('analysisModal');
                    displayMessage(`âœ“ WyÅ›wietlono analizÄ™ z pamiÄ™ci (${analyzedMatches.length} meczÃ³w)`, 'info');
                }
                return;
            }
            
            showLoading(true);
            displayMessage('Analizowanie meczÃ³w...', 'info');
            
            try {
                // Pobierz nazwy lig
                const leaguesMap = await fetchLeagueNames();
                const leaguePerformanceStats = calculateHistoricalLeaguePerformance();
                
                // Pobierz statystyki dla wszystkich druÅ¼yn
                analyzedMatches = [];
                allAnalyzedMatches = []; // WyczyÅ›Ä‡ wszystkie przeanalizowane mecze
                let processed = 0;
                const total = matchesData.length;
                
                for (const match of matchesData) {
                    processed++;
                    const progress = Math.round((processed / total) * 100);
                    displayMessage(`Analizowanie meczu ${processed}/${total} (${progress}%)...`, 'info');
                    
                    const competitionId = match.competition_id;
                    const homeId = match.homeID;
                    const awayId = match.awayID;
                    
                    if (!competitionId || !homeId || !awayId) {
                        continue;
                    }
                    
                    // Pobierz statystyki obu druÅ¼yn
                    const [homeStats, awayStats] = await Promise.all([
                        fetchTeamStats(homeId, competitionId),
                        fetchTeamStats(awayId, competitionId)
                    ]);
                    
                    if (!homeStats || !awayStats) {
                        continue;
                    }
                    
                    // Analizuj mecz
                    const analysis = analyzeMatch(match, homeStats, awayStats);
                    
                    // Zapisz wszystkie przeanalizowane mecze (nie tylko zakwalifikowane)
                    const matchItem = {
                        match,
                        league: leaguesMap[competitionId] || `Liga ID: ${competitionId}`,
                        analysis,
                        home_name: match.home_name,
                        away_name: match.away_name,
                        time: match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-',
                        odds_over95: null
                    };
                    
                    // Dodaj do wszystkich przeanalizowanych
                    allAnalyzedMatches.push(matchItem);
                    
                    // Oblicz zakwalifikowane modele
                    const qualifiedModels = determineQualifiedModels(analysis.model_results);
                    matchItem.qualified_models = qualifiedModels;
                    
                    // Ponownie sprawdÅº czy mecz kwalifikuje siÄ™ na podstawie model_results
                    // (analysis.qualified moÅ¼e byÄ‡ false w starym cache, ale modele mogÄ… byÄ‡ speÅ‚nione)
                    const actuallyQualified = qualifiedModels.length > 0 && 
                        (qualifiedModels.length > 1 || qualifiedModels[0] !== 4);
                    
                    // Mecz kwalifikuje siÄ™ jeÅ›li:
                    // 1. analysis.qualified jest true (speÅ‚nia podstawowe wymagania) LUB
                    // 2. Ma zakwalifikowane modele (i nie jest to TYLKO Model 4)
                    if (analysis.qualified || actuallyQualified) {
                        // Ustaw analysis.qualified na true jeÅ›li modele sÄ… speÅ‚nione
                        if (actuallyQualified && !analysis.qualified) {
                            analysis.qualified = true;
                            matchItem.analysis.qualified = true;
                        }
                        
                        // Wyklucz mecze z TYLKO Modelem 4 (muszÄ… mieÄ‡ co najmniej jeden inny model)
                        if (qualifiedModels.length === 1 && qualifiedModels[0] === 4) {
                            // Mecz speÅ‚nia tylko Model 4 - nie dodawaj do zakwalifikowanych
                            continue;
                        }
                        
                        analyzedMatches.push(matchItem);
                    }
                    
                    // OpÃ³Åºnienie miÄ™dzy requestami
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Sortuj wedÅ‚ug score i percent_sum
                analyzedMatches.sort((a, b) => {
                    if (b.analysis.score !== a.analysis.score) {
                        return b.analysis.score - a.analysis.score;
                    }
                    return b.analysis.percent_sum - a.analysis.percent_sum;
                });
                
                // Pobieranie kursÃ³w wyÅ‚Ä…czone - kursy nie sÄ… adekwatne do bukmachera uÅ¼ytkownika

                const { filtered, rejected, summary } = applyAdvancedFilters(analyzedMatches, {
                    leagueStats: leaguePerformanceStats,
                    settings: ADVANCED_FILTER_SETTINGS
                });
                analyzedMatches = filtered;
                advancedFiltersSummary = summary;
                advancedFiltersRejected = rejected;
                if (summary) {
                    
                    if (summary.rejected > 0) {
                        console.log('Odrzucone mecze:', rejected.map(item => ({
                            match: `${item.home_name} vs ${item.away_name}`,
                            league: item.league,
                            reasons: item.advanced_metrics?.reasons || []
                        })));
                    }
                    displayMessage(`âœ… Zaawansowane filtry: ${summary.kept}/${summary.total} meczÃ³w`, 'success');
                }
                
                // Zapisz do cache
                lastAnalysisHash = currentHash;
                localStorage.setItem('lastAnalysis', JSON.stringify(analyzedMatches));
                localStorage.setItem('lastAnalysisAll', JSON.stringify(allAnalyzedMatches)); // Zapisz wszystkie przeanalizowane mecze
                localStorage.setItem('lastAnalysisHash', currentHash);
                
                // Automatycznie zapisz do historii jeÅ›li to pierwsza analiza dzisiaj
                if (analyzedMatches.length > 0) {
                    try {
                        const today = new Date().toISOString().split('T')[0];
                        const savedHistory = localStorage.getItem('over95_history');
                        let history = savedHistory ? JSON.parse(savedHistory) : [];
                        
                        // SprawdÅº czy juÅ¼ zapisano mecze dzisiaj (sprawdÅº pole saved_date lub ostatni zapis)
                        let lastSaveDate = null;
                        const lastSaveDateStr = localStorage.getItem('lastHistorySaveDate');
                        if (lastSaveDateStr) {
                            lastSaveDate = lastSaveDateStr;
                        } else if (history.length > 0) {
                            // Fallback: sprawdÅº datÄ™ ostatniego meczu (jeÅ›li nie ma saved_date)
                            const lastMatch = history.reduce((latest, match) => {
                                const matchSavedDate = match.saved_date || (match.date_unix ? new Date(match.date_unix * 1000).toISOString().split('T')[0] : null);
                                const latestSavedDate = latest.saved_date || (latest.date_unix ? new Date(latest.date_unix * 1000).toISOString().split('T')[0] : null);
                                return (matchSavedDate && matchSavedDate > (latestSavedDate || '')) ? match : latest;
                            });
                            if (lastMatch.saved_date) {
                                lastSaveDate = lastMatch.saved_date;
                            } else if (lastMatch.date_unix) {
                                lastSaveDate = new Date(lastMatch.date_unix * 1000).toISOString().split('T')[0];
                            }
                        }
                        
                        // JeÅ›li nie zapisano dzisiaj, zapisz automatycznie
                        if (lastSaveDate !== today) {
                            let savedCount = 0;
                            analyzedMatches.forEach(item => {
                                const { match, league, analysis } = item;
                                
                                // SprawdÅº czy mecz juÅ¼ istnieje w historii
                                const matchId = match.id || `${match.homeID}_${match.awayID}_${match.date_unix}`;
                                const alreadyExists = history.some(h => 
                                    (h.api_match_id === match.id) ||
                                    (h.match_id === matchId) ||
                                    (h.home_id === match.homeID && h.away_id === match.awayID && 
                                     h.date_unix === match.date_unix)
                                );
                                
                                if (!alreadyExists) {
                                    // ZnajdÅº ktÃ³ry model zakwalifikowaÅ‚ mecz (priorytet: 1, 2, 3, 4, 5)
                                    const modelResults = analysis.model_results || {};
                                    const qualifiedModels = determineQualifiedModels(modelResults);
                                    const primaryModel = qualifiedModels.length ? qualifiedModels[0] : null;
                                    
                                    const historyEntry = {
                                        match_id: matchId,
                                        api_match_id: match.id,
                                        home_id: match.homeID,
                                        away_id: match.awayID,
                                        home_name: match.home_name || item.home_name,
                                        away_name: match.away_name || item.away_name,
                                        league_name: league.split(' - ').slice(-1)[0] || league,
                                        country: league.split(' - ')[0] || '',
                                        date_unix: match.date_unix || 0,
                                        date_formatted: match.date_unix ? new Date(match.date_unix * 1000).toLocaleString('pl-PL') : 'N/A',
                                        saved_date: today, // Data zapisu do historii
                                        over95_percentages: [analysis.home_percent, analysis.away_percent],
                                        home_stats: analysis.home_stats || {},
                                        away_stats: analysis.away_stats || {},
                                        categories: analysis.categories || [],
                                        score: analysis.score || 0,
                                        percent_sum: analysis.percent_sum || 0,
                                        odds_over95: item.odds_over95 ?? analysis.odds_over95 ?? null,
                                        qualified_model: primaryModel, // Model ktÃ³ry zakwalifikowaÅ‚ mecz (1-5) - pole legacy
                                        qualified_models: qualifiedModels, // Wszystkie modele, ktÃ³re zakwalifikowaÅ‚y mecz
                                        model_results: analysis.model_results || {}, // Wszystkie wyniki modeli
                                        status: 'pending',
                                        result: 'pending',
                                        match: match,
                                        analysis: analysis,
                                        league: league
                                    };
                                    history.push(historyEntry);
                                    savedCount++;
                                }
                            });
                            
                            if (savedCount > 0) {
                                localStorage.setItem('over95_history', JSON.stringify(history));
                                localStorage.setItem('lastHistorySaveDate', today);
                                console.log(`ðŸ’¾ Automatycznie zapisano ${savedCount} meczÃ³w do historii (pierwsza analiza dzisiaj)`);
                                displayMessage(`ðŸ’¾ Automatycznie zapisano ${savedCount} meczÃ³w do historii`, 'success');
                            }
                        }
                    } catch (e) {
                        console.error('BÅ‚Ä…d podczas automatycznego zapisu do historii:', e);
                    }
                }
                
                // Aktualizuj statystyki na stronie gÅ‚Ã³wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                showLoading(false);
                
                // OdÅ›wieÅ¼ listÄ™ meczÃ³w aby pokazaÄ‡ zaktualizowane ikony (âœ…/âŒ)
                displayMatches();
                
                if (!silent) {
                    displayAnalysisResults();
                    openModal('analysisModal');
                }
                
                if (analyzedMatches.length > 0) {
                    displayMessage(`âœ“ Znaleziono ${analyzedMatches.length} kwalifikujÄ…cych siÄ™ meczÃ³w!`, 'success');
                } else {
                    displayMessage('â„¹ï¸ Nie znaleziono meczÃ³w speÅ‚niajÄ…cych kryteria Over 9.5', 'info');
                }
                
            } catch (error) {
                showLoading(false);
                console.error('BÅ‚Ä…d analizy:', error);
                displayMessage('BÅ‚Ä…d analizy: ' + error.message, 'error');
            }
        }

        // Display analysis results
        function displayAnalysisResults() {
            const content = document.getElementById('analysis-content');
            
            if (analyzedMatches.length === 0) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center;">
                            Brak meczÃ³w kwalifikujÄ…cych siÄ™ do Over 9.5.<br>
                            Å»aden mecz nie speÅ‚nia wymaganych kryteriÃ³w (â‰¥50% oba zespoÅ‚y i â‰¥7 z 9 kryteriÃ³w).
                        </p>
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="analyzeOver95()" class="btn btn-primary">ðŸ”„ Analizuj ponownie</button>
                        </div>
                    </div>
                `;
                return;
            }
            
            const totalAfterFilters = analyzedMatches.length;
            const totalBeforeFilters = advancedFiltersSummary?.total ?? totalAfterFilters;
            const totalRejectedByFilters = advancedFiltersSummary?.rejected ?? 0;

            const filteredMatches = analyzedMatches.filter(item => {
                if (currentModelFilter === 'all') return true;
                const models = (item.qualified_models && item.qualified_models.length)
                    ? item.qualified_models
                    : determineQualifiedModels(item.analysis?.model_results || item.model_results || {});
                return models.includes(parseInt(currentModelFilter, 10));
            });

            const matchesToDisplay = filteredMatches;

            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 15px; flex-wrap: wrap;">
                        <div>
                            <h3 style="color: #EF0107; margin-bottom: 10px;">âœ… Znaleziono ${matchesToDisplay.length} / ${totalAfterFilters} meczÃ³w kwalifikujÄ…cych siÄ™ (po filtrach)</h3>
                            <p style="color: #FFFFFF;">Mecze posortowane wedÅ‚ug score (najwyÅ¼szy pierwszy)</p>
                            ${advancedFiltersSummary ? `
                                <p style="color: rgba(255,255,255,0.8); font-size: 0.9em; margin-top: 8px;">
                                    ðŸ” PoczÄ…tkowo: ${totalBeforeFilters}, odrzucono przez filtry: ${totalRejectedByFilters}. 
                                    Wymagany konsensus modeli â‰¥ ${ADVANCED_FILTER_SETTINGS.minConsensus}, przewaga â‰¥ ${(ADVANCED_FILTER_SETTINGS.minEdge * 100).toFixed(1)}%, historia ligi â‰¥ ${(ADVANCED_FILTER_SETTINGS.minLeagueWinRate * 100).toFixed(0)}% przy min. ${ADVANCED_FILTER_SETTINGS.minLeagueSamples} meczach.
                                </p>
                            ` : ''}
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <label for="model-filter" style="color: #FFFFFF; font-size: 0.9em;">Filtr modelu:</label>
                            <select id="model-filter" onchange="setModelFilter(this.value)" style="padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.2); color: #FFFFFF;">
                                <option value="all" ${currentModelFilter === 'all' ? 'selected' : ''}>Wszystkie modele</option>
                                <option value="1" ${currentModelFilter === '1' ? 'selected' : ''}>Model 1</option>
                                <option value="2" ${currentModelFilter === '2' ? 'selected' : ''}>Model 2</option>
                                <option value="3" ${currentModelFilter === '3' ? 'selected' : ''}>Model 3</option>
                                <option value="4" ${currentModelFilter === '4' ? 'selected' : ''}>Model 4</option>
                                <option value="5" ${currentModelFilter === '5' ? 'selected' : ''}>Model 5</option>
                                <option value="7" ${currentModelFilter === '7' ? 'selected' : ''}>Model 7 (Premium)</option>
                            </select>
                            <button onclick="forceReanalyze()" class="btn btn-secondary" style="padding: 10px 20px; font-size: 14px;">ðŸ”„ Analizuj ponownie</button>
                        </div>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            `;
            
            if (matchesToDisplay.length === 0) {
                html += `
                    <div style="grid-column: 1 / -1;">
                        <div class="card">
                            <p style="color: #FFFFFF; text-align: center; padding: 30px;">
                                Brak meczÃ³w dla wybranego modelu.
                            </p>
                        </div>
                    </div>
                `;
                html += '</div>';
                content.innerHTML = html;
                return;
            }

            // Podziel mecze naprzemiennie miÄ™dzy kolumny, zachowujÄ…c sortowanie wedÅ‚ug score Model 1
            // Kolumna A wiersz 1: najwyÅ¼szy score, Kolumna B wiersz 1: nastÄ™pny, itd.
            // Mecze sÄ… juÅ¼ posortowane wedÅ‚ug score Model 1 (od najwyÅ¼szego do najniÅ¼szego) w linii 1367-1372
            const leftColumn = [];
            const rightColumn = [];
            
            matchesToDisplay.forEach((item, index) => {
                if (index % 2 === 0) {
                    // Parzyste indeksy (0, 2, 4...) â†’ lewa kolumna
                    leftColumn.push(item);
                } else {
                    // Nieparzyste indeksy (1, 3, 5...) â†’ prawa kolumna
                    rightColumn.push(item);
                }
            });
            
            // Funkcja do generowania szczegÃ³Å‚Ã³w dla kaÅ¼dego modelu
            const generateModelDetails = (analysis, modelResults) => {
                const homeStats = analysis.home_stats || {};
                const awayStats = analysis.away_stats || {};
                const homePercent = analysis.home_percent || 0;
                const awayPercent = analysis.away_percent || 0;
                const predictedAvgCorners = analysis.predicted_avg_corners || 0;
                const score = analysis.score || 0;
                
                // Oblicz statystyki
                const avgShotsHome = homeStats.avg_shots || 0;
                const avgShotsAway = awayStats.avg_shots || 0;
                const avgPossessionHome = homeStats.avg_possession || 0;
                const avgPossessionAway = awayStats.avg_possession || 0;
                const avgDangerousAttacksHome = homeStats.avg_dangerous_attacks || 0;
                const avgDangerousAttacksAway = awayStats.avg_dangerous_attacks || 0;
                const avgCornersHome = homeStats.avg_corners || 0;
                const avgCornersAway = awayStats.avg_corners || 0;
                
                const homeRecent = homeStats.recent_matches || [];
                const awayRecent = awayStats.recent_matches || [];
                const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
                const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
                const avgTotalCornersHome = homeValidCorners.length > 0 ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length : 0;
                const avgTotalCornersAway = awayValidCorners.length > 0 ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length : 0;
                
                const qualifiedModels = determineQualifiedModels(modelResults);
                const primaryModel = qualifiedModels.length ? qualifiedModels[0] : null;
                
                let scoreText = '';
                let detailsHTML = '';
                
                if (primaryModel === 1) {
                    // Model 1: Score >= 7/9
                    scoreText = `Score: ${score}/9`;
                    detailsHTML = analysis.categories.map(cat => {
                        const color = cat.startsWith('âœ“') ? '#4CAF50' : cat.startsWith('âœ—') ? '#EF0107' : '#FFFFFF';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                    }).join('');
                } else if (primaryModel === 2) {
                    // Model 2: Punktowy >= 9
                    const model2Score = calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners);
                    scoreText = `Punkty: ${model2Score}`;
                    
                    const details = [];
                    if (avgCornersHome >= 5.0) details.push(`âœ“ Åšr roÅ¼ne (gospodarz) â‰¥ 5.0 (${avgCornersHome.toFixed(1)})`);
                    else details.push(`âœ— Åšr roÅ¼ne (gospodarz) = ${avgCornersHome.toFixed(1)}`);
                    
                    if (avgCornersAway >= 4.5) details.push(`âœ“ Åšr roÅ¼ne (goÅ›Ä‡) â‰¥ 4.5 (${avgCornersAway.toFixed(1)})`);
                    else details.push(`âœ— Åšr roÅ¼ne (goÅ›Ä‡) = ${avgCornersAway.toFixed(1)}`);
                    
                    if (minCornersHome >= 4.5 || minCornersAway >= 4.5) details.push(`âœ“ Min roÅ¼ne â‰¥ 4.5 (${minCornersHome} vs ${minCornersAway})`);
                    else details.push(`âœ— Min roÅ¼ne = ${minCornersHome} vs ${minCornersAway}`);
                    
                    if (avgCornersHome + avgCornersAway >= 9.5) details.push(`âœ“ Suma roÅ¼nych â‰¥ 9.5 (${(avgCornersHome + avgCornersAway).toFixed(1)})`);
                    else details.push(`âœ— Suma roÅ¼nych = ${(avgCornersHome + avgCornersAway).toFixed(1)}`);
                    
                    if (avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) details.push(`âœ“ Ataki â‰¥ 50+50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`âœ— Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    if (avgShotsHome >= 12 && avgShotsAway >= 12) details.push(`âœ“ StrzaÅ‚y â‰¥ 12+12 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                    else details.push(`âœ— StrzaÅ‚y = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
                    
                    if (avgDangerousAttacksHome >= 55) details.push(`âœ“ Ataki (gospodarz) â‰¥ 55 (${avgDangerousAttacksHome.toFixed(1)})`);
                    else details.push(`âœ— Ataki (gospodarz) = ${avgDangerousAttacksHome.toFixed(1)}`);
                    
                    if (predictedAvgCorners >= 10) details.push(`âœ“ Predicted avg â‰¥ 10 (${predictedAvgCorners.toFixed(1)})`);
                    else details.push(`âœ— Predicted avg = ${predictedAvgCorners.toFixed(1)}`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('âœ“') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (primaryModel === 3) {
                    // Model 3: JakoÅ›ciowy
                    scoreText = `Predicted avg: ${predictedAvgCorners.toFixed(1)}`;
                    
                    const details = [];
                    if (predictedAvgCorners >= 10.0) details.push(`âœ“ Predicted avg corners â‰¥ 10.0 (${predictedAvgCorners.toFixed(1)})`);
                    else details.push(`âœ— Predicted avg corners = ${predictedAvgCorners.toFixed(1)}`);
                    
                    const style1 = (avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45);
                    if (style1) details.push(`âœ“ Styl 1: RÃ³Å¼nica posiadania > 10% (${avgPossessionHome.toFixed(0)}% vs ${avgPossessionAway.toFixed(0)}%)`);
                    else details.push(`âœ— Styl 1: RÃ³Å¼nica posiadania = ${Math.abs(avgPossessionHome - avgPossessionAway).toFixed(0)}%`);
                    
                    const style2 = avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50;
                    if (style2) details.push(`âœ“ Styl 2: Ataki â‰¥ 50+50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`âœ— Styl 2: Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    const style3 = avgShotsHome > 14 || avgShotsAway > 14;
                    if (style3) details.push(`âœ“ Styl 3: StrzaÅ‚y > 14 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                    else details.push(`âœ— Styl 3: StrzaÅ‚y = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('âœ“') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (primaryModel === 4) {
                    // Model 4: 4 czynniki >= 2
                    const factors = calculateModel4Qualifies(avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, minCornersHome, minCornersAway);
                    scoreText = `Czynniki: ${factors}/3`;
                    
                    const details = [];
                    const possDiff = Math.abs(avgPossessionHome - avgPossessionAway);
                    if (possDiff >= 10) details.push(`âœ“ RÃ³Å¼nica posiadania â‰¥ 10% (${possDiff.toFixed(0)}%)`);
                    else details.push(`âœ— RÃ³Å¼nica posiadania = ${possDiff.toFixed(0)}%`);
                    
                    if (avgDangerousAttacksHome >= 50 || avgDangerousAttacksAway >= 50) details.push(`âœ“ Ataki â‰¥ 50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                    else details.push(`âœ— Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
                    
                    const factor3 = (avgPossessionHome < 45 && minCornersAway >= 6) || (avgPossessionAway < 45 && minCornersHome >= 6);
                    if (factor3) details.push(`âœ“ Niskie posiadanie + min roÅ¼ne â‰¥ 6 (${avgPossessionHome.toFixed(0)}%/${minCornersAway} lub ${avgPossessionAway.toFixed(0)}%/${minCornersHome})`);
                    else details.push(`âœ— Niskie posiadanie + min roÅ¼ne (${avgPossessionHome.toFixed(0)}%/${minCornersHome} vs ${avgPossessionAway.toFixed(0)}%/${minCornersAway})`);
                    
                    detailsHTML = details.map(d => {
                        const color = d.startsWith('âœ“') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (primaryModel === 5) {
                    // Model 5: WEIGHTED >= 8.0
                    const model5Score = calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, avgDangerousAttacksHome, avgDangerousAttacksAway, avgPossessionHome, avgPossessionAway, avgShotsHome, avgShotsAway, avgCornersHome, avgCornersAway, minCornersHome, minCornersAway);
                    scoreText = `Punkty: ${model5Score.toFixed(2)}`;
                    
                    const details = [];
                    details.push(`Predicted avg corners: ${predictedAvgCorners.toFixed(1)}`);
                    details.push(`Model 1 Score: ${score}/9`);
                    details.push(`Min Over 9.5%: ${Math.min(homePercent, awayPercent).toFixed(1)}%`);
                    details.push(`Åšr atakÃ³w: ${((avgDangerousAttacksHome + avgDangerousAttacksAway) / 2).toFixed(1)}`);
                    details.push(`Styl gry: ${((avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45) || (avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) || (avgShotsHome > 14 || avgShotsAway > 14)) ? 'Tak' : 'Nie'}`);
                    details.push(`Åšr roÅ¼ne: ${avgCornersHome.toFixed(1)} | ${avgCornersAway.toFixed(1)}`);
                    details.push(`Min roÅ¼ne: ${minCornersHome} | ${minCornersAway}`);
                    
                    detailsHTML = details.map(d => {
                        return `<p style="color: #FFFFFF; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                } else if (primaryModel === 7) {
                    const model7 = analysis.model7_details || {};
                    const passed = model7.passedCount ?? 0;
                    const total = model7.totalCount ?? (model7.details ? model7.details.length : 0);
                    scoreText = `Model 7 (Premium): ${passed}/${total || 11} warunkÃ³w speÅ‚nionych`;
                    const detailLines = model7.details || [];
                    detailsHTML = detailLines.map(d => {
                        const color = d.startsWith('âœ“') ? '#4CAF50' : '#EF0107';
                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                    }).join('');
                }
                
                return { scoreText, detailsHTML, primaryModel, qualifiedModels };
            };
            
            // Funkcja do generowania HTML dla meczu
            const generateMatchHTML = (item, index) => {
                const { match, league, analysis } = item;
                const basicRequirement = analysis.home_percent >= 50 && analysis.away_percent >= 50;
                const basicText = basicRequirement 
                    ? `âœ“ WYMAGANIE PODSTAWOWE: Oba zespoÅ‚y â‰¥ 50% (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`
                    : `âœ— WYMAGANIE PODSTAWOWE: Oba zespoÅ‚y â‰¥ 50% - NIE SPEÅNIONE (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`;
                
                // SprawdÅº ktÃ³re modele zakwalifikowaÅ‚y mecz
                const modelResults = analysis.model_results || {};
                const model1Qualified = modelResults.model1 ? 'âœ…' : 'âŒ';
                const model2Qualified = modelResults.model2 ? 'âœ…' : 'âŒ';
                const model3Qualified = modelResults.model3 ? 'âœ…' : 'âŒ';
                const model4Qualified = modelResults.model4 ? 'âœ…' : 'âŒ';
                const model5Qualified = modelResults.model5 ? 'âœ…' : 'âŒ';
                const model7Qualified = modelResults.model7 ? 'âœ…' : 'âŒ';
                
                // Wygeneruj szczegÃ³Å‚y dla modelu, ktÃ³ry zakwalifikowaÅ‚ mecz
                const { scoreText, detailsHTML, primaryModel, qualifiedModels } = generateModelDetails(analysis, modelResults);
                const modelsForDisplay = (item.qualified_models && item.qualified_models.length) ? item.qualified_models : qualifiedModels;
                const primaryModelResolved = modelsForDisplay.length ? modelsForDisplay[0] : (primaryModel || 1);
                const primaryModelLabel = formatModelLabel(primaryModelResolved);
                const qualifiedModelsLabel = modelsForDisplay.length ? modelsForDisplay.map(formatModelLabel).join(', ') : primaryModelLabel;
                
                return `
                    <div class="card" style="margin-bottom: 20px; cursor: pointer;" onclick="showMatchDetailsByIndex(${index})">
                        <div class="card-header">
                            ðŸ† ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                                <span style="font-size: 0.7em; color: #EF0107; margin-left: 10px;">ðŸ‘† Kliknij aby zobaczyÄ‡ szczegÃ³Å‚y</span>
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                <p style="color: #EF0107; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    ${scoreText}
                                </p>
                            </div>
                            
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(239, 1, 7, 0.1); border-radius: 8px; border-left: 3px solid #EF0107;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold; font-size: 0.95em;">Wyniki wszystkich modeli:</p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 8px; font-size: 0.9em;">
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 1 (Score >= 7): ${model1Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 2 (Punktowy >= 9): ${model2Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 3 (JakoÅ›ciowy): ${model3Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0;">Model 4 (4 czynniki >= 2): ${model4Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0; grid-column: 1 / -1;">Model 5 WEIGHTED (prÃ³g 8.0): ${model5Qualified}</p>
                                    <p style="color: #FFFFFF; margin: 3px 0; grid-column: 1 / -1;">Model 7 (Premium): ${model7Qualified}</p>
                                </div>
                                ${modelsForDisplay.length ? `<p style="color: #4CAF50; margin-top: 8px; font-weight: bold; font-size: 0.9em;">âœ… Zakwalifikowany przez: ${qualifiedModelsLabel}</p>` : ''}
                            </div>
                            
                            <div style="margin-top: 15px;">
                                <p style="color: ${basicRequirement ? '#4CAF50' : '#EF0107'}; margin: 5px 0;">
                                    ${basicText}
                                </p>
                                <p style="color: #FFFFFF; margin-top: 10px; font-weight: bold;">SzczegÃ³Å‚y wymagaÅ„ (${primaryModelLabel}):</p>
                                ${detailsHTML}
                            </div>
                        </div>
                    </div>
                `;
            };
            
            // Zapisz wszystkie mecze do wyÅ›wietlenia w globalnej zmiennej
            window.allDisplayedMatches = [...leftColumn, ...rightColumn];
            
            // Lewa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            leftColumn.forEach((item, idx) => {
                html += generateMatchHTML(item, idx);
            });
            html += '</div>';
            
            // Prawa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            rightColumn.forEach((item, idx) => {
                html += generateMatchHTML(item, leftColumn.length + idx);
            });
            html += '</div>';
            
            html += '</div>';
            
            content.innerHTML = html;
        }

        // WymuÅ› ponownÄ… analizÄ™ (ignoruj cache)
        async function forceReanalyze() {
            showLoading(true);
            displayMessage('ðŸ”„ Wymuszam ponownÄ… analizÄ™...', 'info');
            
            lastAnalysisHash = null;
            analyzedMatches = [];
            allAnalyzedMatches = [];
            localStorage.removeItem('lastAnalysis');
            localStorage.removeItem('lastAnalysisAll');
            localStorage.removeItem('lastAnalysisHash');
            
            // WywoÅ‚aj analyzeOver95 z flagÄ… forceReanalyze = true
            await analyzeOver95(false, true);
        }

        // Weryfikuj wyniki meczÃ³w w historii
        async function verifyHistoryResults(silent = false) {
            const savedHistory = localStorage.getItem('over95_history');
            if (!savedHistory) {
                if (!silent) {
                displayMessage('Brak historii do weryfikacji', 'warning');
                }
                return;
            }
            
            if (!silent) {
            showLoading(true);
            displayMessage('Weryfikowanie wynikÃ³w meczÃ³w...', 'info');
            }
            
            try {
                let history = JSON.parse(savedHistory);
                let verifiedCount = 0;
                let updatedCount = 0;
                
                // ZnajdÅº mecze ktÃ³re wymagajÄ… weryfikacji (status pending)
                const pendingMatches = history.filter(m => m.status === 'pending' || m.result === 'pending');
                
                if (pendingMatches.length === 0) {
                    if (!silent) {
                    showLoading(false);
                    displayMessage('Wszystkie mecze sÄ… juÅ¼ zweryfikowane', 'info');
                    }
                    return;
                }
                
                if (!silent) {
                displayMessage(`Weryfikowanie ${pendingMatches.length} meczÃ³w...`, 'info');
                }
                
                for (let i = 0; i < pendingMatches.length; i++) {
                    const match = pendingMatches[i];
                    const matchId = match.api_match_id;
                    
                    if (!matchId) {
                        
                        continue;
                    }
                    
                    try {
                        // Pobierz dane meczu z API
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        if (!data.success || !data.data) continue;
                        
                        const matchData = data.data;
                        const status = matchData.status;
                        
                        // SprawdÅº czy mecz siÄ™ zakoÅ„czyÅ‚
                        if (status === 'complete') {
                            const totalCorners = matchData.totalCornerCount || 0;
                            const expectedCorners = 9.5;
                            
                            // Aktualizuj status w historii
                            const historyIndex = history.findIndex(h => 
                                h.api_match_id === matchId || 
                                (h.match_id === match.match_id)
                            );
                            
                            if (historyIndex !== -1) {
                                const result = totalCorners > expectedCorners ? 'won' : 'lost';
                                history[historyIndex].status = 'verified';
                                history[historyIndex].result = result;
                                history[historyIndex].actual_corners = totalCorners;
                                history[historyIndex].match = matchData;
                                updatedCount++;
                                console.log(`âœ“ Zaktualizowano ${match.home_name} vs ${match.away_name}: ${result} (${totalCorners} roÅ¼nych)`);
                            }
                        }
                        
                        verifiedCount++;
                        
                        // OpÃ³Åºnienie miÄ™dzy requestami
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`BÅ‚Ä…d weryfikacji meczu ${match.home_name} vs ${match.away_name}:`, error);
                    }
                }
                
                // Zapisz zaktualizowanÄ… historiÄ™
                if (updatedCount > 0) {
                    const saveResult = saveHistoryWithQuotaProtection(history);
                    history = saveResult.history;
                    if (!saveResult.saved) {
                        if (!silent) {
                        displayMessage('âš ï¸ Nie udaÅ‚o siÄ™ zapisaÄ‡ peÅ‚nej historii â€“ pamiÄ™Ä‡ lokalna jest zapeÅ‚niona.', 'error');
                        }
                        console.warn('âš ï¸ Nie udaÅ‚o siÄ™ zapisaÄ‡ historii over95_history (QuotaExceeded). RozwaÅ¼ rÄ™czne wyczyszczenie starszych danych.');
                    } else {
                        if (saveResult.removed > 0) {
                            
                            if (!silent) {
                            displayMessage(`âœ‚ï¸ Historia zostaÅ‚a skrÃ³cona (usuniÄ™to ${saveResult.removed} najstarszych meczÃ³w)`, 'warning');
                            }
                        }
                        if (!silent) {
                        displayMessage(`âœ“ Zaktualizowano ${updatedCount} meczÃ³w w historii`, 'success');
                        // OdÅ›wieÅ¼ wyÅ›wietlanie historii
                        showHistory();
                    } else {
                            
                        }
                    }
                } else {
                    if (!silent) {
                    displayMessage('Brak meczÃ³w do aktualizacji', 'info');
                    }
                }
                
                if (!silent) {
                showLoading(false);
                }

                await exportYesterdayProfitReport({
                    stake: 5,
                    format: 'csv',
                    autoDownload: true,
                    fetchMissingOdds: true,
                    skipIfAlreadyExported: false,
                    logSummary: !silent
                });
            } catch (error) {
                if (!silent) {
                showLoading(false);
                displayMessage('BÅ‚Ä…d podczas weryfikacji: ' + error.message, 'error');
                }
                console.error('BÅ‚Ä…d podczas weryfikacji:', error);
            }
        }
        
        // Automatyczna weryfikacja przy pierwszym uruchomieniu w nowym dniu
        async function autoVerifyOnNewDay() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const lastVerifyDate = localStorage.getItem('lastAutoVerifyDate');
                
                // JeÅ›li to pierwsze uruchomienie w nowym dniu, zweryfikuj automatycznie
                if (lastVerifyDate !== today) {
                    const savedHistory = localStorage.getItem('over95_history');
                    if (savedHistory) {
                        const history = JSON.parse(savedHistory);
                        const pendingMatches = history.filter(m => m.status === 'pending' || m.result === 'pending');
                        
                        if (pendingMatches.length > 0) {
                            console.log(`ðŸ”„ [AUTO-VERIFY] Automatyczna weryfikacja wynikÃ³w (${pendingMatches.length} meczÃ³w oczekujÄ…cych)...`);
                            // WywoÅ‚aj weryfikacjÄ™ w trybie cichym (bez wyÅ›wietlania komunikatÃ³w)
                            await verifyHistoryResults(true);
                            // Zapisz datÄ™ ostatniej weryfikacji
                            localStorage.setItem('lastAutoVerifyDate', today);
                            
                        }
                    }
                }
            } catch (error) {
                console.error('BÅ‚Ä…d podczas automatycznej weryfikacji:', error);
            }
        }

        // Show history
        function showHistory() {
            const savedHistory = localStorage.getItem('over95_history');
            const content = document.getElementById('history-content');
            
            if (!savedHistory) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center; padding: 40px;">
                            ðŸ“‹ Brak historii meczÃ³w.<br>
                            <span style="color: rgba(255,255,255,0.7); font-size: 0.9em;">
                                Po analizie i zapisaniu meczÃ³w, pojawiÄ… siÄ™ tutaj.
                            </span>
                        </p>
                    </div>
                `;
            } else {
                try {
                    const historyRaw = JSON.parse(savedHistory);
                    const totalHistoryCount = historyRaw.length;
                    
                    const extractQualifiedModels = (entry) => {
                        const normalizeModels = (models) => models
                            .map(m => parseInt(m, 10))
                            .filter(n => !Number.isNaN(n));
                        
                        if (entry?.qualified_models?.length) return normalizeModels(entry.qualified_models);
                        if (entry?.qualified_model !== undefined && entry?.qualified_model !== null) return normalizeModels([entry.qualified_model]);
                        if (entry?.analysis?.model_results) return determineQualifiedModels(entry.analysis.model_results);
                        return [];
                    };
                    
                    const selectedModel = historyModelFilter === 'all' ? null : parseInt(historyModelFilter, 10);
                    
                    const history = historyRaw.filter(entry => {
                        if (selectedModel === null || Number.isNaN(selectedModel)) return true;
                        const models = extractQualifiedModels(entry);
                        return models.includes(selectedModel);
                    });
                    
                    if (history.length === 0) {
                        const filterLabel = selectedModel === null ? 'wszystkie modele' : `Model ${selectedModel}`;
                        content.innerHTML = `
                            <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                                    <div>
                                        <h3 style="color: #EF0107; margin-bottom: 10px;">ðŸ“œ Historia analizowanych meczÃ³w</h3>
                                        <p style="color: #FFFFFF;">Brak meczÃ³w speÅ‚niajÄ…cych filtr: ${filterLabel}.</p>
                                        <p style="color: rgba(255,255,255,0.7); font-size: 0.9em;">Zapisanych meczÃ³w Å‚Ä…cznie: ${totalHistoryCount}</p>
                                    </div>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                        <select id="historyModelFilter" onchange="setHistoryModelFilter(this.value)" style="
                                            padding: 10px 15px;
                                            font-size: 14px;
                                            border-radius: 5px;
                                            background: rgba(255, 255, 255, 0.1);
                                            color: #FFFFFF;
                                            border: 1px solid rgba(255, 255, 255, 0.3);
                                            cursor: pointer;
                                        ">
                                            <option value="all" ${historyModelFilter === 'all' ? 'selected' : ''}>Filtr: Wszystkie modele</option>
                                            <option value="1" ${historyModelFilter === '1' ? 'selected' : ''}>Model 1</option>
                                            <option value="2" ${historyModelFilter === '2' ? 'selected' : ''}>Model 2</option>
                                            <option value="3" ${historyModelFilter === '3' ? 'selected' : ''}>Model 3</option>
                                            <option value="4" ${historyModelFilter === '4' ? 'selected' : ''}>Model 4</option>
                                        <option value="5" ${historyModelFilter === '5' ? 'selected' : ''}>Model 5</option>
                                            <option value="7" ${historyModelFilter === '7' ? 'selected' : ''}>Model 7 (Premium)</option>
                                        </select>
                                        <button onclick="verifyHistoryResults()" class="btn btn-secondary" style="
                                            padding: 12px 24px;
                                            font-size: 16px;
                                            white-space: nowrap;
                                        ">ðŸ”„ Weryfikuj Wyniki</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        return;
                    }
                    
                        history.sort((a, b) => {
                            const dateA = a.date_unix || a.match?.date_unix || 0;
                            const dateB = b.date_unix || b.match?.date_unix || 0;
                            return dateB - dateA;
                        });
                    
                    const matchesByDate = {};
                    history.forEach(match => {
                        const dateUnix = match.date_unix || match.match?.date_unix || 0;
                        if (dateUnix) {
                            const date = new Date(dateUnix * 1000);
                            const dateStr = date.toLocaleDateString('pl-PL', { 
                                year: 'numeric', 
                                month: 'long', 
                                day: 'numeric' 
                            });
                            
                            if (!matchesByDate[dateStr]) {
                                matchesByDate[dateStr] = [];
                            }
                            matchesByDate[dateStr].push(match);
                        }
                    });
                    
                    const sortedDates = Object.keys(matchesByDate).sort((a, b) => {
                        const dateA = matchesByDate[a][0].date_unix || matchesByDate[a][0].match?.date_unix || 0;
                        const dateB = matchesByDate[b][0].date_unix || matchesByDate[b][0].match?.date_unix || 0;
                        return dateB - dateA; // Najnowsze pierwsze (malejÄ…co)
                    });
                    
                    const filterLabel = selectedModel === null ? 'wszystkie modele' : `Model ${selectedModel}`;
                    
                    let html = `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                                <div>
                                    <h3 style="color: #EF0107; margin-bottom: 10px;">ðŸ“œ Historia analizowanych meczÃ³w</h3>
                                    <p style="color: #FFFFFF;">ÅÄ…cznie: ${history.length} meczÃ³w w historii</p>
                                </div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <select id="historyModelFilter" onchange="setHistoryModelFilter(this.value)" style="
                                        padding: 10px 15px;
                                        font-size: 14px;
                                    border-radius: 5px;
                                        background: rgba(255, 255, 255, 0.1);
                                        color: #FFFFFF;
                                        border: 1px solid rgba(255, 255, 255, 0.3);
                                    cursor: pointer;
                                    ">
                                        <option value="all" ${historyModelFilter === 'all' ? 'selected' : ''}>Filtr: Wszystkie modele</option>
                                        <option value="1" ${historyModelFilter === '1' ? 'selected' : ''}>Model 1</option>
                                        <option value="2" ${historyModelFilter === '2' ? 'selected' : ''}>Model 2</option>
                                        <option value="3" ${historyModelFilter === '3' ? 'selected' : ''}>Model 3</option>
                                        <option value="4" ${historyModelFilter === '4' ? 'selected' : ''}>Model 4</option>
                                        <option value="5" ${historyModelFilter === '5' ? 'selected' : ''}>Model 5</option>
                                        <option value="7" ${historyModelFilter === '7' ? 'selected' : ''}>Model 7 (Premium)</option>
                                    </select>
                                    <button onclick="verifyHistoryResults()" class="btn btn-secondary" style="
                                        padding: 12px 24px;
                                        font-size: 16px;
                                        white-space: nowrap;
                                ">ðŸ”„ Weryfikuj Wyniki</button>
                                </div>
                            </div>
                            <p style="color: rgba(255,255,255,0.7); font-size: 0.9em; margin-top: 10px;">Aktualny filtr: ${filterLabel}. WyÅ›wietlane mecze: ${history.length} (z ${totalHistoryCount} zapisanych).</p>
                        </div>
                    `;
                    
                    sortedDates.forEach(dateStr => {
                        const matches = matchesByDate[dateStr];
                        
                            matches.sort((a, b) => {
                                const dateA = a.date_unix || a.match?.date_unix || 0;
                                const dateB = b.date_unix || b.match?.date_unix || 0;
                                return dateB - dateA; // Najnowsze pierwsze
                            });
                        
                        const resolveResult = (entry) => {
                            if (entry?.result && ['won', 'lost'].includes(entry.result)) return entry.result;
                            if (entry?.status && ['won', 'lost'].includes(entry.status)) return entry.status;
                            return 'pending';
                        };
                        
                        const wins = matches.filter(match => resolveResult(match) === 'won').length;
                        const losses = matches.filter(match => resolveResult(match) === 'lost').length;
                        const pending = matches.filter(match => resolveResult(match) === 'pending').length;
                        const concluded = wins + losses;
                        const successRate = concluded > 0 ? ((wins / concluded) * 100).toFixed(2) : '0.00';
                        const summaryParts = [
                            `Wygrane: <strong>${wins}</strong>`,
                            `Przegrane: <strong>${losses}</strong>`
                        ];
                        if (pending > 0) {
                            summaryParts.push(`Oczekuje: <strong>${pending}</strong>`);
                        }
                        summaryParts.push(`SkutecznoÅ›Ä‡: <strong>${concluded > 0 ? `${successRate}%` : 'â€”'}</strong>`);
                        
                        html += `
                                <div class="card" style="margin-bottom: 20px;">
                                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                                    <span>ðŸ“… ${dateStr} (${matches.length} ${matches.length === 1 ? 'mecz' : 'meczÃ³w'})</span>
                                    <span style="font-size: 0.9em; color: #FFFFFF;">
                                        ${summaryParts.join(' | ')}
                                    </span>
                                </div>
                                <div style="padding: 15px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        `;
                        
                        // Podziel mecze naprzemiennie miÄ™dzy kolumny
                        const leftColumn = [];
                        const rightColumn = [];
                        
                        matches.forEach((match, matchIdx) => {
                            if (matchIdx % 2 === 0) {
                                leftColumn.push({ match, matchIdx });
                            } else {
                                rightColumn.push({ match, matchIdx });
                            }
                        });
                        
                        // Funkcja do generowania HTML dla meczu
                        const generateMatchHTML = (match, matchIdx) => {
                            const matchData = match.match || match;
                            const homeName = match.home_name || matchData.home_name || 'N/A';
                            const awayName = match.away_name || matchData.away_name || 'N/A';
                            const league = match.league || match.league_name || matchData.competition_id || 'N/A';
                            const status = resolveResult(match);
                            const actualCorners = match.actual_corners || matchData.totalCornerCount || '-';
                            const score = match.score || match.analysis?.score || 0;
                            
                            const qualifiedModels = extractQualifiedModels(match);
                            const primaryModel = qualifiedModels.length ? qualifiedModels[0] : null;
                            const modelBadgeText = qualifiedModels.length ? qualifiedModels.map(n => `M-${n}`).join(', ') : '';
                            const modelBadge = modelBadgeText ? `<span style="display: none;">${modelBadgeText}</span>` : '';
                            
                            let statusBadge = '';
                            let statusColor = '#FF9800';
                            if (status === 'won') {
                                statusBadge = '<span class="badge badge-success" style="display: block; width: 100%; text-align: center; box-sizing: border-box;">âœ… WygraÅ‚</span>';
                                statusColor = '#4CAF50';
                            } else if (status === 'lost') {
                                statusBadge = '<span class="badge badge-danger" style="display: block; width: 100%; text-align: center; box-sizing: border-box;">âŒ PrzegraÅ‚</span>';
                                statusColor = '#EF0107';
                            } else {
                                statusBadge = '<span class="badge badge-warning" style="display: block; width: 100%; text-align: center; box-sizing: border-box;">â³ Oczekuje</span>';
                            }
                            
                            const matchId = `history_${dateStr.replace(/\s+/g, '_')}_${matchIdx}`;
                            window[matchId] = match; // Zapisz match w globalnym scope
                            
                            // WyÅ›wietl roÅ¼ne - jeÅ›li mecz oczekuje, pokaÅ¼ klepsydrÄ™ zamiast -1
                            let cornersDisplay = actualCorners;
                            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                                cornersDisplay = 'â³';
                            }
                            
                            return `
                                <div class="match-item" style="border-left-color: ${statusColor}; margin-bottom: 15px;" data-model="${primaryModel || 0}" data-score="${score}">
                                    <div style="display: grid; grid-template-columns: 1fr 150px; align-items: flex-start; gap: 15px;">
                                        <div>
                                            <div class="match-teams">${homeName} vs ${awayName} ${modelBadge}</div>
                                            <div class="match-league">${league}</div>
                                            <div style="margin-top: 10px;">
                                                <span style="color: #FFFFFF;">
                                                    Score: <strong>${score}/9</strong> | RzutÃ³w roÅ¼nych: <strong>${cornersDisplay}</strong>
                                                </span>
                                            </div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; align-items: stretch; gap: 10px; width: 150px; justify-self: end;">
                                            ${statusBadge}
                                            <button onclick="showMatchHistoryDetails(window['${matchId}'])" class="btn btn-secondary" style="
                                                padding: 12px 24px;
                                                font-size: 14px;
                                                white-space: nowrap;
                                                width: 100%;
                                        ">ðŸ” SzczegÃ³Å‚y</button>
                                        </div>
                                    </div>
                                </div>
                            `;
                        };
                        
                        // Lewa kolumna
                        html += '<div style="display: flex; flex-direction: column;">';
                        leftColumn.forEach(({ match, matchIdx }) => {
                            html += generateMatchHTML(match, matchIdx);
                        });
                        html += '</div>';
                        
                        // Prawa kolumna
                        html += '<div style="display: flex; flex-direction: column;">';
                        rightColumn.forEach(({ match, matchIdx }) => {
                            html += generateMatchHTML(match, matchIdx);
                        });
                        html += '</div>';
                        
                        html += `
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    content.innerHTML = html;
                } catch (e) {
                    console.error('BÅ‚Ä…d odczytu historii:', e);
                    content.innerHTML = `
                        <div class="card">
                            <p style="color: #EF0107; text-align: center; padding: 40px;">
                                âŒ BÅ‚Ä…d odczytu historii: ${e.message}
                            </p>
                        </div>
                    `;
                }
            }
            
            openModal('historyModal');
        }

        // PokaÅ¼ szczegÃ³Å‚y meczu z historii z porÃ³wnaniem predykcji vs rzeczywistoÅ›Ä‡
        async function showMatchHistoryDetails(match) {
            if (!match) {
                displayMessage('BÅ‚Ä…d: brak danych meczu', 'error');
                return;
            }
            
            const matchData = match.match || match;
            const homeName = match.home_name || matchData.home_name || 'N/A';
            const awayName = match.away_name || matchData.away_name || 'N/A';
            const league = match.league || match.league_name || 'N/A';
            const status = match.result || match.status || 'pending';
            let actualCorners = match.actual_corners || matchData.totalCornerCount;
            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                actualCorners = 'â³';
            }
            const score = match.score || match.analysis?.score || 0;
            const categories = match.categories || match.analysis?.categories || [];
            const percentSum = match.percent_sum || match.analysis?.percent_sum || 0;
            
            // Dane przed meczem (predykcja)
            const homeStats = match.home_stats || match.analysis?.home_stats || {};
            const awayStats = match.away_stats || match.analysis?.away_stats || {};
            
            const qualifiedModelsHistory = (match.qualified_models && match.qualified_models.length)
                ? match.qualified_models
                : (match.qualified_model ? [match.qualified_model] : determineQualifiedModels(match.analysis?.model_results || match.model_results || {}));
            const qualifiedModelsHistoryLabel = qualifiedModelsHistory.length
                ? qualifiedModelsHistory.map(formatModelLabel).join(', ')
                : 'Brak danych';
            
            // Pobierz dane rzeczywiste z API jeÅ›li mecz siÄ™ zakoÅ„czyÅ‚
            let actualMatchData = null;
            if (status === 'won' || status === 'lost' || status === 'verified') {
                const matchId = match.api_match_id || matchData.id;
                if (matchId) {
                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                actualMatchData = data.data;
                            }
                        }
                    } catch (error) {
                        console.error('BÅ‚Ä…d pobierania danych meczu:', error);
                    }
                }
            }
            
            let statusText = '';
            let statusColor = '#FF9800';
            if (status === 'won') {
                statusText = 'âœ… WygraÅ‚';
                statusColor = '#4CAF50';
            } else if (status === 'lost') {
                statusText = 'âŒ PrzegraÅ‚';
                statusColor = '#EF0107';
            } else {
                statusText = 'â³ Oczekuje';
            }
            
            // PorÃ³wnanie predykcji vs rzeczywistoÅ›Ä‡
            let comparisonHTML = '';
            if (actualMatchData && (status === 'won' || status === 'lost' || status === 'verified')) {
                const actualTotalCorners = actualMatchData.totalCornerCount || 0;
                const actualHomeCorners = actualMatchData.team_a_corners || 0;
                const actualAwayCorners = actualMatchData.team_b_corners || 0;
                const actualShotsHome = actualMatchData.team_a_shots || 0;
                const actualShotsAway = actualMatchData.team_b_shots || 0;
                const actualPossessionHome = actualMatchData.team_a_possession || 0;
                const actualPossessionAway = actualMatchData.team_b_possession || 0;
                const actualDangerousAttacksHome = actualMatchData.team_a_dangerous_attacks || 0;
                const actualDangerousAttacksAway = actualMatchData.team_b_dangerous_attacks || 0;
                
                // Åšrednie przed meczem
                const predictedShotsHome = homeStats?.avg_shots || 0;
                const predictedShotsAway = awayStats?.avg_shots || 0;
                const predictedPossessionHome = homeStats?.avg_possession || 0;
                const predictedPossessionAway = awayStats?.avg_possession || 0;
                const predictedDangerousAttacksHome = homeStats?.avg_dangerous_attacks || 0;
                const predictedDangerousAttacksAway = awayStats?.avg_dangerous_attacks || 0;
                
                // Åšrednia Å‚Ä…cznych roÅ¼nych przed meczem
                const homeRecent = homeStats?.recent_matches || [];
                const awayRecent = awayStats?.recent_matches || [];
                const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
                const predictedAvgTotalCornersHome = homeValidCorners.length > 0 
                    ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length 
                    : 0;
                const predictedAvgTotalCornersAway = awayValidCorners.length > 0 
                    ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length 
                    : 0;
                const predictedAvgTotalCorners = (predictedAvgTotalCornersHome + predictedAvgTotalCornersAway) / 2;
                
                comparisonHTML = `
                    <div class="card" style="margin-top: 20px; border: 2px solid #EF0107;">
                        <div class="card-header" style="background: rgba(239, 1, 7, 0.3);">
                            ðŸ“Š PorÃ³wnanie: Predykcja vs RzeczywistoÅ›Ä‡
                        </div>
                        <div style="padding: 20px;">
                            <h4 style="color: #EF0107; margin-bottom: 15px;">RzutÃ³w roÅ¼nych</h4>
                            <table style="width: 100%; color: #FFFFFF; margin-bottom: 20px;">
                                <tr>
                                    <td><strong>Przed meczem (Å›rednia):</strong></td>
                                    <td style="text-align: right;">${predictedAvgTotalCorners.toFixed(1)}</td>
                                </tr>
                                <tr>
                                    <td><strong>Rzeczywiste:</strong></td>
                                    <td style="text-align: right; color: ${actualTotalCorners > 9.5 ? '#4CAF50' : '#EF0107'}; font-weight: bold;">${actualTotalCorners}</td>
                                </tr>
                                <tr>
                                    <td><strong>RÃ³Å¼nica:</strong></td>
                                    <td style="text-align: right; color: ${(actualTotalCorners - predictedAvgTotalCorners) >= 0 ? '#4CAF50' : '#EF0107'};">
                                        ${(actualTotalCorners - predictedAvgTotalCorners) >= 0 ? '+' : ''}${(actualTotalCorners - predictedAvgTotalCorners).toFixed(1)}
                                    </td>
                                </tr>
                            </table>
                            
                            <h4 style="color: #EF0107; margin-bottom: 15px; margin-top: 20px;">SzczegÃ³Å‚y roÅ¼nych</h4>
                            <table style="width: 100%; color: #FFFFFF; margin-bottom: 20px;">
                                <tr>
                                    <td><strong>${homeName}:</strong></td>
                                    <td style="text-align: right;">${actualHomeCorners}</td>
                                </tr>
                                <tr>
                                    <td><strong>${awayName}:</strong></td>
                                    <td style="text-align: right;">${actualAwayCorners}</td>
                                </tr>
                            </table>
                            
                            <h4 style="color: #EF0107; margin-bottom: 15px; margin-top: 20px;">Inne statystyki</h4>
                            <table style="width: 100%; color: #FFFFFF; font-size: 0.9em;">
                                <tr>
                                    <td><strong>StrzaÅ‚y (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedShotsHome.toFixed(1)} â†’ <strong>${actualShotsHome}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>StrzaÅ‚y (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedShotsAway.toFixed(1)} â†’ <strong>${actualShotsAway}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Posiadanie (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedPossessionHome.toFixed(0)}% â†’ <strong>${actualPossessionHome}%</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Posiadanie (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedPossessionAway.toFixed(0)}% â†’ <strong>${actualPossessionAway}%</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Ataki (${homeName}):</strong></td>
                                    <td style="text-align: right;">${predictedDangerousAttacksHome.toFixed(1)} â†’ <strong>${actualDangerousAttacksHome}</strong></td>
                                </tr>
                                <tr>
                                    <td><strong>Ataki (${awayName}):</strong></td>
                                    <td style="text-align: right;">${predictedDangerousAttacksAway.toFixed(1)} â†’ <strong>${actualDangerousAttacksAway}</strong></td>
                                </tr>
                            </table>
                            
                            ${actualTotalCorners <= 9.5 && score >= 7 ? `
                                <div style="margin-top: 20px; padding: 15px; background: rgba(255, 152, 0, 0.2); border-left: 4px solid #FF9800; border-radius: 5px;">
                                    <h4 style="color: #FF9800; margin-bottom: 10px;">âš ï¸ Analiza przyczyny przegranej</h4>
                                    <p style="color: #FFFFFF; margin: 5px 0;">â€¢ Score: ${score}/9 (wysokie) ale tylko ${actualTotalCorners} roÅ¼nych</p>
                                    <p style="color: #FFFFFF; margin: 5px 0;">â€¢ Åšrednia przed meczem: ${predictedAvgTotalCorners.toFixed(1)} roÅ¼nych</p>
                                    <p style="color: #FFFFFF; margin: 5px 0;">â€¢ MoÅ¼liwe przyczyny:</p>
                                    <ul style="color: #FFFFFF; margin-left: 20px;">
                                        <li>Taktyka defensywna w tym meczu</li>
                                        <li>Brak agresywnych akcji mimo wysokich statystyk</li>
                                        <li>Warunki pogodowe lub inne czynniki zewnÄ™trzne</li>
                                        <li>Niska jakoÅ›Ä‡ danych historycznych</li>
                                    </ul>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">
                        ${homeName} vs ${awayName}
                    </div>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 20px;">
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Liga:</strong> ${league}</p>
                            <p style="color: ${statusColor}; margin: 5px 0;"><strong>Status:</strong> ${statusText}</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>RzutÃ³w roÅ¼nych:</strong> ${actualCorners}</p>
                            <p style="color: #EF0107; margin: 5px 0; font-size: 1.2em;"><strong>Score:</strong> ${score}/9</p>
                            <p style="color: #4CAF50; margin: 5px 0;"><strong>Zakwalifikowany przez:</strong> ${qualifiedModelsHistoryLabel}</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Suma %:</strong> ${percentSum.toFixed(1)}%</p>
                        </div>
                        
                        ${categories.length > 0 ? `
                            <div style="margin-top: 20px;">
                                <h4 style="color: #FFFFFF; margin-bottom: 10px;">Kryteria przed meczem:</h4>
                                ${categories.map(cat => {
                                    const color = cat.startsWith('âœ“') ? '#4CAF50' : cat.startsWith('âœ—') ? '#EF0107' : '#FFFFFF';
                                    return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
                ${comparisonHTML}
            `;
            
            // UtwÃ³rz nowy modal dla szczegÃ³Å‚Ã³w
            const detailsModal = document.createElement('div');
            detailsModal.className = 'modal';
            detailsModal.id = 'historyDetailsModal';
            detailsModal.innerHTML = `
                <div class="modal-content" style="max-width: 900px;">
                    <span class="close" onclick="closeModal('historyDetailsModal')">&times;</span>
                    <h2 style="color: #EF0107; margin-bottom: 20px;">ðŸ” SzczegÃ³Å‚y meczu</h2>
                    ${html}
                </div>
            `;
            document.body.appendChild(detailsModal);
            // Dodaj event listenery dla blokady scrollowania
            const modalContent = detailsModal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.addEventListener('wheel', function(e) {
                    const { scrollTop, scrollHeight, clientHeight } = this;
                    const isAtTop = scrollTop === 0;
                    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                    
                    if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            detailsModal.style.display = 'block';
            lockBodyScroll();
        }

        // Utility functions
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function displayMessage(message, type = 'info') {
            const colors = {
                'info': '#023474',
                'success': '#4CAF50',
                'error': '#EF0107',
                'warning': '#FF9800'
            };
            
            // UtwÃ³rz kontener dla komunikatÃ³w, jeÅ›li nie istnieje
            let container = document.getElementById('messages-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'messages-container';
                document.body.appendChild(container);
            }
            
            // UtwÃ³rz element komunikatu
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message-item';
            messageDiv.style.cssText = `
                background: ${colors[type]};
                color: #FFFFFF;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                animation: slideIn 0.3s;
                max-width: 400px;
                word-wrap: break-word;
            `;
            messageDiv.textContent = message;
            
            // Dodaj komunikat do kontenera
            container.appendChild(messageDiv);
            
            // UsuÅ„ komunikat po 3 sekundach
            setTimeout(() => {
                messageDiv.style.animation = 'slideOut 0.3s';
                setTimeout(() => {
                    // PÅ‚ynnie zmniejsz wysokoÅ›Ä‡ i padding
                    messageDiv.style.height = messageDiv.offsetHeight + 'px';
                    messageDiv.style.overflow = 'hidden';
                    messageDiv.offsetHeight; // Force reflow
                    messageDiv.style.height = '0';
                    messageDiv.style.marginTop = '0';
                    messageDiv.style.marginBottom = '0';
                    messageDiv.style.paddingTop = '0';
                    messageDiv.style.paddingBottom = '0';
                    messageDiv.style.opacity = '0';
                    
                    // Po zakoÅ„czeniu animacji usuÅ„ element
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                        // JeÅ›li kontener jest pusty, usuÅ„ go
                        if (container.children.length === 0) {
                            container.remove();
                        }
                    }, 300);
                }, 300);
            }, 3000);
        }

        // Blokuj przewijanie strony w tle gdy modal jest otwarty
        function lockBodyScroll() {
            document.body.classList.add('modal-open');
            // Zapisz pozycjÄ™ scrolla
            const scrollY = window.scrollY;
            document.body.style.top = `-${scrollY}px`;
        }

        // Odblokuj przewijanie strony w tle
        function unlockBodyScroll() {
            const scrollY = document.body.style.top;
            document.body.classList.remove('modal-open');
            document.body.style.top = '';
            if (scrollY) {
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                // SprawdÅº czy inne modale sÄ… otwarte
                const openModals = document.querySelectorAll('.modal[style*="block"]');
                if (openModals.length === 0 || (openModals.length === 1 && openModals[0].id === modalId)) {
                    unlockBodyScroll();
                }
            }
        }

        // Global state dla kartek
        let analyzedCardsMatches = [];
        let refereeStats = {}; // Cache statystyk sÄ™dziÃ³w
        let refereeStatsCache = {}; // Cache statystyk sÄ™dziÃ³w z API-Football (referee_name -> avg_cards)

        // Oblicz statystyki sÄ™dziÃ³w z historii meczÃ³w
        function calculateRefereeStats() {
            const savedHistory = localStorage.getItem('over95_history');
            if (!savedHistory) {
                return {};
            }

            try {
                const history = JSON.parse(savedHistory);
                const stats = {};

                history.forEach(match => {
                    const matchData = match.match || {};
                    const refereeId = matchData.refereeID;
                    if (refereeId) {
                        const homeCards = matchData.team_a_cards_num || 0;
                        const awayCards = matchData.team_b_cards_num || 0;
                        const totalCards = homeCards + awayCards;

                        if (!stats[refereeId]) {
                            stats[refereeId] = { totalCards: 0, matches: 0 };
                        }
                        stats[refereeId].totalCards += totalCards;
                        stats[refereeId].matches += 1;
                    }
                });

                // Oblicz Å›rednie
                const avgStats = {};
                for (const [refId, data] of Object.entries(stats)) {
                    if (data.matches >= 3) { // Minimum 3 mecze
                        avgStats[refId] = data.totalCards / data.matches;
                    }
                }

                return avgStats;
            } catch (e) {
                console.error('BÅ‚Ä…d obliczania statystyk sÄ™dziÃ³w:', e);
                return {};
            }
        }

        // Pobierz sÄ™dziego dla meczu z API-Football
        async function getRefereeFromAPIFootball(fixtureId) {
            if (!USE_API_FOOTBALL_REFEREES || !fixtureId) return null;
            
            try {
                // SprawdÅº cache
                const cacheKey = `referee_${fixtureId}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    // Cache waÅ¼ny przez 7 dni
                    if (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000) {
                        return data.referee;
                    }
                }
                
                const response = await fetch(`${API_FOOTBALL_BASE_URL}/fixtures?id=${fixtureId}`, {
                    headers: {
                        'x-apisports-key': API_FOOTBALL_KEY
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.response && data.response.length > 0) {
                        const referee = data.response[0].fixture?.referee;
                        if (referee) {
                            // Cache'uj wynik
                            localStorage.setItem(cacheKey, JSON.stringify({
                                referee: referee,
                                timestamp: Date.now()
                            }));
                            return referee;
                        }
                    }
                }
            } catch (error) {
                console.error(`BÅ‚Ä…d pobierania sÄ™dziego z API-Football dla fixture ${fixtureId}:`, error);
            }
            
            return null;
        }
        
        // Pobierz statystyki sÄ™dziego z API-Football (Å›rednia kartek)
        async function getRefereeStatsFromAPIFootball(refereeName, leagueId = null, season = 2024) {
            if (!USE_API_FOOTBALL_REFEREES || !refereeName) return null;
            
            // SprawdÅº cache
            const cacheKey = `referee_stats_${refereeName}_${leagueId || 'all'}_${season}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                const data = JSON.parse(cached);
                // Cache waÅ¼ny przez 7 dni
                if (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000) {
                    return data.stats;
                }
            }
            
            try {
                // Pobierz mecze sÄ™dziego
                let url = `${API_FOOTBALL_BASE_URL}/fixtures?referee=${encodeURIComponent(refereeName)}&season=${season}`;
                if (leagueId) {
                    url += `&league=${leagueId}`;
                }
                
                const response = await fetch(url, {
                    headers: {
                        'x-apisports-key': API_FOOTBALL_KEY
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.response && data.response.length > 0) {
                        const matches = data.response;
                        let totalCards = 0;
                        let matchesWithStats = 0;
                        
                        // Pobierz statystyki dla kaÅ¼dego meczu (maksymalnie 10, Å¼eby nie przekroczyÄ‡ limitu)
                        for (let i = 0; i < Math.min(matches.length, 10); i++) {
                            const fixtureId = matches[i].fixture?.id;
                            if (!fixtureId) continue;
                            
                            try {
                                const statsResponse = await fetch(`${API_FOOTBALL_BASE_URL}/fixtures/statistics?fixture=${fixtureId}`, {
                                    headers: {
                                        'x-apisports-key': API_FOOTBALL_KEY
                                    }
                                });
                                
                                if (statsResponse.ok) {
                                    const statsData = await statsResponse.json();
                                    if (statsData.response && statsData.response.length > 0) {
                                        // Oblicz kartki z statystyk
                                        let matchCards = 0;
                                        statsData.response.forEach(teamStats => {
                                            const statistics = teamStats.statistics || [];
                                            statistics.forEach(stat => {
                                                if (stat.type === 'Yellow Cards' || stat.type === 'Red Cards') {
                                                    const value = parseInt(stat.value) || 0;
                                                    matchCards += value;
                                                }
                                            });
                                        });
                                        
                                        totalCards += matchCards;
                                        matchesWithStats++;
                                    }
                                }
                                
                                // OpÃ³Åºnienie miÄ™dzy requestami
                                await new Promise(resolve => setTimeout(resolve, 200));
                            } catch (error) {
                                console.error(`BÅ‚Ä…d pobierania statystyk meczu ${fixtureId}:`, error);
                            }
                        }
                        
                        const avgCards = matchesWithStats > 0 ? totalCards / matchesWithStats : 0;
                        const stats = {
                            avgCards: avgCards,
                            totalMatches: matches.length,
                            matchesWithStats: matchesWithStats
                        };
                        
                        // Cache'uj wynik
                        localStorage.setItem(cacheKey, JSON.stringify({
                            stats: stats,
                            timestamp: Date.now()
                        }));
                        
                        return stats;
                    }
                }
            } catch (error) {
                console.error(`BÅ‚Ä…d pobierania statystyk sÄ™dziego ${refereeName} z API-Football:`, error);
            }
            
            return null;
        }
        
        // Analizuj mecz dla kartek (SUPER KOMBINACJA)
        function analyzeMatchForCards(match) {
            const dangerousAttacksHome = match.team_a_dangerous_attacks || 0;
            const dangerousAttacksAway = match.team_b_dangerous_attacks || 0;
            const foulsHome = match.team_a_fouls || 0;
            const foulsAway = match.team_b_fouls || 0;
            const refereeId = match.refereeID;

            // Kryteria SUPER KOMBINACJI:
            // 1. Dangerous Attacks â‰¥55 (co najmniej jedna druÅ¼yna)
            const dangerousAttacksOk = dangerousAttacksHome >= 55 || dangerousAttacksAway >= 55;
            
            // 2. Faule â‰¥12+12 (obie druÅ¼yny)
            const foulsOk = foulsHome >= 12 && foulsAway >= 12;
            
            // 3. SÄ™dzia z Å›redniÄ… kartek â‰¥4.0
            let refereeAvgCards = refereeStats[refereeId] || 0;
            
            // SprÃ³buj pobraÄ‡ statystyki z API-Football (jeÅ›li wÅ‚Ä…czone i brak danych lokalnych)
            if (USE_API_FOOTBALL_REFEREES && refereeAvgCards === 0 && match.referee_name) {
                // SprawdÅº cache
                const cacheKey = `referee_stats_${match.referee_name}_all_2024`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    if (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000) {
                        refereeAvgCards = data.stats?.avgCards || 0;
                    }
                } else {
                    // Pobierz asynchronicznie (nie blokuj analizy)
                    getRefereeStatsFromAPIFootball(match.referee_name, match.competition_id, 2024)
                        .then(stats => {
                            if (stats && stats.avgCards > 0) {
                                // Zaktualizuj cache
                                refereeStatsCache[match.referee_name] = stats.avgCards;
                                // MoÅ¼na teÅ¼ zaktualizowaÄ‡ refereeStats jeÅ›li refereeId pasuje
                            }
                        })
                        .catch(err => console.error('BÅ‚Ä…d pobierania statystyk sÄ™dziego:', err));
                }
            }
            
            // SprawdÅº teÅ¼ cache z API-Football
            if (refereeAvgCards === 0 && match.referee_name && refereeStatsCache[match.referee_name]) {
                refereeAvgCards = refereeStatsCache[match.referee_name];
            }
            
            const refereeOk = refereeAvgCards >= 4.0;

            const qualified = dangerousAttacksOk && foulsOk && refereeOk;

            const categories = [];
            if (dangerousAttacksOk) {
                categories.push(`âœ“ Dangerous Attacks â‰¥55 (${dangerousAttacksHome} | ${dangerousAttacksAway})`);
            } else {
                categories.push(`âœ— Dangerous Attacks <55 (${dangerousAttacksHome} | ${dangerousAttacksAway})`);
            }

            if (foulsOk) {
                categories.push(`âœ“ Faule â‰¥12+12 (${foulsHome} | ${foulsAway})`);
            } else {
                categories.push(`âœ— Faule <12+12 (${foulsHome} | ${foulsAway})`);
            }

            if (refereeOk) {
                categories.push(`âœ“ SÄ™dzia (Å›rednia kartek: ${refereeAvgCards.toFixed(2)})`);
            } else {
                categories.push(`âœ— SÄ™dzia (Å›rednia kartek: ${refereeAvgCards.toFixed(2)} < 4.0)`);
            }

            return {
                qualified,
                categories,
                dangerousAttacksHome,
                dangerousAttacksAway,
                foulsHome,
                foulsAway,
                refereeId,
                refereeAvgCards
            };
        }

        // Oblicz statystyki sÄ™dziÃ³w z WSZYSTKICH meczÃ³w (z historii + dzisiejsze)
        async function calculateRefereeStatsFromAllMatches() {
            const stats = {};
            
            // 1. Dodaj statystyki z historii (jeÅ›li istnieje)
            const savedHistory = localStorage.getItem('over95_history');
            if (savedHistory) {
                try {
                    const history = JSON.parse(savedHistory);
                    history.forEach(match => {
                        const matchData = match.match || {};
                        const refereeId = matchData.refereeID;
                        if (refereeId) {
                            const homeCards = matchData.team_a_cards_num || 0;
                            const awayCards = matchData.team_b_cards_num || 0;
                            const totalCards = homeCards + awayCards;

                            if (!stats[refereeId]) {
                                stats[refereeId] = { totalCards: 0, matches: 0 };
                            }
                            stats[refereeId].totalCards += totalCards;
                            stats[refereeId].matches += 1;
                        }
                    });
                } catch (e) {
                    console.error('BÅ‚Ä…d odczytu historii:', e);
                }
            }
            
            // 2. Dodaj statystyki z dzisiejszych meczÃ³w (pobierz peÅ‚ne dane)
            // To zapewni, Å¼e mamy dane o sÄ™dziach nawet jeÅ›li nie byÅ‚o analizy Over 9.5
            if (matchesData.length > 0) {
                displayMessage('Pobieranie danych o sÄ™dziach z dzisiejszych meczÃ³w...', 'info');
                
                for (const match of matchesData) {
                    const matchId = match.id;
                    if (!matchId) continue;
                    
                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        
                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                const fullMatch = data.data;
                                const refereeId = fullMatch.refereeID;
                                
                                if (refereeId) {
                                    const homeCards = fullMatch.team_a_cards_num || 0;
                                    const awayCards = fullMatch.team_b_cards_num || 0;
                                    const totalCards = homeCards + awayCards;
                                    
                                    // Dodaj tylko jeÅ›li mecz jest zakoÅ„czony (ma kartki)
                                    if (totalCards > 0 || fullMatch.status === 'complete') {
                                        if (!stats[refereeId]) {
                                            stats[refereeId] = { totalCards: 0, matches: 0 };
                                        }
                                        stats[refereeId].totalCards += totalCards;
                                        stats[refereeId].matches += 1;
                                    }
                                    
                                    // 3. Pobierz dane o sÄ™dziu z API-Football (jeÅ›li wÅ‚Ä…czone)
                                    if (USE_API_FOOTBALL_REFEREES) {
                                        // SprÃ³buj znaleÅºÄ‡ fixture_id (moÅ¼e byÄ‡ w match lub trzeba mapowaÄ‡)
                                        // Na razie pomijamy - wymaga mapowania fixture_id
                                        // MoÅ¼na dodaÄ‡ pÃ³Åºniej gdy bÄ™dzie mapowanie
                                    }
                                }
                            }
                        }
                        // KrÃ³tkie opÃ³Åºnienie
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        // Ignoruj bÅ‚Ä™dy - kontynuuj z nastÄ™pnym meczem
                    }
                }
            }
            
            // Oblicz Å›rednie
            const avgStats = {};
            for (const [refId, data] of Object.entries(stats)) {
                if (data.matches >= 3) { // Minimum 3 mecze
                    avgStats[refId] = data.totalCards / data.matches;
                }
            }
            
            // 4. UzupeÅ‚nij statystyki z API-Football (jeÅ›li wÅ‚Ä…czone)
            if (USE_API_FOOTBALL_REFEREES) {
                displayMessage('Pobieranie statystyk sÄ™dziÃ³w z API-Football...', 'info');
                
                // Pobierz unikalne refereeID z dzisiejszych meczÃ³w
                const todayRefereeIds = new Set();
                for (const match of matchesData) {
                    if (match.refereeID) {
                        todayRefereeIds.add(match.refereeID);
                    }
                }
                
                // Dla kaÅ¼dego sÄ™dziego sprÃ³buj pobraÄ‡ statystyki z API-Football
                // UWAGA: Wymaga mapowania refereeID -> referee_name lub fixture_id
                // Na razie pomijamy - moÅ¼na dodaÄ‡ pÃ³Åºniej gdy bÄ™dzie mapowanie
            }
            
            return avgStats;
        }

        // Analizuj wszystkie mecze dla kartek
        async function analyzeCards() {
            if (matchesData.length === 0) {
                displayMessage('Najpierw pobierz mecze!', 'warning');
                return;
            }

            showLoading(true);
            displayMessage('Obliczanie statystyk sÄ™dziÃ³w...', 'info');

            try {
                // Oblicz statystyki sÄ™dziÃ³w z WSZYSTKICH meczÃ³w (historia + dzisiejsze)
                refereeStats = await calculateRefereeStatsFromAllMatches();
                console.log(`ðŸ“Š Obliczono statystyki dla ${Object.keys(refereeStats).length} sÄ™dziÃ³w`);

                // Pobierz nazwy lig
                const leaguesMap = await fetchLeagueNames();

                analyzedCardsMatches = [];
                let processed = 0;
                const total = matchesData.length;

                displayMessage('Analizowanie meczÃ³w dla kartek...', 'info');

                for (const match of matchesData) {
                    processed++;
                    const progress = Math.round((processed / total) * 100);
                    displayMessage(`Analizowanie meczu ${processed}/${total} (${progress}%)...`, 'info');

                    // Pobierz peÅ‚ne dane meczu (potrzebujemy dangerous_attacks i fouls)
                    const matchId = match.id;
                    if (!matchId) continue;

                    try {
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }

                        const response = await fetch(url);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.data) {
                                const fullMatch = data.data;
                                
                                // Analizuj mecz
                                const analysis = analyzeMatchForCards(fullMatch);
                                
                                if (analysis.qualified) {
                                    analyzedCardsMatches.push({
                                        match: fullMatch,
                                        league: leaguesMap[fullMatch.competition_id] || `Liga ID: ${fullMatch.competition_id}`,
                                        analysis,
                                        home_name: fullMatch.home_name || match.home_name,
                                        away_name: fullMatch.away_name || match.away_name,
                                        time: fullMatch.date_unix ? new Date(fullMatch.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-'
                                    });
                                }
                            }
                        }
                        // OpÃ³Åºnienie miÄ™dzy requestami
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`BÅ‚Ä…d pobierania meczu ${matchId}:`, error);
                    }
                }

                showLoading(false);
                displayCardsResults();
                openModal('cardsModal');

                if (analyzedCardsMatches.length > 0) {
                    displayMessage(`âœ“ Znaleziono ${analyzedCardsMatches.length} meczÃ³w kwalifikujÄ…cych siÄ™ do Over 3.5 kartek!`, 'success');
                } else {
                    displayMessage('â„¹ï¸ Nie znaleziono meczÃ³w speÅ‚niajÄ…cych kryteria SUPER KOMBINACJI', 'info');
                }

            } catch (error) {
                showLoading(false);
                console.error('BÅ‚Ä…d analizy kartek:', error);
                displayMessage('BÅ‚Ä…d analizy kartek: ' + error.message, 'error');
            }
        }

        // WyÅ›wietl wyniki analizy kartek
        function displayCardsResults() {
            const content = document.getElementById('cards-content');
            
            if (analyzedCardsMatches.length === 0) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center;">
                            Brak meczÃ³w kwalifikujÄ…cych siÄ™ do Over 3.5 kartek.<br>
                            <strong style="color: #FFA500;">SUPER KOMBINACJA:</strong><br>
                            - Dangerous Attacks â‰¥55 (co najmniej jedna druÅ¼yna)<br>
                            - Faule â‰¥12+12 (obie druÅ¼yny)<br>
                            - SÄ™dzia z Å›redniÄ… kartek â‰¥4.0<br><br>
                            <span style="color: rgba(255,255,255,0.7); font-size: 0.9em;">
                                DokÅ‚adnoÅ›Ä‡: 87.50% (48 meczÃ³w w historii)
                            </span>
                        </p>
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="analyzeCards()" class="btn btn-secondary" style="background: #FFA500; color: #000;">ðŸ”„ Analizuj ponownie</button>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 165, 0, 0.2); border-radius: 10px; border-left: 4px solid #FFA500;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="color: #FFA500; margin-bottom: 10px;">âœ… Znaleziono ${analyzedCardsMatches.length} meczÃ³w kwalifikujÄ…cych siÄ™</h3>
                            <p style="color: #FFFFFF;">SUPER KOMBINACJA: Dangerous Attacks + Faule + SÄ™dzia</p>
                            <p style="color: rgba(255,255,255,0.7); font-size: 0.9em; margin-top: 5px;">
                                DokÅ‚adnoÅ›Ä‡: 87.50% (48 meczÃ³w w historii)
                            </p>
                        </div>
                        <button onclick="analyzeCards()" class="btn btn-secondary" style="background: #FFA500; color: #000; padding: 10px 20px; font-size: 14px;">ðŸ”„ Analizuj ponownie</button>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            `;
            
            // Podziel mecze naprzemiennie miÄ™dzy kolumny
            const leftColumn = [];
            const rightColumn = [];
            
            analyzedCardsMatches.forEach((item, index) => {
                if (index % 2 === 0) {
                    leftColumn.push(item);
                } else {
                    rightColumn.push(item);
                }
            });
            
            // Lewa kolumna
            html += '<div>';
            leftColumn.forEach(item => {
                const { match, league, analysis } = item;
                html += `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header" style="background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);">
                            ðŸ† ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 165, 0, 0.2); border-radius: 8px;">
                                <p style="color: #FFA500; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    âœ… Kwalifikuje siÄ™ do Over 3.5 kartek
                                </p>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold;">Kryteria:</p>
                                ${analysis.categories.map(cat => `
                                    <p style="color: ${cat.startsWith('âœ“') ? '#4CAF50' : '#EF0107'}; margin: 3px 0; font-size: 0.95em;">
                                        ${cat}
                                    </p>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Prawa kolumna
            html += '<div>';
            rightColumn.forEach(item => {
                const { match, league, analysis } = item;
                html += `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header" style="background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);">
                            ðŸ† ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 165, 0, 0.2); border-radius: 8px;">
                                <p style="color: #FFA500; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    âœ… Kwalifikuje siÄ™ do Over 3.5 kartek
                                </p>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <p style="color: #FFFFFF; margin: 5px 0; font-weight: bold;">Kryteria:</p>
                                ${analysis.categories.map(cat => `
                                    <p style="color: ${cat.startsWith('âœ“') ? '#4CAF50' : '#EF0107'}; margin: 3px 0; font-size: 0.95em;">
                                        ${cat}
                                    </p>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            html += '</div>';
            content.innerHTML = html;
        }

        // Funkcja do otwierania modala z blokadÄ… scrollowania
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'block';
                lockBodyScroll();
                
                // Blokuj scroll w modal-content, Å¼eby nie przewijaÅ‚o strony w tle
                // UÅ¼yj flagi, Å¼eby nie duplikowaÄ‡ event listenerÃ³w
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent && !modalContent.dataset.scrollLocked) {
                    modalContent.dataset.scrollLocked = 'true';
                    
                    // Blokuj scroll kÃ³Å‚kiem myszy na granicach
                    modalContent.addEventListener('wheel', function(e) {
                        const { scrollTop, scrollHeight, clientHeight } = this;
                        const isAtTop = scrollTop === 0;
                        const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                        
                        // JeÅ›li jesteÅ›my na gÃ³rze i scrollujemy w gÃ³rÄ™, lub na dole i scrollujemy w dÃ³Å‚, zablokuj
                        if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }, { passive: false });
                    
                    // Blokuj touchmove na granicach (dla urzÄ…dzeÅ„ mobilnych)
                    let lastTouchY = 0;
                    modalContent.addEventListener('touchstart', function(e) {
                        lastTouchY = e.touches[0].clientY;
                    }, { passive: true });
                    
                    modalContent.addEventListener('touchmove', function(e) {
                        const { scrollTop, scrollHeight, clientHeight } = this;
                        const currentTouchY = e.touches[0].clientY;
                        const deltaY = lastTouchY - currentTouchY;
                        
                        const isAtTop = scrollTop === 0;
                        const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                        
                        // JeÅ›li jesteÅ›my na gÃ³rze i przesuwamy w gÃ³rÄ™, lub na dole i przesuwamy w dÃ³Å‚, zablokuj
                        if ((isAtTop && deltaY < 0) || (isAtBottom && deltaY > 0)) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        
                        lastTouchY = currentTouchY;
                    }, { passive: false });
                }
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    closeModal(modal.id || '');
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async function() {
            
            updateAppVersionDisplay();
            ensureYesterdayCache();
            
            // SprÃ³buj zaÅ‚adowaÄ‡ nazwy lig
            await fetchLeagueNames();
            
            // Automatyczna weryfikacja wynikÃ³w przy pierwszym uruchomieniu w nowym dniu
            await autoVerifyOnNewDay();
            
            // SprÃ³buj zaÅ‚adowaÄ‡ dane z localStorage
            const savedMatches = localStorage.getItem('matchesData');
            const savedDate = localStorage.getItem('matchesDate');
            const today = new Date().toISOString().split('T')[0];
            
            if (savedMatches && savedDate === today) {
                try {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj teÅ¼ z cache (na wypadek jeÅ›li byÅ‚y w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('ZaÅ‚adowano dane z cache', 'info');
                } catch (e) {
                    console.error('BÅ‚Ä…d odczytu cache:', e);
                }
            }
            
        });

        function calculateModel7Result(match, homeStats, awayStats) {
            const corners95Potential = match.corners_o95_potential ?? 0;
            const totalXgPre = match.total_xg_prematch ?? 0;
            const homeXgPre = match.team_a_xg_prematch ?? 0;
            const awayXgPre = match.team_b_xg_prematch ?? 0;
            const cornersPotential = match.corners_potential ?? 0;
            const bttsPotential = match.btts_potential ?? 0;

            const homeRecentAvgTotal = homeStats?.recent_avg_total_corners ?? 0;
            const awayRecentAvgTotal = awayStats?.recent_avg_total_corners ?? 0;
            const combinedRecentAvgTotal = (homeRecentAvgTotal + awayRecentAvgTotal) / 2;

            const homeFirst10Rate = homeStats?.recent_corner_first10_rate ?? 0;
            const awayFirst10Rate = awayStats?.recent_corner_first10_rate ?? 0;
            const combinedFirst10Rate = (homeFirst10Rate + awayFirst10Rate) / 2;

            const homeCorners6Rate = homeStats?.recent_team_corners_ge6_rate ?? 0;
            const awayCorners6Rate = awayStats?.recent_team_corners_ge6_rate ?? 0;
            const combinedCorners6Rate = (homeCorners6Rate + awayCorners6Rate) / 2;

            const avgShotsHome = homeStats?.avg_shots ?? 0;
            const avgShotsAway = awayStats?.avg_shots ?? 0;
            const avgShots = (avgShotsHome + avgShotsAway) / 2;

            const details = [];
            const conditions = [];

            conditions.push({
                label: `Corners o95 potential â‰¥ 68 (${corners95Potential.toFixed(0)})`,
                passed: corners95Potential >= 68
            });
            conditions.push({
                label: `Total xG prematch â‰¥ 3.0 (${totalXgPre.toFixed(2)})`,
                passed: totalXgPre >= 3.0
            });
            conditions.push({
                label: `Home xG prematch â‰¥ 1.4 (${homeXgPre.toFixed(2)})`,
                passed: homeXgPre >= 1.4
            });
            conditions.push({
                label: `Away xG prematch â‰¥ 1.3 (${awayXgPre.toFixed(2)})`,
                passed: awayXgPre >= 1.3
            });
            conditions.push({
                label: `Corners potential â‰¥ 12 (${cornersPotential.toFixed(2)})`,
                passed: cornersPotential >= 12
            });
            conditions.push({
                label: `BTTS potential â‰¥ 60 (${bttsPotential.toFixed(0)})`,
                passed: bttsPotential >= 60
            });
            conditions.push({
                label: `Åšr. Å‚Ä…cznych roÅ¼nych (ostatnie mecze) â‰¥ 10.5 (${combinedRecentAvgTotal.toFixed(2)})`,
                passed: combinedRecentAvgTotal >= 10.5
            });
            conditions.push({
                label: `RoÅ¼ne 0-10' (Å‚Ä…czny rate) â‰¥ 0.40 (${combinedFirst10Rate.toFixed(2)})`,
                passed: combinedFirst10Rate >= 0.40
            });
            conditions.push({
                label: `Rate roÅ¼nych â‰¥6 (gospodarz) â‰¥ 0.60 (${homeCorners6Rate.toFixed(2)})`,
                passed: homeCorners6Rate >= 0.60
            });
            conditions.push({
                label: `Rate roÅ¼nych â‰¥6 (goÅ›Ä‡) â‰¥ 0.60 (${awayCorners6Rate.toFixed(2)})`,
                passed: awayCorners6Rate >= 0.60
            });
            conditions.push({
                label: `Åšrednia strzaÅ‚Ã³w obu druÅ¼yn â‰¥ 11 (${avgShots.toFixed(2)}; ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`,
                passed: avgShotsHome >= 11 && avgShotsAway >= 11
            });

            const passedCount = conditions.filter(c => c.passed).length;
            conditions.forEach(cond => {
                details.push(`${cond.passed ? 'âœ“' : 'âœ—'} ${cond.label}`);
            });

            return {
                qualified: passedCount === conditions.length,
                passedCount,
                totalCount: conditions.length,
                details,
                metrics: {
                    avgShots,
                    combinedCorners6Rate,
                    combinedRecentAvgTotal,
                    combinedFirst10Rate
                }
            };
        }

        // Funkcja pomocnicza do wyÅ›wietlania szczegÃ³Å‚Ã³w meczu przez indeks
        function showMatchDetailsByIndex(index) {
            if (window.allDisplayedMatches && window.allDisplayedMatches[index]) {
                showMatchDetails(window.allDisplayedMatches[index]);
            } else {
                displayMessage('BÅ‚Ä…d: Nie znaleziono meczu', 'error');
            }
        }

        // Funkcja do analizy i wyÅ›wietlenia szczegÃ³Å‚Ã³w meczu z gÅ‚Ã³wnej listy
        async function analyzeAndShowMatchDetails(matchId) {
            // ZnajdÅº mecz w matchesData
            const match = matchesData.find(m => (m.id || m.match_id) === matchId);
            if (!match) {
                displayMessage('BÅ‚Ä…d: Nie znaleziono meczu', 'error');
                return;
            }

            // SprawdÅº czy mecz ma juÅ¼ analizÄ™ (w allAnalyzedMatches)
            let analyzedMatch = null;
            if (allAnalyzedMatches && allAnalyzedMatches.length > 0) {
                analyzedMatch = allAnalyzedMatches.find(am => {
                    const amMatch = am.match || {};
                    const amMatchId = amMatch.id || amMatch.match_id || am.api_match_id;
                    return amMatchId === matchId;
                });
            }

            // JeÅ›li mecz ma juÅ¼ analizÄ™ - pokaÅ¼ szczegÃ³Å‚y od razu (bez dodatkowego pobierania)
            if (analyzedMatch && analyzedMatch.analysis) {
                showMatchDetails(analyzedMatch);
                return;
            }

            // JeÅ›li nie ma analizy - uruchom peÅ‚nÄ… analizÄ™ dla wszystkich meczÃ³w
            if (!analyzedMatch) {
                showLoading(true);
                displayMessage('ðŸ”„ Rozpoczynam analizÄ™ wszystkich meczÃ³w...', 'info');
                
                // Uruchom peÅ‚nÄ… analizÄ™ w trybie cichym (bez otwierania modala)
                await analyzeOver95(true);
                
                // Po analizie znajdÅº mecz ponownie w allAnalyzedMatches
                if (allAnalyzedMatches && allAnalyzedMatches.length > 0) {
                    analyzedMatch = allAnalyzedMatches.find(am => {
                        const amMatch = am.match || {};
                        const amMatchId = amMatch.id || amMatch.match_id || am.api_match_id;
                        return amMatchId === matchId;
                    });
                }
                
                showLoading(false);
                
                // OdÅ›wieÅ¼ listÄ™ meczÃ³w aby pokazaÄ‡ nowe ikony (âœ…/âŒ)
                displayMatches();
                
                // JeÅ›li mecz ma analizÄ™ - pokaÅ¼ szczegÃ³Å‚y od razu
                if (analyzedMatch && analyzedMatch.analysis) {
                    displayMessage('âœ… Analiza zakoÅ„czona - otwieram szczegÃ³Å‚y meczu', 'success');
                    // MaÅ‚e opÃ³Åºnienie aby uÅ¼ytkownik zobaczyÅ‚ toast
                    setTimeout(() => {
                        showMatchDetails(analyzedMatch);
                    }, 500);
                    return;
                } else {
                    displayMessage('âœ… Analiza zakoÅ„czona - mecz nie kwalifikuje siÄ™', 'info');
                    return;
                }
            } else {
                // JeÅ›li nadal nie ma analizy (mecz nie zakwalifikowaÅ‚ siÄ™) - przeanalizuj tylko ten mecz
                showLoading(true);
                displayMessage('Analizowanie meczu...', 'info');

                try {
                    const competitionId = match.competition_id;
                    const homeId = match.homeID || match.home_id;
                    const awayId = match.awayID || match.away_id;

                    if (!competitionId || !homeId || !awayId) {
                        displayMessage('BÅ‚Ä…d: Brak wymaganych danych meczu', 'error');
                        showLoading(false);
                        return;
                    }

                    // Pobierz statystyki obu druÅ¼yn
                    const [homeStats, awayStats] = await Promise.all([
                        fetchTeamStats(homeId, competitionId),
                        fetchTeamStats(awayId, competitionId)
                    ]);

                    if (!homeStats || !awayStats) {
                        displayMessage('BÅ‚Ä…d: Nie udaÅ‚o siÄ™ pobraÄ‡ statystyk druÅ¼yn', 'error');
                        showLoading(false);
                        return;
                    }

                    // Analizuj mecz
                    const analysis = analyzeMatch(match, homeStats, awayStats);

                    // Pobierz nazwÄ™ ligi
                    let leaguesMap = {};
                    try {
                        const saved = localStorage.getItem('leaguesMap');
                        if (saved) {
                            leaguesMap = JSON.parse(saved);
                        }
                    } catch (e) {
                        console.error('BÅ‚Ä…d odczytu leaguesMap:', e);
                    }
                    const leagueKey = leaguesMap[competitionId] || `Liga ID: ${competitionId}`;

                    // Przygotuj obiekt w formacie oczekiwanym przez showMatchDetails
                    const matchItem = {
                        match: match,
                        league: leagueKey,
                        analysis: analysis,
                        home_name: match.home_name || 'N/A',
                        away_name: match.away_name || 'N/A',
                        time: match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-'
                    };

                    showLoading(false);
                    showMatchDetails(matchItem);
                } catch (error) {
                    console.error('BÅ‚Ä…d analizy meczu:', error);
                    displayMessage('BÅ‚Ä…d podczas analizy meczu: ' + error.message, 'error');
                    showLoading(false);
                }
            }
        }

        // Funkcja do generowania tabeli przelicznikÃ³w Modelu 5 (zoptymalizowana)
        function generateModel5TableHTML(tableId) {
            const rows = [
                ['1. Predicted avg corners', 'â‰¥12.0', '+2.50', true],
                ['', 'â‰¥11.5', '+2.00'],
                ['', 'â‰¥11.0', '+1.50'],
                ['', 'â‰¥10.5', '+1.00'],
                ['', 'â‰¥10.0', '+0.50'],
                ['2. Score (Model 1)', '9/9', '+2.50', true],
                ['', '8/9', '+2.00'],
                ['', '7/9', '+1.50'],
                ['', '6/9', '+1.00'],
                ['', '5/9', '+0.50'],
                ['3. Min Over 9.5%', 'â‰¥75%', '+3.00', true],
                ['', 'â‰¥70.1%', '+2.50'],
                ['', 'â‰¥65%', '+1.50'],
                ['', 'â‰¥60%', '+1.00'],
                ['', 'â‰¥55%', '+0.50'],
                ['4. Åšr atakÃ³w', 'â‰¥57', '+1.50', true],
                ['', 'â‰¥55', '+1.00'],
                ['', 'â‰¥50', '+0.50'],
                ['5. Styl gry', '3 style', '+1.50', true],
                ['', '1-2 style', '+0.75'],
                ['6. Åšr roÅ¼ne', 'â‰¥5.0 i â‰¥4.5', '+1.00', true],
                ['', 'â‰¥4.5 lub â‰¥4.0', '+0.50'],
                ['7. Min roÅ¼ne', 'â‰¥7 i â‰¥7', '+1.00', true],
                ['', 'â‰¥6 lub â‰¥6', '+0.50'],
                ['8. Bonus', 'Oba â‰¥70%', '+0.50', true]
            ];
            const tableRows = rows.map(([cat, val, pts, bold]) => 
                `<tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <td style="padding: 6px;">${cat}</td>
                    <td style="text-align: center; padding: 6px;">${val}</td>
                    <td style="text-align: center; padding: 6px; color: #4CAF50; ${bold ? 'font-weight: bold;' : ''}">${pts}</td>
                </tr>`
            ).join('');
            return `<p onclick="toggleModel5Table('${tableId}')" style="color: #FFFFFF; font-weight: bold; margin-top: 15px; margin-bottom: 10px; font-size: 1.1em; cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(2, 52, 116, 0.3); border-radius: 5px;" onmouseover="this.style.background='rgba(2, 52, 116, 0.5)'" onmouseout="this.style.background='rgba(2, 52, 116, 0.3)'">
                <span>ðŸ“Š Tabela przelicznikÃ³w punktowych:</span>
                <span id="${tableId}-icon">â–¶</span>
            </p>
            <div id="${tableId}" style="display: none; margin-top: 10px;">
                <div style="padding: 15px; background: rgba(2, 52, 116, 0.3); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                    <table style="width: 100%; border-collapse: collapse; color: #FFFFFF; font-size: 0.9em;">
                        <thead>
                            <tr style="border-bottom: 1px solid rgba(255,255,255,0.2);">
                                <th style="text-align: left; padding: 8px;">Kategoria</th>
                                <th style="text-align: center; padding: 8px;">WartoÅ›Ä‡</th>
                                <th style="text-align: center; padding: 8px;">Punkty</th>
                            </tr>
                        </thead>
                        <tbody>${tableRows}</tbody>
                    </table>
                    <p style="color: #FFFFFF; margin-top: 15px; font-size: 0.9em; font-style: italic;">
                        <strong>Maksymalna liczba punktÃ³w: 13.0</strong><br>
                        <strong>Wymagany prÃ³g: â‰¥8.0 (61.5% maksimum)</strong>
                    </p>
                </div>
            </div>`;
        }

        // Funkcja do zwijania/rozwijania tabeli Modelu 5
        function toggleModel5Table(tableId) {
            const table = document.getElementById(tableId);
            const icon = document.getElementById(tableId + '-icon');
            if (table && icon) {
                if (table.style.display === 'none') {
                    table.style.display = 'block';
                    icon.textContent = 'â–¼';
                } else {
                    table.style.display = 'none';
                    icon.textContent = 'â–¶';
                }
            }
        }

        // Funkcja do wyÅ›wietlania szczegÃ³Å‚Ã³w meczu
        function showMatchDetails(item) {
            const { match, league, analysis } = item;
            const matchId = match?.id || match?.match_id || 'default';
            const modelResults = analysis.model_results || {};
            const homeStats = analysis.home_stats || {};
            const awayStats = analysis.away_stats || {};
            
            // Oblicz wszystkie statystyki potrzebne do analizy
            const homePercent = analysis.home_percent || 0;
            const awayPercent = analysis.away_percent || 0;
            const score = analysis.score || 0;
            const predictedAvgCorners = analysis.predicted_avg_corners || 0;
            
            const avgShotsHome = homeStats.avg_shots || 0;
            const avgShotsAway = awayStats.avg_shots || 0;
            const avgPossessionHome = homeStats.avg_possession || 0;
            const avgPossessionAway = awayStats.avg_possession || 0;
            const avgDangerousAttacksHome = homeStats.avg_dangerous_attacks || 0;
            const avgDangerousAttacksAway = awayStats.avg_dangerous_attacks || 0;
            const avgCornersHome = homeStats.avg_corners || 0;
            const avgCornersAway = awayStats.avg_corners || 0;
            
            const homeRecent = homeStats.recent_matches || [];
            const awayRecent = awayStats.recent_matches || [];
            const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
            const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
            const avgTotalCornersHome = homeValidCorners.length > 0 ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length : 0;
            const avgTotalCornersAway = awayValidCorners.length > 0 ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length : 0;
            
            // Warunek podstawowy
            const basicRequirement = homePercent >= 50 && awayPercent >= 50;
            
            // Analiza Model 1
            const model1Qualified = modelResults.model1 || false;
            const model1Requirement = "Score >= 7 (z 9 kategorii)";
            const model1Actual = `Score: ${score}/9`;
            
            // Analiza Model 2
            const model2Score = calculateModel2Score(homeStats, awayStats, homePercent, awayPercent, predictedAvgCorners);
            const model2Qualified = modelResults.model2 || false;
            const model2Requirement = "Punkty >= 9 (max 13)";
            const model2Actual = `Punkty: ${model2Score}`;
            
            // Analiza Model 3
            const model3Qualified = modelResults.model3 || false;
            const model3Requirement = "Predicted avg >= 10.0 I (RÃ³Å¼nica posiadania > 10% LUB Ataki >= 50+50 LUB StrzaÅ‚y > 14)";
            const model3Actual = `Predicted avg: ${predictedAvgCorners.toFixed(1)}`;
            const style1 = (avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45);
            const style2 = avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50;
            const style3 = avgShotsHome > 14 || avgShotsAway > 14;
            
            // Analiza Model 4
            const model4Factors = calculateModel4Qualifies(avgPossessionHome, avgPossessionAway, avgDangerousAttacksHome, avgDangerousAttacksAway, minCornersHome, minCornersAway);
            const model4Qualified = modelResults.model4 || false;
            const model4Requirement = "Czynniki >= 2 (z 3)";
            const model4Actual = `Czynniki: ${model4Factors}/3`;
            
            // Analiza Model 5
            const model5Score = calculateModel5WeightedScore(score, predictedAvgCorners, homePercent, awayPercent, avgDangerousAttacksHome, avgDangerousAttacksAway, avgPossessionHome, avgPossessionAway, avgShotsHome, avgShotsAway, avgCornersHome, avgCornersAway, minCornersHome, minCornersAway);
            const model5Qualified = modelResults.model5 || false;
            const model5Requirement = "Punkty WEIGHTED >= 8.0";
            const model5Actual = `Punkty: ${model5Score.toFixed(2)}`;
            
            // Analiza Model 7
            const model7Qualified = modelResults.model7 || false;
            const model7Details = analysis.model7_details || {};
            const model7Requirement = "Wszystkie 11 warunkÃ³w speÅ‚nione";
            const model7Actual = `${model7Details.passedCount || 0}/${model7Details.totalCount || 11} warunkÃ³w`;
            
            // Generuj HTML dla wszystkich modeli
            let modelsHTML = '';
            const models = [
                { num: 1, qualified: model1Qualified, requirement: model1Requirement, actual: model1Actual, details: analysis.categories || [] },
                { num: 2, qualified: model2Qualified, requirement: model2Requirement, actual: model2Actual, details: [] },
                { num: 3, qualified: model3Qualified, requirement: model3Requirement, actual: model3Actual, details: [] },
                { num: 4, qualified: model4Qualified, requirement: model4Requirement, actual: model4Actual, details: [] },
                { num: 5, qualified: model5Qualified, requirement: model5Requirement, actual: model5Actual, details: [] },
                { num: 7, qualified: model7Qualified, requirement: model7Requirement, actual: model7Actual, details: model7Details.details || [] }
            ];
            
            models.forEach(model => {
                const statusIcon = model.qualified ? 'âœ…' : 'âŒ';
                const statusColor = model.qualified ? '#4CAF50' : '#EF0107';
                
                modelsHTML += `
                    <div class="card" style="margin-bottom: 20px; border-color: ${statusColor};">
                        <div class="card-header" style="background: ${model.qualified ? 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)' : 'linear-gradient(135deg, #EF0107 0%, #cc0000 100%)'};">
                            ${statusIcon} Model ${model.num} ${model.num === 7 ? '(Premium)' : ''}
                        </div>
                        <div style="padding: 15px;">
                            <div style="margin-bottom: 15px;">
                                <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 5px;">Wymaganie:</p>
                                <p style="color: #EF0107; margin-bottom: 10px;">${model.requirement}</p>
                                <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 5px;">Aktualna wartoÅ›Ä‡:</p>
                                <p style="color: ${statusColor}; font-size: 1.1em; font-weight: bold; margin-bottom: 15px;">${model.actual}</p>
                                <p style="color: ${statusColor}; font-weight: bold; font-size: 1.2em;">
                                    ${model.qualified ? 'âœ… SPEÅNIA WYMAGANIE' : 'âŒ NIE SPEÅNIA WYMAGANIA'}
                                </p>
                            </div>
                            ${model.details.length > 0 ? `
                                <div style="margin-top: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                    <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 10px;">SzczegÃ³Å‚y:</p>
                                    ${model.details.map(d => {
                                        const color = d.startsWith('âœ“') ? '#4CAF50' : d.startsWith('âœ—') ? '#EF0107' : '#FFFFFF';
                                        return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${d}</p>`;
                                    }).join('')}
                                </div>
                            ` : ''}
                            ${model.num === 2 ? `
                                <div style="margin-top: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                    <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 10px;">SzczegÃ³Å‚y punktacji:</p>
                                    <p style="color: ${avgCornersHome >= 5.0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${avgCornersHome >= 5.0 ? 'âœ“' : 'âœ—'} Åšr roÅ¼ne (gospodarz) â‰¥ 5.0: ${avgCornersHome.toFixed(1)} ${avgCornersHome >= 5.0 ? '(+2 pkt)' : ''}
                                    </p>
                                    <p style="color: ${avgCornersAway >= 4.5 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${avgCornersAway >= 4.5 ? 'âœ“' : 'âœ—'} Åšr roÅ¼ne (goÅ›Ä‡) â‰¥ 4.5: ${avgCornersAway.toFixed(1)} ${avgCornersAway >= 4.5 ? '(+2 pkt)' : ''}
                                    </p>
                                    <p style="color: ${(minCornersHome >= 4.5 || minCornersAway >= 4.5) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${(minCornersHome >= 4.5 || minCornersAway >= 4.5) ? 'âœ“' : 'âœ—'} Min roÅ¼ne â‰¥ 4.5: ${minCornersHome} vs ${minCornersAway} ${(minCornersHome >= 4.5 || minCornersAway >= 4.5) ? '(+1 pkt)' : ''}
                                    </p>
                                    <p style="color: ${(avgCornersHome + avgCornersAway >= 9.5) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${(avgCornersHome + avgCornersAway >= 9.5) ? 'âœ“' : 'âœ—'} Suma roÅ¼nych â‰¥ 9.5: ${(avgCornersHome + avgCornersAway).toFixed(1)} ${(avgCornersHome + avgCornersAway >= 9.5) ? '(+2 pkt)' : ''}
                                    </p>
                                    <p style="color: ${(avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${(avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) ? 'âœ“' : 'âœ—'} Ataki â‰¥ 50+50: ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)} ${(avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50) ? '(+1 pkt)' : ''}
                                    </p>
                                    <p style="color: ${(avgShotsHome >= 12 && avgShotsAway >= 12) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${(avgShotsHome >= 12 && avgShotsAway >= 12) ? 'âœ“' : 'âœ—'} StrzaÅ‚y â‰¥ 12+12: ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)} ${(avgShotsHome >= 12 && avgShotsAway >= 12) ? '(+1 pkt)' : ''}
                                    </p>
                                    <p style="color: ${avgDangerousAttacksHome >= 55 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${avgDangerousAttacksHome >= 55 ? 'âœ“' : 'âœ—'} Ataki (gospodarz) â‰¥ 55: ${avgDangerousAttacksHome.toFixed(1)} ${avgDangerousAttacksHome >= 55 ? '(+1 pkt)' : ''}
                                    </p>
                                    <p style="color: ${predictedAvgCorners >= 10 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${predictedAvgCorners >= 10 ? 'âœ“' : 'âœ—'} Predicted avg â‰¥ 10: ${predictedAvgCorners.toFixed(1)} ${predictedAvgCorners >= 10 ? '(+1 pkt)' : ''}
                                    </p>
                                </div>
                            ` : ''}
                            ${model.num === 3 ? `
                                <div style="margin-top: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                    <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 10px;">Warunki stylu gry:</p>
                                    <p style="color: ${predictedAvgCorners >= 10.0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${predictedAvgCorners >= 10.0 ? 'âœ“' : 'âœ—'} Predicted avg corners â‰¥ 10.0: ${predictedAvgCorners.toFixed(1)}
                                    </p>
                                    <p style="color: ${style1 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${style1 ? 'âœ“' : 'âœ—'} Styl 1: RÃ³Å¼nica posiadania > 10% (${avgPossessionHome.toFixed(0)}% vs ${avgPossessionAway.toFixed(0)}%)
                                    </p>
                                    <p style="color: ${style2 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${style2 ? 'âœ“' : 'âœ—'} Styl 2: Ataki â‰¥ 50+50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})
                                    </p>
                                    <p style="color: ${style3 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${style3 ? 'âœ“' : 'âœ—'} Styl 3: StrzaÅ‚y > 14 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})
                                    </p>
                                    <p style="color: #FFFFFF; margin-top: 10px; font-style: italic;">
                                        Model 3 wymaga: Predicted avg â‰¥ 10.0 I (Styl 1 LUB Styl 2 LUB Styl 3)
                                    </p>
                                </div>
                            ` : ''}
                            ${model.num === 4 ? `
                                <div style="margin-top: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                    <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 10px;">Czynniki:</p>
                                    <p style="color: ${Math.abs(avgPossessionHome - avgPossessionAway) >= 10 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${Math.abs(avgPossessionHome - avgPossessionAway) >= 10 ? 'âœ“' : 'âœ—'} RÃ³Å¼nica posiadania â‰¥ 10%: ${Math.abs(avgPossessionHome - avgPossessionAway).toFixed(0)}%
                                    </p>
                                    <p style="color: ${(avgDangerousAttacksHome >= 50 || avgDangerousAttacksAway >= 50) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${(avgDangerousAttacksHome >= 50 || avgDangerousAttacksAway >= 50) ? 'âœ“' : 'âœ—'} Ataki â‰¥ 50: ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}
                                    </p>
                                    <p style="color: ${((avgPossessionHome < 45 && minCornersAway >= 6) || (avgPossessionAway < 45 && minCornersHome >= 6)) ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                        ${((avgPossessionHome < 45 && minCornersAway >= 6) || (avgPossessionAway < 45 && minCornersHome >= 6)) ? 'âœ“' : 'âœ—'} Niskie posiadanie + min roÅ¼ne â‰¥ 6: (${avgPossessionHome.toFixed(0)}%/${minCornersAway} lub ${avgPossessionAway.toFixed(0)}%/${minCornersHome})
                                    </p>
                                </div>
                            ` : ''}
                            ${model.num === 5 ? `
                                <div style="margin-top: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                    <p style="color: #FFFFFF; font-weight: bold; margin-bottom: 10px;">SzczegÃ³Å‚y punktacji WEIGHTED:</p>
                                    ${(() => {
                                        let detailsHTML = '';
                                        let totalPoints = 0;
                                        
                                        // 1. Predicted avg corners
                                        let predictedPoints = 0;
                                        if (predictedAvgCorners >= 12) {
                                            predictedPoints = 2.5;
                                        } else if (predictedAvgCorners >= 11.5) {
                                            predictedPoints = 2.0;
                                        } else if (predictedAvgCorners >= 11) {
                                            predictedPoints = 1.5;
                                        } else if (predictedAvgCorners >= 10.5) {
                                            predictedPoints = 1.0;
                                        } else if (predictedAvgCorners >= 10) {
                                            predictedPoints = 0.5;
                                        }
                                        totalPoints += predictedPoints;
                                        detailsHTML += `<p style="color: ${predictedPoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${predictedPoints > 0 ? 'âœ“' : 'âœ—'} 1. Predicted avg corners: ${predictedAvgCorners.toFixed(1)} ${predictedPoints > 0 ? `(+${predictedPoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 2. Score (Model 1)
                                        let scorePoints = 0;
                                        if (score >= 9) {
                                            scorePoints = 2.5;
                                        } else if (score >= 8) {
                                            scorePoints = 2.0;
                                        } else if (score >= 7) {
                                            scorePoints = 1.5;
                                        } else if (score >= 6) {
                                            scorePoints = 1.0;
                                        } else if (score >= 5) {
                                            scorePoints = 0.5;
                                        }
                                        totalPoints += scorePoints;
                                        detailsHTML += `<p style="color: ${scorePoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${scorePoints > 0 ? 'âœ“' : 'âœ—'} 2. Score (Model 1): ${score}/9 ${scorePoints > 0 ? `(+${scorePoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 3. Min Over 9.5%
                                        const minOver95 = Math.min(homePercent, awayPercent);
                                        let minOver95Points = 0;
                                        if (minOver95 >= 75) {
                                            minOver95Points = 3.0;
                                        } else if (minOver95 >= 70.1) {
                                            minOver95Points = 2.5;
                                        } else if (minOver95 >= 65) {
                                            minOver95Points = 1.5;
                                        } else if (minOver95 >= 60) {
                                            minOver95Points = 1.0;
                                        } else if (minOver95 >= 55) {
                                            minOver95Points = 0.5;
                                        }
                                        totalPoints += minOver95Points;
                                        detailsHTML += `<p style="color: ${minOver95Points > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${minOver95Points > 0 ? 'âœ“' : 'âœ—'} 3. Min Over 9.5%: ${minOver95.toFixed(1)}% (${homePercent.toFixed(1)}% | ${awayPercent.toFixed(1)}%) ${minOver95Points > 0 ? `(+${minOver95Points.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 4. Åšr atakÃ³w
                                        const avgAttacks = (avgDangerousAttacksHome + avgDangerousAttacksAway) / 2;
                                        let avgAttacksPoints = 0;
                                        if (avgAttacks >= 57) {
                                            avgAttacksPoints = 1.5;
                                        } else if (avgAttacks >= 55) {
                                            avgAttacksPoints = 1.0;
                                        } else if (avgAttacks >= 50) {
                                            avgAttacksPoints = 0.5;
                                        }
                                        totalPoints += avgAttacksPoints;
                                        detailsHTML += `<p style="color: ${avgAttacksPoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${avgAttacksPoints > 0 ? 'âœ“' : 'âœ—'} 4. Åšr atakÃ³w: ${avgAttacks.toFixed(1)} (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}) ${avgAttacksPoints > 0 ? `(+${avgAttacksPoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 5. Styl gry
                                        const style1 = (avgPossessionHome > 55 && avgPossessionAway < 45) || (avgPossessionAway > 55 && avgPossessionHome < 45);
                                        const style2 = avgDangerousAttacksHome >= 50 && avgDangerousAttacksAway >= 50;
                                        const style3 = avgShotsHome > 14 || avgShotsAway > 14;
                                        let stylePoints = 0;
                                        if (style1) stylePoints += 0.5;
                                        if (style2) stylePoints += 0.5;
                                        if (style3) stylePoints += 0.5;
                                        let styleFinalPoints = 0;
                                        if (stylePoints >= 1.0) {
                                            styleFinalPoints = 1.5;
                                        } else if (stylePoints >= 0.5) {
                                            styleFinalPoints = 0.75;
                                        }
                                        totalPoints += styleFinalPoints;
                                        detailsHTML += `<p style="color: ${styleFinalPoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${styleFinalPoints > 0 ? 'âœ“' : 'âœ—'} 5. Styl gry: ${style1 ? 'RÃ³Å¼nica posiadania ' : ''}${style2 ? 'Ataki 50+50 ' : ''}${style3 ? 'StrzaÅ‚y >14 ' : ''}${!style1 && !style2 && !style3 ? 'Brak' : ''} ${styleFinalPoints > 0 ? `(+${styleFinalPoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 6. Åšr corners
                                        let avgCornersPoints = 0;
                                        if (avgCornersHome >= 5.0 && avgCornersAway >= 4.5) {
                                            avgCornersPoints = 1.0;
                                        } else if (avgCornersHome >= 4.5 || avgCornersAway >= 4.0) {
                                            avgCornersPoints = 0.5;
                                        }
                                        totalPoints += avgCornersPoints;
                                        detailsHTML += `<p style="color: ${avgCornersPoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${avgCornersPoints > 0 ? 'âœ“' : 'âœ—'} 6. Åšr roÅ¼ne: ${avgCornersHome.toFixed(1)} | ${avgCornersAway.toFixed(1)} ${avgCornersPoints > 0 ? `(+${avgCornersPoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 7. Min corners
                                        let minCornersPoints = 0;
                                        if (minCornersHome >= 7 && minCornersAway >= 7) {
                                            minCornersPoints = 1.0;
                                        } else if (minCornersHome >= 6 || minCornersAway >= 6) {
                                            minCornersPoints = 0.5;
                                        }
                                        totalPoints += minCornersPoints;
                                        detailsHTML += `<p style="color: ${minCornersPoints > 0 ? '#4CAF50' : '#EF0107'}; margin: 5px 0; padding-left: 20px;">
                                            ${minCornersPoints > 0 ? 'âœ“' : 'âœ—'} 7. Min roÅ¼ne: ${minCornersHome} | ${minCornersAway} ${minCornersPoints > 0 ? `(+${minCornersPoints.toFixed(2)} pkt)` : '(0 pkt)'}
                                        </p>`;
                                        
                                        // 8. Bonus za wysokie oba Over 9.5%
                                        let bonusPoints = 0;
                                        if (homePercent >= 70 && awayPercent >= 70) {
                                            bonusPoints = 0.5;
                                        }
                                        totalPoints += bonusPoints;
                                        if (bonusPoints > 0) {
                                            detailsHTML += `<p style="color: #4CAF50; margin: 5px 0; padding-left: 20px;">
                                                âœ“ 8. Bonus (oba Over 9.5% â‰¥ 70%): ${homePercent.toFixed(1)}% | ${awayPercent.toFixed(1)}% (+${bonusPoints.toFixed(2)} pkt)
                                            </p>`;
                                        }
                                        
                                        detailsHTML += `<p style="color: #FFFFFF; margin-top: 15px; font-weight: bold; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;">
                                            Suma punktÃ³w: ${totalPoints.toFixed(2)} / 8.0 (wymagane: â‰¥ 8.0)
                                        </p>`;
                                        
                                        // Dodaj zwijanÄ… sekcjÄ™ z tabelÄ… przelicznikÃ³w (uÅ¼yj funkcji)
                                        const tableId = `model5-table-${matchId}`;
                                        const tableSection = generateModel5TableHTML(tableId);
                                        
                                        return detailsHTML + tableSection;
                                    })()}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            // Generuj gÅ‚Ã³wny HTML
            const html = `
                <h2 style="color: #EF0107; margin-bottom: 20px; text-align: center;">
                    ðŸ“Š SzczegÃ³Å‚y meczu: ${item.home_name} vs ${item.away_name}
                </h2>
                <div style="text-align: center; margin-bottom: 30px; padding: 15px; background: rgba(2, 52, 116, 0.2); border-radius: 10px;">
                    <p style="color: #FFFFFF; font-size: 1.1em; margin: 5px 0;"><strong>ðŸ† Liga:</strong> ${league}</p>
                    <p style="color: #FFFFFF; font-size: 1.1em; margin: 5px 0;"><strong>ðŸ• Czas:</strong> ${item.time}</p>
                    <p style="color: ${basicRequirement ? '#4CAF50' : '#EF0107'}; font-size: 1.1em; margin: 5px 0; font-weight: bold;">
                        ${basicRequirement ? 'âœ…' : 'âŒ'} Warunek podstawowy: Oba zespoÅ‚y â‰¥ 50% (${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%)
                    </p>
                </div>
                
                <h3 style="color: #FFFFFF; margin: 30px 0 20px 0; font-size: 1.5em;">ðŸ” Analiza wszystkich modeli:</h3>
                ${modelsHTML}
            `;
            
            document.getElementById('match-details-content').innerHTML = html;
            openModal('matchDetailsModal');
        }
    </script>
</body>
</html>

