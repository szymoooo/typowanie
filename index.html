<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corner Predictor - Over 9.5 Analiza</title>
    <style>
        /* Kolory Arsenal: czerwony #EF0107, bia≈Çy #FFFFFF, granatowy #023474 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            padding: 30px 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 20px rgba(239, 1, 7, 0.3);
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            color: #FFFFFF;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }

        header .subtitle {
            color: #FFFFFF;
            font-size: 1.1em;
            opacity: 0.95;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: #EF0107;
            color: #FFFFFF;
        }

        .btn-primary:hover {
            background: #cc0000;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(239, 1, 7, 0.4);
        }

        .btn-secondary {
            background: #023474;
            color: #FFFFFF;
        }

        .btn-secondary:hover {
            background: #011f4a;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(2, 52, 116, 0.4);
        }

        .btn-white {
            background: #FFFFFF;
            color: #EF0107;
        }

        .btn-white:hover {
            background: #f5f5f5;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.3);
        }

        /* Cards */
        .card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(239, 1, 7, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .card-header {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 15px 20px;
            border-radius: 10px;
            margin: -25px -25px 20px -25px;
            font-size: 1.3em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header.blue {
            background: linear-gradient(135deg, #023474 0%, #011f4a 100%);
        }

        /* Match List */
        .match-item {
            background: rgba(255, 255, 255, 0.03);
            border-left: 4px solid #EF0107;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .match-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-left-color: #023474;
            transform: translateX(5px);
        }

        .match-time {
            color: #FFFFFF;
            font-weight: bold;
            display: inline-block;
            width: 70px;
        }

        .match-teams {
            color: #FFFFFF;
            font-size: 1.1em;
            margin: 5px 0;
        }

        .match-league {
            color: #EF0107;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(2, 52, 116, 0.5);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #EF0107;
            margin: 10px 0;
        }

        .stat-label {
            color: #FFFFFF;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #EF0107;
            font-size: 1.2em;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #EF0107;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 1, 7, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 1, 7, 0);
            }
        }

        /* League Section - Two Column Layout */
        #matches-container {
            margin-top: 20px;
        }

        .league-section {
            margin-bottom: 0;
            break-inside: avoid;
        }

        .league-title {
            background: linear-gradient(135deg, #EF0107 0%, #cc0000 100%);
            color: #FFFFFF;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        /* Responsive - jedna kolumna na ma≈Çych ekranach */
        @media (max-width: 768px) {
            #matches-container {
                grid-template-columns: 1fr;
            }
            
            #analysis-content > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
        }

        /* Analysis Window */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 50px auto;
            padding: 30px;
            border: 3px solid #EF0107;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(239, 1, 7, 0.5);
        }

        .close {
            color: #FFFFFF;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #EF0107;
        }

        /* Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th {
            background: #023474;
            color: #FFFFFF;
            padding: 15px;
            text-align: left;
            border-bottom: 3px solid #EF0107;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        tr:hover {
            background: rgba(239, 1, 7, 0.1);
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-success {
            background: #4CAF50;
            color: #FFFFFF;
        }

        .badge-danger {
            background: #EF0107;
            color: #FFFFFF;
        }

        .badge-warning {
            background: #FF9800;
            color: #FFFFFF;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öΩ Corner Predictor</h1>
            <p class="subtitle">Analiza Over 9.5 Rzut√≥w Ro≈ºnych</p>
        </header>

        <div class="button-group">
            <button class="btn btn-primary" onclick="fetchMatches()">üîÑ Pobierz Mecze</button>
            <button class="btn btn-secondary" onclick="analyzeOver95()">üìä Analizuj Over 9.5</button>
            <button class="btn btn-white" onclick="showHistory()">üìú Historia</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Pobieranie danych...</p>
        </div>

        <div id="stats" class="stats-grid" style="display: none;">
            <div class="stat-card">
                <div class="stat-label">Dzisiejsze Mecze</div>
                <div class="stat-value" id="total-matches">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Ligi</div>
                <div class="stat-value" id="total-leagues">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">KwalifikujƒÖce siƒô</div>
                <div class="stat-value" id="qualified-matches">0</div>
            </div>
        </div>

        <div id="matches-container"></div>
    </div>

    <!-- Modal dla analizy -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('analysisModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">üìä Analiza Over 9.5</h2>
            <div id="analysis-content"></div>
        </div>
    </div>

    <!-- Modal dla historii -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('historyModal')">&times;</span>
            <h2 style="color: #EF0107; margin-bottom: 20px;">üìú Historia Mecz√≥w</h2>
            <div id="history-content"></div>
        </div>
    </div>

    <footer>
        <p>Corner Predictor - System analizy rzut√≥w ro≈ºnych Over 9.5</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Powered by Football Data API</p>
    </footer>

    <script>
        // API Configuration
        const API_KEY = '8cdad7757b702fae3b792c0b3328017ee33cc17594b18ea8a2717cdc53162325';
        
        // Konfiguracja: u≈ºyj lokalnego proxy servera (uruchom: python3 proxy_server.py)
        const BASE_URL = 'http://localhost:8080/api';
        const USE_PROXY = false; // false = u≈ºywa lokalnego proxy, true = u≈ºywa zewnƒôtrznych proxy (czƒôsto 403)
        
        // Debug: sprawd≈∫ konfiguracjƒô
        console.log('üîß Konfiguracja API:', { BASE_URL, USE_PROXY, proxy: getProxy() });
        
        // Proxy dla CORS - wiƒôcej opcji na wypadek blokad
        const PROXY_SERVICES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://thingproxy.freeboard.io/fetch/',
        ];
        let currentProxyIndex = 0;
        
        function getProxy() {
            if (!USE_PROXY) return ''; // Brak proxy je≈õli u≈ºywamy lokalnego serwera
            return PROXY_SERVICES[currentProxyIndex];
        }

        // Global state
        let matchesData = [];
        let leaguesData = {};
        let teamsData = {};
        let analyzedMatches = [];
        let lastAnalysisHash = null; // Hash mecz√≥w z ostatniej analizy

        // Fetch matches from API
        async function fetchMatches() {
            showLoading(true);
            displayMessage('Pobieranie mecz√≥w z API...', 'info');
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const proxy = getProxy();
                
                // Je≈õli u≈ºywasz lokalnego proxy, API_KEY jest ju≈º w URL przez backend
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/todays-matches?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/todays-matches`;
                }
                
                console.log('Pobieranie mecz√≥w z:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success || !data.data || !Array.isArray(data.data)) {
                    throw new Error('Brak danych w odpowiedzi API');
                }
                
                // Filtruj tylko mecze z dzisiaj (wed≈Çug date_unix w UTC)
                // date_unix z API jest w UTC, wiƒôc musimy u≈ºyƒá UTC do obliczania przedzia≈Ç√≥w
                const todayUTC = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
                const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000); // Unix timestamp poczƒÖtku dnia UTC
                const todayEnd = todayStart + 86399; // +23:59:59 = 86399 sekund
                
                const allMatches = data.data || [];
                console.log(`üìÖ Pobrano ${allMatches.length} mecz√≥w z API`);
                console.log(`üìÖ Dzisiejszy zakres UTC: ${new Date(todayStart * 1000).toISOString()} - ${new Date(todayEnd * 1000).toISOString()}`);
                
                // Pokazuj WSZYSTKIE mecze z dzisiaj - niezale≈ºnie od statusu (rozegrane, trwajƒÖce, oczekujƒÖce)
                // Rozszerzamy zakres o 6 godzin w ka≈ºdƒÖ stronƒô aby uwzglƒôdniƒá r√≥≈ºnice stref czasowych
                const extendedStart = todayStart - 21600; // 6 godzin wcze≈õniej
                const extendedEnd = todayEnd + 21600; // 6 godzin p√≥≈∫niej
                
                const filteredOut = [];
                matchesData = allMatches.filter(match => {
                    const matchDateUnix = match.date_unix;
                    const status = match.status || 'unknown';
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    
                    if (!matchDateUnix) {
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: 'brak date_unix', status});
                        return false;
                    }
                    
                    // Pokazuj mecz je≈õli jest w rozszerzonym zakresie (dzisiaj +/- 6h)
                    // To uwzglƒôdnia r√≥≈ºnice stref czasowych i mecze kt√≥re mogƒÖ siƒô ko≈Ñczyƒá/zaczynaƒá dzisiaj
                    const isInRange = matchDateUnix >= extendedStart && matchDateUnix <= extendedEnd;
                    
                    if (!isInRange) {
                        const matchDate = new Date(matchDateUnix * 1000).toISOString();
                        filteredOut.push({match: `${homeName} vs ${awayName}`, reason: `poza zakresem (${matchDate})`, status});
                        return false;
                    }
                    
                    return true;
                });
                
                console.log(`‚úÖ Filtrowanie mecz√≥w: ${allMatches.length} wszystkich, ${matchesData.length} pokazanych (wszystkie statusy)`);
                if (filteredOut.length > 0) {
                    console.log(`‚ùå Odfiltrowano ${filteredOut.length} mecz√≥w:`);
                    filteredOut.forEach((item, idx) => {
                        console.log(`   ${idx + 1}. ${item.match} - ${item.reason} (status: ${item.status})`);
                    });
                }
                
                // Loguj pokazane mecze z ich statusami
                console.log(`üìã Pokazane mecze (${matchesData.length}):`);
                matchesData.forEach((match, idx) => {
                    const status = match.status || 'unknown';
                    const time = match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-';
                    console.log(`   ${idx + 1}. ${match.home_name} vs ${match.away_name} (${time}) - status: ${status}`);
                });
                
                // Zapisz do localStorage
                localStorage.setItem('matchesData', JSON.stringify(matchesData));
                localStorage.setItem('matchesDate', today);
                
                // Je≈õli mecze siƒô zmieni≈Çy, wyczy≈õƒá cache analizy
                const currentHash = createMatchesHash(matchesData);
                const cachedHash = localStorage.getItem('lastAnalysisHash');
                if (cachedHash !== currentHash) {
                    console.log('üìã Mecze siƒô zmieni≈Çy - czyszczƒô cache analizy');
                    localStorage.removeItem('lastAnalysis');
                    localStorage.removeItem('lastAnalysisHash');
                    analyzedMatches = [];
                    lastAnalysisHash = null;
                }
                
                showLoading(false);
                displayMatches();
                displayMessage(`‚úì Pobrano ${matchesData.length} mecz√≥w!`, 'success');
            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd pobierania mecz√≥w:', error);
                displayMessage('B≈ÇƒÖd pobierania danych: ' + error.message, 'error');
                
                // Spr√≥buj za≈Çadowaƒá z localStorage
                const savedMatches = localStorage.getItem('matchesData');
                const savedDate = localStorage.getItem('matchesDate');
                if (savedMatches && savedDate === new Date().toISOString().split('T')[0]) {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj te≈º z cache (na wypadek je≈õli by≈Çy w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('Za≈Çadowano dane z cache', 'info');
                }
            }
        }

        // Display matches
        function displayMatches() {
            const container = document.getElementById('matches-container');
            if (matchesData.length === 0) {
                container.innerHTML = '<div class="card" style="grid-column: 1 / -1;"><p style="color: #FFFFFF; text-align: center;">Brak mecz√≥w do wy≈õwietlenia</p></div>';
                return;
            }
            
            // Pobierz nazwy lig (z cache je≈õli dostƒôpne)
            let leaguesMap = {};
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    leaguesMap = JSON.parse(saved);
                }
            } catch (e) {
                console.error('B≈ÇƒÖd odczytu leaguesMap:', e);
            }
            
            // Grupuj mecze wed≈Çug ligi
            const matchesByLeague = {};
            matchesData.forEach(match => {
                const competitionId = match.competition_id;
                const leagueKey = leaguesMap[competitionId] || `Liga ID: ${competitionId}`;
                
                if (!matchesByLeague[leagueKey]) {
                    matchesByLeague[leagueKey] = [];
                }
                matchesByLeague[leagueKey].push(match);
            });
            
            // Przygotuj ligi z informacjƒÖ o liczbie mecz√≥w
            const leagueEntries = Object.entries(matchesByLeague).map(([key, matches]) => ({
                key,
                matches,
                count: matches.length
            }));
            
            // Sortuj ligi wed≈Çug liczby mecz√≥w (malejƒÖco)
            leagueEntries.sort((a, b) => b.count - a.count);
            
            // Podziel ligi na pary - w ka≈ºdej parze lewa (A) ma wiƒôcej mecz√≥w ni≈º prawa (B)
            const leaguePairs = [];
            for (let i = 0; i < leagueEntries.length; i += 2) {
                if (i + 1 < leagueEntries.length) {
                    // Para lig - upewnij siƒô, ≈ºe lewa ma wiƒôcej
                    const left = leagueEntries[i];
                    const right = leagueEntries[i + 1];
                    if (left.count >= right.count) {
                        leaguePairs.push([left, right]);
                    } else {
                        leaguePairs.push([right, left]);
                    }
                } else {
                    // Ostatnia liga bez pary - dodaj do lewej kolumny
                    leaguePairs.push([leagueEntries[i], null]);
                }
            }
            
            // Funkcja do generowania HTML dla sekcji ligi
            const generateLeagueHTML = (league) => {
                if (!league) return '';
                const matchText = league.count === 1 ? '1 mecz' : `${league.count} mecz√≥w`;
                let html = `
                    <div class="league-section">
                        <div class="league-title">üèÜ ${league.key} (${matchText})</div>
                `;
                
                league.matches.forEach(match => {
                    const homeName = match.home_name || 'N/A';
                    const awayName = match.away_name || 'N/A';
                    const dateUnix = match.date_unix;
                    const status = match.status || 'pending';
                    let timeStr = '-';
                    let statusBadge = '';
                    
                    if (dateUnix) {
                        const date = new Date(dateUnix * 1000);
                        timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                    }
                    
                    // Dodaj badge statusu
                    if (status === 'complete' || status === 'finished' || status === 'FT') {
                        statusBadge = '<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">Zako≈Ñczony</span>';
                    } else if (status === 'live' || status === 'inplay' || status === 'LIVE') {
                        statusBadge = '<span style="background: #EF0107; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">LIVE</span>';
                    } else if (status === 'pending' || status === 'scheduled') {
                        statusBadge = '<span style="background: #FF9800; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 5px;">Oczekuje</span>';
                    }
                    
                    html += `
                        <div class="match-item">
                            <span class="match-time">${timeStr}</span>
                            <div class="match-teams">${homeName} vs ${awayName} ${statusBadge}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                return html;
            };
            
            // Generuj HTML - ka≈ºda para lig w osobnym wierszu
            let html = '';
            leaguePairs.forEach(([leftLeague, rightLeague]) => {
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">';
                html += '<div>' + generateLeagueHTML(leftLeague) + '</div>';
                html += '<div>' + generateLeagueHTML(rightLeague) + '</div>';
                html += '</div>';
            });
            
            container.innerHTML = html;
            
            // Aktualizuj statystyki
            document.getElementById('total-matches').textContent = matchesData.length;
            document.getElementById('total-leagues').textContent = leagueEntries.length;
            document.getElementById('stats').style.display = 'grid';
        }

        // Fetch team stats from API
        async function fetchTeamStats(teamId, competitionId) {
            try {
                const proxy = getProxy();
                
                // Najpierw spr√≥buj league-season
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-season?season_id=${competitionId}`;
                }
                let response = await fetch(url);
                
                // Je≈õli 403 i u≈ºywamy zewnƒôtrznego proxy, spr√≥buj zmieniƒá proxy
                if (response.status === 403 && USE_PROXY) {
                    console.warn(`‚ö†Ô∏è 403 Forbidden dla league-season, pr√≥bujƒô zmieniƒá proxy...`);
                    // Pr√≥buj nastƒôpnego proxy
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-season?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                } else if (response.status === 403 && !USE_PROXY) {
                    console.error('‚ùå 403 Forbidden - sprawd≈∫ czy proxy server dzia≈Ça na localhost:8080');
                    console.error('   Uruchom: python3 proxy_server.py');
                }
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.data) {
                        // Znajd≈∫ dru≈ºynƒô w danych
                        const clubs = Array.isArray(data.data) ? data.data : (data.data.clubs || []);
                        for (const club of clubs) {
                            if (club.id === teamId) {
                                return club;
                            }
                        }
                    }
                }
                
                // Fallback: pobierz mecze z ligi
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                } else {
                    url = `${BASE_URL}/league-matches?season_id=${competitionId}`;
                }
                response = await fetch(url);
                
                // Je≈õli 403 i u≈ºywamy zewnƒôtrznego proxy, spr√≥buj zmieniƒá proxy
                if (response.status === 403 && USE_PROXY) {
                    console.warn(`403 Forbidden dla league-matches, pr√≥bujƒô zmieniƒá proxy...`);
                    currentProxyIndex = (currentProxyIndex + 1) % PROXY_SERVICES.length;
                    const newProxy = getProxy();
                    url = `${newProxy}${BASE_URL}/league-matches?key=${API_KEY}&season_id=${competitionId}`;
                    response = await fetch(url);
                }
                
                if (!response.ok) {
                    console.error(`B≈ÇƒÖd pobierania league-matches: ${response.status}`);
                    return null;
                }
                
                const data = await response.json();
                if (!data.success || !data.data) return null;
                
                // Filtruj mecze z tƒÖ dru≈ºynƒÖ (zako≈Ñczone)
                const teamMatches = data.data
                    .filter(m => m.status === 'complete' && (m.homeID === teamId || m.awayID === teamId))
                    .sort((a, b) => (b.date_unix || 0) - (a.date_unix || 0))
                    .slice(0, 5);
                
                if (teamMatches.length === 0) return null;
                
                // Oblicz statystyki z mecz√≥w
                return calculateStatsFromMatches(teamMatches, teamId);
                
            } catch (error) {
                console.error('B≈ÇƒÖd pobierania statystyk:', error);
                return null;
            }
        }

        // Calculate stats from matches
        function calculateStatsFromMatches(matches, teamId) {
            if (!matches || matches.length === 0) return null;
            
            let totalCorners = 0;
            let totalShots = 0;
            let totalPossession = 0;
            let totalDangerousAttacks = 0;
            let over95Count = 0;
            const recentMatches = [];
            
            matches.forEach(match => {
                const isHome = match.homeID === teamId;
                const corners = isHome ? (match.team_a_corners || 0) : (match.team_b_corners || 0);
                const oppCorners = isHome ? (match.team_b_corners || 0) : (match.team_a_corners || 0);
                const totalCornerCount = (match.totalCornerCount || 0);
                
                const shots = isHome ? (match.team_a_shots || 0) : (match.team_b_shots || 0);
                const possession = isHome ? (match.team_a_possession || 0) : (match.team_b_possession || 0);
                const dangerousAttacks = isHome ? (match.team_a_dangerous_attacks || 0) : (match.team_b_dangerous_attacks || 0);
                
                totalCorners += corners;
                totalShots += shots;
                totalPossession += possession;
                totalDangerousAttacks += dangerousAttacks;
                
                if (totalCornerCount > 9.5) {
                    over95Count++;
                }
                
                recentMatches.push({
                    totalCornerCount: totalCornerCount,
                    corners: corners,
                    shots: shots,
                    possession: possession,
                    dangerousAttacks: dangerousAttacks
                });
            });
            
            const matchCount = matches.length;
            
            return {
                avg_corners: totalCorners / matchCount,
                avg_shots: totalShots / matchCount,
                avg_possession: totalPossession / matchCount,
                avg_dangerous_attacks: totalDangerousAttacks / matchCount,
                over95_percentages: [(over95Count / matchCount) * 100],
                recent_matches: recentMatches
            };
        }

        // Calculate Over 9.5 percentage
        function calculateOver95Percentage(stats) {
            if (!stats || !stats.recent_matches || stats.recent_matches.length === 0) {
                // Spr√≥buj z over95_percentages je≈õli dostƒôpne
                if (stats?.over95_percentages && stats.over95_percentages.length > 0) {
                    return stats.over95_percentages[0];
                }
                return 0;
            }
            
            const validMatches = stats.recent_matches.filter(m => m.totalCornerCount !== -1 && m.totalCornerCount !== undefined);
            if (validMatches.length === 0) return 0;
            
            const over95Count = validMatches.filter(m => m.totalCornerCount > 9.5).length;
            return (over95Count / validMatches.length) * 100;
        }

        // Analyze single match
        function analyzeMatch(match, homeStats, awayStats) {
            const homePercent = calculateOver95Percentage(homeStats);
            const awayPercent = calculateOver95Percentage(awayStats);
            
            // Podstawowe wymaganie
            const meetsBasic = homePercent >= 50 && awayPercent >= 50;
            
            // Oblicz statystyki
            const avgShotsHome = homeStats?.avg_shots || 0;
            const avgShotsAway = awayStats?.avg_shots || 0;
            const avgPossessionHome = homeStats?.avg_possession || 0;
            const avgPossessionAway = awayStats?.avg_possession || 0;
            const avgDangerousAttacksHome = homeStats?.avg_dangerous_attacks || 0;
            const avgDangerousAttacksAway = awayStats?.avg_dangerous_attacks || 0;
            
            // Min ro≈ºne
            const homeRecent = homeStats?.recent_matches || [];
            const awayRecent = awayStats?.recent_matches || [];
            
            const homeValidCorners = homeRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            const awayValidCorners = awayRecent.slice(0, 5).map(m => m.totalCornerCount || -1).filter(v => v !== -1 && v !== 999);
            
            const minCornersHome = homeValidCorners.length > 0 ? Math.min(...homeValidCorners) : 0;
            const minCornersAway = awayValidCorners.length > 0 ? Math.min(...awayValidCorners) : 0;
            
            // ≈örednia ≈ÇƒÖcznych ro≈ºnych
            const avgTotalCornersHome = homeValidCorners.length > 0 
                ? homeValidCorners.reduce((sum, v) => sum + v, 0) / homeValidCorners.length 
                : 0;
            const avgTotalCornersAway = awayValidCorners.length > 0 
                ? awayValidCorners.reduce((sum, v) => sum + v, 0) / awayValidCorners.length 
                : 0;
            
            // Trend
            let trendOk = false;
            for (const stats of [homeStats, awayStats]) {
                const recent = stats?.recent_matches || [];
                if (recent.length >= 4) {
                    const first2 = recent.slice(0, 2);
                    const last2 = recent.slice(-2);
                    const first2Avg = first2.reduce((sum, m) => sum + (m.totalCornerCount || 0), 0) / 2;
                    const last2Avg = last2.reduce((sum, m) => sum + (m.totalCornerCount || 0), 0) / 2;
                    if (last2Avg > first2Avg) {
                        trendOk = true;
                        break;
                    }
                }
            }
            
            // Kategorie
            const categories = [];
            let score = 0;
            
            // 1. Over 9.5
            const avgOver95 = (homePercent + awayPercent) / 2;
            const sumOver95 = homePercent + awayPercent;
            const meetsOver95 = (
                avgOver95 >= 60 ||
                sumOver95 >= 100 ||
                (homePercent >= 60 && awayPercent >= 40) ||
                (awayPercent >= 60 && homePercent >= 40)
            );
            if (meetsOver95) {
                categories.push(`‚úì Over 9.5 ‚â• 60% (${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%)`);
                score++;
            } else {
                categories.push(`‚úó Over 9.5 = ${homePercent.toFixed(2)}% | ${awayPercent.toFixed(2)}%`);
            }
            
            // 2. Strza≈Çy
            if (avgShotsHome > 15 && avgShotsAway > 15) {
                categories.push(`‚úì Strza≈Çy > 15 (${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Strza≈Çy = ${avgShotsHome.toFixed(1)} | ${avgShotsAway.toFixed(1)}`);
            }
            
            // 3. Posiadanie
            if (avgPossessionHome >= 45 && avgPossessionAway >= 45) {
                categories.push(`‚úì Posiadanie ‚â• 45% (${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%)`);
                score++;
            } else {
                categories.push(`‚úó Posiadanie = ${avgPossessionHome.toFixed(0)}% | ${avgPossessionAway.toFixed(0)}%`);
            }
            
            // 4. Niebezpieczne ataki
            if (avgDangerousAttacksHome > 50 && avgDangerousAttacksAway > 50) {
                categories.push(`‚úì Ataki > 50 (${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó Ataki = ${avgDangerousAttacksHome.toFixed(1)} | ${avgDangerousAttacksAway.toFixed(1)}`);
            }
            
            // 5. ≈ör ≈ÇƒÖczne ro≈ºne
            if (avgTotalCornersHome > 9.5 && avgTotalCornersAway > 9.5) {
                categories.push(`‚úì ≈ör ≈ÇƒÖczne ro≈ºne > 9.5 (${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)})`);
                score++;
            } else {
                categories.push(`‚úó ≈ör ≈ÇƒÖczne ro≈ºne = ${avgTotalCornersHome.toFixed(1)} vs ${avgTotalCornersAway.toFixed(1)}`);
            }
            
            // 6. Min ro≈ºne
            if (minCornersHome >= 7 && minCornersAway >= 7) {
                categories.push(`‚úì Min ro≈ºne ‚â• 7 (${minCornersHome} vs ${minCornersAway})`);
                score++;
            } else {
                categories.push(`‚úó Min ro≈ºne = ${minCornersHome} vs ${minCornersAway}`);
            }
            
            // 7. Trend
            if (trendOk) {
                categories.push('‚úì Trend rising');
                score++;
            } else {
                categories.push('‚úó Trend rising');
            }
            
            const qualified = meetsBasic && score >= 4;
            
            return {
                qualified,
                score,
                categories,
                percent_sum: sumOver95,
                home_percent: homePercent,
                away_percent: awayPercent,
                home_stats: homeStats,
                away_stats: awayStats
            };
        }

        // Fetch league names
        async function fetchLeagueNames() {
            try {
                const saved = localStorage.getItem('leaguesMap');
                if (saved) {
                    return JSON.parse(saved);
                }
                
                const proxy = getProxy();
                let url;
                if (USE_PROXY) {
                    url = `${proxy}${BASE_URL}/league-list?key=${API_KEY}`;
                } else {
                    url = `${BASE_URL}/league-list`;
                }
                const response = await fetch(url);
                
                if (!response.ok) return {};
                
                const data = await response.json();
                if (!data.success || !data.data) return {};
                
                const leaguesMap = {};
                data.data.forEach(league => {
                    const seasons = league.season || [];
                    seasons.forEach(season => {
                        if (season.id) {
                            const country = league.country || '';
                            const leagueName = league.league_name || league.name || '';
                            leaguesMap[season.id] = `${country} - ${leagueName}`;
                        }
                    });
                });
                
                localStorage.setItem('leaguesMap', JSON.stringify(leaguesMap));
                return leaguesMap;
            } catch (error) {
                console.error('B≈ÇƒÖd pobierania nazw lig:', error);
                return {};
            }
        }

        // Utw√≥rz hash z mecz√≥w dla por√≥wnania
        function createMatchesHash(matches) {
            if (!matches || matches.length === 0) return '';
            // Sortuj mecze i stw√≥rz hash z ID i dat
            const sorted = [...matches].sort((a, b) => (a.id || 0) - (b.id || 0));
            const ids = sorted.map(m => `${m.id}_${m.date_unix}_${m.status}`).join('|');
            return ids;
        }

        // Analyze Over 9.5 matches
        async function analyzeOver95() {
            if (matchesData.length === 0) {
                displayMessage('Najpierw pobierz mecze!', 'warning');
                return;
            }
            
            // Sprawd≈∫ czy mecze siƒô zmieni≈Çy od ostatniej analizy
            const currentHash = createMatchesHash(matchesData);
            const cachedAnalysis = localStorage.getItem('lastAnalysis');
            const cachedHash = localStorage.getItem('lastAnalysisHash');
            
                if (cachedAnalysis && cachedHash === currentHash && analyzedMatches.length === 0) {
                // Wczytaj z cache
                try {
                    const parsed = JSON.parse(cachedAnalysis);
                    analyzedMatches = parsed;
                    console.log(`üìã Wczytano analizƒô z cache (${analyzedMatches.length} mecz√≥w)`);
                    
                    // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                    const qualifiedElement = document.getElementById('qualified-matches');
                    if (qualifiedElement) {
                        qualifiedElement.textContent = analyzedMatches.length;
                    }
                    
                    displayAnalysisResults();
                    document.getElementById('analysisModal').style.display = 'block';
                    displayMessage(`‚úì Wy≈õwietlono poprzedniƒÖ analizƒô (${analyzedMatches.length} mecz√≥w). Aby wykonaƒá ponownie, u≈ºyj "Analizuj ponownie"`, 'info');
                    return;
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu cache analizy:', e);
                }
            }
            
            // Je≈õli mecze siƒô nie zmieni≈Çy ale mamy ju≈º wyniki w pamiƒôci, u≈ºyj ich
            if (currentHash === lastAnalysisHash && analyzedMatches.length > 0) {
                console.log('üìã U≈ºywam wynik√≥w z pamiƒôci (mecze nie zmieni≈Çy siƒô)');
                
                // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                displayAnalysisResults();
                document.getElementById('analysisModal').style.display = 'block';
                displayMessage(`‚úì Wy≈õwietlono analizƒô z pamiƒôci (${analyzedMatches.length} mecz√≥w)`, 'info');
                return;
            }
            
            showLoading(true);
            displayMessage('Analizowanie mecz√≥w...', 'info');
            
            try {
                // Pobierz nazwy lig
                const leaguesMap = await fetchLeagueNames();
                
                // Pobierz statystyki dla wszystkich dru≈ºyn
                analyzedMatches = [];
                let processed = 0;
                const total = matchesData.length;
                
                for (const match of matchesData) {
                    processed++;
                    const progress = Math.round((processed / total) * 100);
                    displayMessage(`Analizowanie meczu ${processed}/${total} (${progress}%)...`, 'info');
                    
                    const competitionId = match.competition_id;
                    const homeId = match.homeID;
                    const awayId = match.awayID;
                    
                    if (!competitionId || !homeId || !awayId) {
                        continue;
                    }
                    
                    // Pobierz statystyki obu dru≈ºyn
                    const [homeStats, awayStats] = await Promise.all([
                        fetchTeamStats(homeId, competitionId),
                        fetchTeamStats(awayId, competitionId)
                    ]);
                    
                    if (!homeStats || !awayStats) {
                        continue;
                    }
                    
                    // Analizuj mecz
                    const analysis = analyzeMatch(match, homeStats, awayStats);
                    
                    if (analysis.qualified) {
                        analyzedMatches.push({
                            match,
                            league: leaguesMap[competitionId] || `Liga ID: ${competitionId}`,
                            analysis,
                            home_name: match.home_name,
                            away_name: match.away_name,
                            time: match.date_unix ? new Date(match.date_unix * 1000).toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' }) : '-'
                        });
                    }
                    
                    // Op√≥≈∫nienie miƒôdzy requestami
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Sortuj wed≈Çug score i percent_sum
                analyzedMatches.sort((a, b) => {
                    if (b.analysis.score !== a.analysis.score) {
                        return b.analysis.score - a.analysis.score;
                    }
                    return b.analysis.percent_sum - a.analysis.percent_sum;
                });
                
                // Zapisz do cache
                lastAnalysisHash = currentHash;
                localStorage.setItem('lastAnalysis', JSON.stringify(analyzedMatches));
                localStorage.setItem('lastAnalysisHash', currentHash);
                
                // Automatycznie zapisz do historii je≈õli to pierwsza analiza dzisiaj
                if (analyzedMatches.length > 0) {
                    try {
                        const today = new Date().toISOString().split('T')[0];
                        const savedHistory = localStorage.getItem('over95_history');
                        let history = savedHistory ? JSON.parse(savedHistory) : [];
                        
                        // Sprawd≈∫ czy ju≈º zapisano mecze dzisiaj (sprawd≈∫ pole saved_date lub ostatni zapis)
                        let lastSaveDate = null;
                        const lastSaveDateStr = localStorage.getItem('lastHistorySaveDate');
                        if (lastSaveDateStr) {
                            lastSaveDate = lastSaveDateStr;
                        } else if (history.length > 0) {
                            // Fallback: sprawd≈∫ datƒô ostatniego meczu (je≈õli nie ma saved_date)
                            const lastMatch = history.reduce((latest, match) => {
                                const matchSavedDate = match.saved_date || (match.date_unix ? new Date(match.date_unix * 1000).toISOString().split('T')[0] : null);
                                const latestSavedDate = latest.saved_date || (latest.date_unix ? new Date(latest.date_unix * 1000).toISOString().split('T')[0] : null);
                                return (matchSavedDate && matchSavedDate > (latestSavedDate || '')) ? match : latest;
                            });
                            if (lastMatch.saved_date) {
                                lastSaveDate = lastMatch.saved_date;
                            } else if (lastMatch.date_unix) {
                                lastSaveDate = new Date(lastMatch.date_unix * 1000).toISOString().split('T')[0];
                            }
                        }
                        
                        // Je≈õli nie zapisano dzisiaj, zapisz automatycznie
                        if (lastSaveDate !== today) {
                            let savedCount = 0;
                            analyzedMatches.forEach(item => {
                                const { match, league, analysis } = item;
                                
                                // Sprawd≈∫ czy mecz ju≈º istnieje w historii
                                const matchId = match.id || `${match.homeID}_${match.awayID}_${match.date_unix}`;
                                const alreadyExists = history.some(h => 
                                    (h.api_match_id === match.id) ||
                                    (h.match_id === matchId) ||
                                    (h.home_id === match.homeID && h.away_id === match.awayID && 
                                     h.date_unix === match.date_unix)
                                );
                                
                                if (!alreadyExists) {
                                    const historyEntry = {
                                        match_id: matchId,
                                        api_match_id: match.id,
                                        home_id: match.homeID,
                                        away_id: match.awayID,
                                        home_name: match.home_name || item.home_name,
                                        away_name: match.away_name || item.away_name,
                                        league_name: league.split(' - ').slice(-1)[0] || league,
                                        country: league.split(' - ')[0] || '',
                                        date_unix: match.date_unix || 0,
                                        date_formatted: match.date_unix ? new Date(match.date_unix * 1000).toLocaleString('pl-PL') : 'N/A',
                                        saved_date: today, // Data zapisu do historii
                                        over95_percentages: [analysis.home_percent, analysis.away_percent],
                                        home_stats: analysis.home_stats || {},
                                        away_stats: analysis.away_stats || {},
                                        categories: analysis.categories || [],
                                        score: analysis.score || 0,
                                        percent_sum: analysis.percent_sum || 0,
                                        status: 'pending',
                                        result: 'pending',
                                        match: match,
                                        analysis: analysis,
                                        league: league
                                    };
                                    history.push(historyEntry);
                                    savedCount++;
                                }
                            });
                            
                            if (savedCount > 0) {
                                localStorage.setItem('over95_history', JSON.stringify(history));
                                localStorage.setItem('lastHistorySaveDate', today);
                                console.log(`üíæ Automatycznie zapisano ${savedCount} mecz√≥w do historii (pierwsza analiza dzisiaj)`);
                                displayMessage(`üíæ Automatycznie zapisano ${savedCount} mecz√≥w do historii`, 'success');
                            }
                        }
                    } catch (e) {
                        console.error('B≈ÇƒÖd podczas automatycznego zapisu do historii:', e);
                    }
                }
                
                // Aktualizuj statystyki na stronie g≈Ç√≥wnej
                const qualifiedElement = document.getElementById('qualified-matches');
                if (qualifiedElement) {
                    qualifiedElement.textContent = analyzedMatches.length;
                }
                
                showLoading(false);
                displayAnalysisResults();
                document.getElementById('analysisModal').style.display = 'block';
                
                if (analyzedMatches.length > 0) {
                    displayMessage(`‚úì Znaleziono ${analyzedMatches.length} kwalifikujƒÖcych siƒô mecz√≥w!`, 'success');
                } else {
                    displayMessage('‚ÑπÔ∏è Nie znaleziono mecz√≥w spe≈ÇniajƒÖcych kryteria Over 9.5', 'info');
                }
                
            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd analizy:', error);
                displayMessage('B≈ÇƒÖd analizy: ' + error.message, 'error');
            }
        }

        // Display analysis results
        function displayAnalysisResults() {
            const content = document.getElementById('analysis-content');
            
            if (analyzedMatches.length === 0) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center;">
                            Brak mecz√≥w kwalifikujƒÖcych siƒô do Over 9.5.<br>
                            ≈ªaden mecz nie spe≈Çnia wymaganych kryteri√≥w (‚â•50% oba zespo≈Çy i ‚â•4 z 7 kryteri√≥w).
                        </p>
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="analyzeOver95()" class="btn btn-primary">üîÑ Analizuj ponownie</button>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="color: #EF0107; margin-bottom: 10px;">‚úÖ Znaleziono ${analyzedMatches.length} mecz√≥w kwalifikujƒÖcych siƒô</h3>
                            <p style="color: #FFFFFF;">Mecze posortowane wed≈Çug score (najwy≈ºszy pierwszy)</p>
                        </div>
                        <button onclick="forceReanalyze()" class="btn btn-secondary" style="padding: 10px 20px; font-size: 14px;">üîÑ Analizuj ponownie</button>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            `;
            
            // Podziel mecze na dwie kolumny
            const midPoint = Math.ceil(analyzedMatches.length / 2);
            const leftColumn = analyzedMatches.slice(0, midPoint);
            const rightColumn = analyzedMatches.slice(midPoint);
            
            // Funkcja do generowania HTML dla meczu
            const generateMatchHTML = (item) => {
                const { match, league, analysis } = item;
                const basicRequirement = analysis.home_percent >= 50 && analysis.away_percent >= 50;
                const basicText = basicRequirement 
                    ? `‚úì WYMAGANIE PODSTAWOWE: Oba zespo≈Çy ‚â• 50% (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`
                    : `‚úó WYMAGANIE PODSTAWOWE: Oba zespo≈Çy ‚â• 50% - NIE SPE≈ÅNIONE (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)`;
                
                return `
                    <div class="card" style="margin-bottom: 20px;">
                        <div class="card-header">
                            üèÜ ${league}
                        </div>
                        <div style="padding: 15px;">
                            <h3 style="color: #FFFFFF; margin-bottom: 15px; font-size: 1.2em;">
                                ${item.time} | ${item.home_name} vs ${item.away_name}
                            </h3>
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(2, 52, 116, 0.2); border-radius: 8px;">
                                <p style="color: #FFFFFF; margin: 5px 0;">
                                    <strong>Suma %:</strong> ${analysis.percent_sum.toFixed(2)}% 
                                    (${analysis.home_percent.toFixed(2)}% | ${analysis.away_percent.toFixed(2)}%)
                                </p>
                                <p style="color: #EF0107; margin: 5px 0; font-size: 1.1em; font-weight: bold;">
                                    Score: ${analysis.score}/7
                                </p>
                            </div>
                            
                            <div style="margin-top: 15px;">
                                <p style="color: ${basicRequirement ? '#4CAF50' : '#EF0107'}; margin: 5px 0;">
                                    ${basicText}
                                </p>
                                <p style="color: #FFFFFF; margin-top: 10px; font-weight: bold;">Szczeg√≥≈Çy wymaga≈Ñ:</p>
                                ${analysis.categories.map(cat => {
                                    const color = cat.startsWith('‚úì') ? '#4CAF50' : cat.startsWith('‚úó') ? '#EF0107' : '#FFFFFF';
                                    return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            };
            
            // Lewa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            leftColumn.forEach(item => {
                html += generateMatchHTML(item);
            });
            html += '</div>';
            
            // Prawa kolumna
            html += '<div style="display: flex; flex-direction: column;">';
            rightColumn.forEach(item => {
                html += generateMatchHTML(item);
            });
            html += '</div>';
            
            html += '</div>';
            
            content.innerHTML = html;
        }

        // Wymu≈õ ponownƒÖ analizƒô (ignoruj cache)
        async function forceReanalyze() {
            console.log('üîÑ Wymuszam ponownƒÖ analizƒô...');
            lastAnalysisHash = null;
            analyzedMatches = [];
            localStorage.removeItem('lastAnalysis');
            localStorage.removeItem('lastAnalysisHash');
            await analyzeOver95();
        }

        // Weryfikuj wyniki mecz√≥w w historii
        async function verifyHistoryResults() {
            const savedHistory = localStorage.getItem('over95_history');
            if (!savedHistory) {
                displayMessage('Brak historii do weryfikacji', 'warning');
                return;
            }
            
            showLoading(true);
            displayMessage('Weryfikowanie wynik√≥w mecz√≥w...', 'info');
            
            try {
                let history = JSON.parse(savedHistory);
                let verifiedCount = 0;
                let updatedCount = 0;
                
                // Znajd≈∫ mecze kt√≥re wymagajƒÖ weryfikacji (status pending)
                const pendingMatches = history.filter(m => m.status === 'pending' || m.result === 'pending');
                
                if (pendingMatches.length === 0) {
                    showLoading(false);
                    displayMessage('Wszystkie mecze sƒÖ ju≈º zweryfikowane', 'info');
                    return;
                }
                
                displayMessage(`Weryfikowanie ${pendingMatches.length} mecz√≥w...`, 'info');
                
                for (let i = 0; i < pendingMatches.length; i++) {
                    const match = pendingMatches[i];
                    const matchId = match.api_match_id;
                    
                    if (!matchId) {
                        console.log(`‚ö†Ô∏è Pomijam mecz ${match.home_name} vs ${match.away_name} - brak api_match_id`);
                        continue;
                    }
                    
                    try {
                        // Pobierz dane meczu z API
                        const proxy = getProxy();
                        let url;
                        if (USE_PROXY) {
                            url = `${proxy}${BASE_URL}/match?key=${API_KEY}&match_id=${matchId}`;
                        } else {
                            url = `${BASE_URL}/match?match_id=${matchId}`;
                        }
                        
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        if (!data.success || !data.data) continue;
                        
                        const matchData = data.data;
                        const status = matchData.status;
                        
                        // Sprawd≈∫ czy mecz siƒô zako≈Ñczy≈Ç
                        if (status === 'complete') {
                            const totalCorners = matchData.totalCornerCount || 0;
                            const expectedCorners = 9.5;
                            
                            // Aktualizuj status w historii
                            const historyIndex = history.findIndex(h => 
                                h.api_match_id === matchId || 
                                (h.match_id === match.match_id)
                            );
                            
                            if (historyIndex !== -1) {
                                const result = totalCorners > expectedCorners ? 'won' : 'lost';
                                history[historyIndex].status = 'verified';
                                history[historyIndex].result = result;
                                history[historyIndex].actual_corners = totalCorners;
                                history[historyIndex].match = matchData;
                                updatedCount++;
                                console.log(`‚úì Zaktualizowano ${match.home_name} vs ${match.away_name}: ${result} (${totalCorners} ro≈ºnych)`);
                            }
                        }
                        
                        verifiedCount++;
                        
                        // Op√≥≈∫nienie miƒôdzy requestami
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`B≈ÇƒÖd weryfikacji meczu ${match.home_name} vs ${match.away_name}:`, error);
                    }
                }
                
                // Zapisz zaktualizowanƒÖ historiƒô
                if (updatedCount > 0) {
                    localStorage.setItem('over95_history', JSON.stringify(history));
                    displayMessage(`‚úì Zaktualizowano ${updatedCount} mecz√≥w w historii`, 'success');
                    // Od≈õwie≈º wy≈õwietlanie historii
                    showHistory();
                } else {
                    displayMessage('Brak mecz√≥w do aktualizacji', 'info');
                }
                
                showLoading(false);
            } catch (error) {
                showLoading(false);
                console.error('B≈ÇƒÖd weryfikacji:', error);
                displayMessage('B≈ÇƒÖd podczas weryfikacji: ' + error.message, 'error');
            }
        }

        // Show history
        function showHistory() {
            const savedHistory = localStorage.getItem('over95_history');
            const content = document.getElementById('history-content');
            
            if (!savedHistory) {
                content.innerHTML = `
                    <div class="card">
                        <p style="color: #FFFFFF; text-align: center; padding: 40px;">
                            üìã Brak historii mecz√≥w.<br>
                            <span style="color: rgba(255,255,255,0.7); font-size: 0.9em;">
                                Po analizie i zapisaniu mecz√≥w, pojawiƒÖ siƒô tutaj.
                            </span>
                        </p>
                    </div>
                `;
            } else {
                try {
                    const history = JSON.parse(savedHistory);
                    
                    // Grupuj mecze wed≈Çug daty
                    const matchesByDate = {};
                    history.forEach(match => {
                        const dateUnix = match.date_unix || match.match?.date_unix || 0;
                        if (dateUnix) {
                            const date = new Date(dateUnix * 1000);
                            const dateStr = date.toLocaleDateString('pl-PL', { 
                                year: 'numeric', 
                                month: 'long', 
                                day: 'numeric' 
                            });
                            
                            if (!matchesByDate[dateStr]) {
                                matchesByDate[dateStr] = [];
                            }
                            matchesByDate[dateStr].push(match);
                        }
                    });
                    
                    // Sortuj daty (najnowsze pierwsze)
                    const sortedDates = Object.keys(matchesByDate).sort((a, b) => {
                        return new Date(b) - new Date(a);
                    });
                    
                    let html = `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(239, 1, 7, 0.2); border-radius: 10px; border-left: 4px solid #EF0107;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <h3 style="color: #EF0107; margin-bottom: 10px;">üìú Historia analizowanych mecz√≥w</h3>
                                    <p style="color: #FFFFFF;">≈ÅƒÖcznie: ${history.length} mecz√≥w w historii</p>
                                </div>
                                <button onclick="verifyHistoryResults()" class="btn btn-secondary" style="
                                    padding: 12px 24px;
                                    font-size: 16px;
                                    white-space: nowrap;
                                ">üîÑ Weryfikuj Wyniki</button>
                            </div>
                        </div>
                    `;
                    
                    // Wy≈õwietl mecze wed≈Çug dat
                    sortedDates.forEach(dateStr => {
                        const matches = matchesByDate[dateStr];
                        
                        html += `
                            <div class="card" style="margin-bottom: 20px;">
                                <div class="card-header">
                                    üìÖ ${dateStr} (${matches.length} ${matches.length === 1 ? 'mecz' : 'mecz√≥w'})
                                </div>
                        `;
                        
                        matches.forEach((match, matchIdx) => {
                            const matchData = match.match || match;
                            const homeName = match.home_name || matchData.home_name || 'N/A';
                            const awayName = match.away_name || matchData.away_name || 'N/A';
                            const league = match.league || match.league_name || matchData.competition_id || 'N/A';
                            const status = match.result || match.status || 'pending';
                            const actualCorners = match.actual_corners || matchData.totalCornerCount || '-';
                            const score = match.score || match.analysis?.score || 0;
                            
                            let statusBadge = '';
                            let statusColor = '#FF9800';
                            if (status === 'won') {
                                statusBadge = '<span class="badge badge-success">‚úÖ Wygra≈Ç</span>';
                                statusColor = '#4CAF50';
                            } else if (status === 'lost') {
                                statusBadge = '<span class="badge badge-danger">‚ùå Przegra≈Ç</span>';
                                statusColor = '#EF0107';
                            } else {
                                statusBadge = '<span class="badge badge-warning">‚è≥ Oczekuje</span>';
                            }
                            
                            const matchId = `history_${dateStr.replace(/\s+/g, '_')}_${matchIdx}`;
                            window[matchId] = match; // Zapisz match w globalnym scope
                            
                            // Wy≈õwietl ro≈ºne - je≈õli mecz oczekuje, poka≈º klepsydrƒô zamiast -1
                            let cornersDisplay = actualCorners;
                            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                                cornersDisplay = '‚è≥';
                            }
                            
                            html += `
                                <div class="match-item" style="border-left-color: ${statusColor};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 15px;">
                                        <div style="flex: 1;">
                                            <div class="match-teams">${homeName} vs ${awayName}</div>
                                            <div class="match-league">${league}</div>
                                            <div style="margin-top: 10px;">
                                                ${statusBadge}
                                                <span style="color: #FFFFFF; margin-left: 10px;">
                                                    Rzut√≥w ro≈ºnych: <strong>${cornersDisplay}</strong> | Score: <strong>${score}/7</strong>
                                                </span>
                                            </div>
                                        </div>
                                        <button onclick="showMatchHistoryDetails(window['${matchId}'])" class="btn btn-secondary" style="
                                            padding: 12px 24px;
                                            font-size: 14px;
                                            white-space: nowrap;
                                            min-width: 120px;
                                        ">üîç Szczeg√≥≈Çy</button>
                                    </div>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                    });
                    
                    content.innerHTML = html;
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu historii:', e);
                    content.innerHTML = `
                        <div class="card">
                            <p style="color: #EF0107; text-align: center; padding: 40px;">
                                ‚ùå B≈ÇƒÖd odczytu historii: ${e.message}
                            </p>
                        </div>
                    `;
                }
            }
            
            document.getElementById('historyModal').style.display = 'block';
        }

        // Poka≈º szczeg√≥≈Çy meczu z historii
        function showMatchHistoryDetails(match) {
            if (!match) {
                displayMessage('B≈ÇƒÖd: brak danych meczu', 'error');
                return;
            }
            
            const matchData = match.match || match;
            const homeName = match.home_name || matchData.home_name || 'N/A';
            const awayName = match.away_name || matchData.away_name || 'N/A';
            const league = match.league || match.league_name || 'N/A';
            const status = match.result || match.status || 'pending';
            let actualCorners = match.actual_corners || matchData.totalCornerCount;
            if (status === 'pending' && (actualCorners === '-' || actualCorners === -1 || actualCorners === null || actualCorners === undefined)) {
                actualCorners = '‚è≥';
            }
            const score = match.score || match.analysis?.score || 0;
            const categories = match.categories || match.analysis?.categories || [];
            const percentSum = match.percent_sum || match.analysis?.percent_sum || 0;
            
            let statusText = '';
            let statusColor = '#FF9800';
            if (status === 'won') {
                statusText = '‚úÖ Wygra≈Ç';
                statusColor = '#4CAF50';
            } else if (status === 'lost') {
                statusText = '‚ùå Przegra≈Ç';
                statusColor = '#EF0107';
            } else {
                statusText = '‚è≥ Oczekuje';
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">
                        ${homeName} vs ${awayName}
                    </div>
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 20px;">
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Liga:</strong> ${league}</p>
                            <p style="color: ${statusColor}; margin: 5px 0;"><strong>Status:</strong> ${statusText}</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Rzut√≥w ro≈ºnych:</strong> ${actualCorners}</p>
                            <p style="color: #EF0107; margin: 5px 0; font-size: 1.2em;"><strong>Score:</strong> ${score}/7</p>
                            <p style="color: #FFFFFF; margin: 5px 0;"><strong>Suma %:</strong> ${percentSum.toFixed(1)}%</p>
                        </div>
                        
                        ${categories.length > 0 ? `
                            <div style="margin-top: 20px;">
                                <h4 style="color: #FFFFFF; margin-bottom: 10px;">Kryteria:</h4>
                                ${categories.map(cat => {
                                    const color = cat.startsWith('‚úì') ? '#4CAF50' : cat.startsWith('‚úó') ? '#EF0107' : '#FFFFFF';
                                    return `<p style="color: ${color}; margin: 5px 0; padding-left: 20px;">${cat}</p>`;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            // Utw√≥rz nowy modal dla szczeg√≥≈Ç√≥w
            const detailsModal = document.createElement('div');
            detailsModal.className = 'modal';
            detailsModal.id = 'historyDetailsModal';
            detailsModal.innerHTML = `
                <div class="modal-content">
                    <span class="close" onclick="closeModal('historyDetailsModal')">&times;</span>
                    <h2 style="color: #EF0107; margin-bottom: 20px;">üîç Szczeg√≥≈Çy meczu</h2>
                    ${html}
                </div>
            `;
            document.body.appendChild(detailsModal);
            detailsModal.style.display = 'block';
        }

        // Utility functions
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function displayMessage(message, type = 'info') {
            const colors = {
                'info': '#023474',
                'success': '#4CAF50',
                'error': '#EF0107',
                'warning': '#FF9800'
            };
            
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type]};
                color: #FFFFFF;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 2000;
                animation: slideIn 0.3s;
            `;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.animation = 'slideOut 0.3s';
                setTimeout(() => messageDiv.remove(), 300);
            }, 3000);
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('Corner Predictor initialized');
            
            // Spr√≥buj za≈Çadowaƒá nazwy lig
            await fetchLeagueNames();
            
            // Spr√≥buj za≈Çadowaƒá dane z localStorage
            const savedMatches = localStorage.getItem('matchesData');
            const savedDate = localStorage.getItem('matchesDate');
            const today = new Date().toISOString().split('T')[0];
            
            if (savedMatches && savedDate === today) {
                try {
                    const parsed = JSON.parse(savedMatches);
                    // Filtruj te≈º z cache (na wypadek je≈õli by≈Çy w cache mecze z jutra)
                    const todayUTC = new Date().toISOString().split('T')[0];
                    const todayStart = Math.floor(new Date(todayUTC + 'T00:00:00Z').getTime() / 1000);
                    const todayEnd = todayStart + 86399;
                    
                    matchesData = parsed.filter(match => {
                        const matchDateUnix = match.date_unix;
                        if (!matchDateUnix) return false;
                        return matchDateUnix >= todayStart && matchDateUnix <= todayEnd;
                    });
                    displayMatches();
                    displayMessage('Za≈Çadowano dane z cache', 'info');
                } catch (e) {
                    console.error('B≈ÇƒÖd odczytu cache:', e);
                }
            }
            
        });
    </script>
</body>
</html>

